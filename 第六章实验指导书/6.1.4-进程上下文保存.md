# 6.1.4 进程上下文保存

## 本节新增文件

```
os/src/process/
├── mod.rs          # 进程管理模块入口（已存在）
├── pid.rs          # PID分配器（已完成）
├── pcb.rs          # 进程控制块（本节继续补充）
└── context.rs      # 进程上下文结构（新建）
```

---

## 什么是进程上下文？

**进程上下文（Process Context）** 是进程的执行状态快照，包含CPU寄存器的所有值。

### 为什么需要保存上下文？

当操作系统进行**进程切换**时：
1. 保存当前进程的上下文（所有寄存器）
2. 恢复下一个进程的上下文
3. 跳转到下一个进程继续执行

**类比**：
- 你在做数学作业（进程A）
- 妈妈喊你吃饭（中断）
- 你记下做到第几题（保存上下文）
- 吃完饭回来继续做（恢复上下文）

---

## RISC-V寄存器回顾

RISC-V有**32个通用寄存器** + **CSR寄存器**：

### 通用寄存器（x0-x31）

| 寄存器 | 别名 | 用途 | 是否需要保存 |
|--------|------|------|------------|
| x0 | zero | 硬件固定为0 | ❌ 不需要 |
| x1 | ra | 返回地址 | ✅ 需要 |
| x2 | sp | 栈指针 | ✅ 需要 |
| x3 | gp | 全局指针 | ✅ 需要 |
| x4 | tp | 线程指针 | ✅ 需要 |
| x5-x7 | t0-t2 | 临时寄存器 | ✅ 需要 |
| x8-x9 | s0-s1 | 保存寄存器 | ✅ 需要 |
| x10-x17 | a0-a7 | 参数/返回值 | ✅ 需要 |
| x18-x27 | s2-s11 | 保存寄存器 | ✅ 需要 |
| x28-x31 | t3-t6 | 临时寄存器 | ✅ 需要 |

### CSR寄存器

| 寄存器 | 用途 | 是否需要保存 |
|--------|------|------------|
| sepc | 异常返回地址 | ✅ 需要 |
| sstatus | 处理器状态 | ✅ 需要 |
| satp | 页表基址 | ⚠️ 特殊处理 |

**总共需要保存**：31个通用寄存器 + 3个CSR = **34个寄存器**

---

## 步骤1：创建context.rs

### 1.1 创建文件

```bash
touch os/src/process/context.rs
```

### 1.2 在mod.rs中注册

```rust
// os/src/process/mod.rs
pub mod pid;
pub mod pcb;
pub mod context;  // ← 新增

pub use pid::ProcessId;
pub use pcb::ProcessState;
pub use context::ProcessContext;  // ← 新增
```

---

## 步骤2：定义ProcessContext结构

在 `os/src/process/context.rs` 中：

```rust
/// 进程上下文
///
/// 保存进程的所有CPU寄存器状态
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct ProcessContext {
    /// 通用寄存器 x1-x31（x0固定为0，不需要保存）
    pub x: [usize; 31],
    
    /// sepc: 异常返回地址
    pub sepc: usize,
    
    /// sstatus: 处理器状态寄存器
    pub sstatus: usize,
    
    /// satp: 页表基址寄存器
    pub satp: usize,
}
```

**关键点**：

### `#[repr(C)]`
- 使用C语言的内存布局
- 保证字段顺序和汇编代码一致
- 便于汇编直接访问

### `#[derive(Copy)]`
- 允许按值复制整个上下文
- 复制开销：34 * 8 = 272字节

---

## 步骤3：实现上下文初始化

```rust
impl ProcessContext {
    /// 创建空白上下文
    pub const fn new() -> Self {
        ProcessContext {
            x: [0; 31],
            sepc: 0,
            sstatus: 0,
            satp: 0,
        }
    }
}
```

---

## 步骤4：添加寄存器访问方法

为了方便访问，添加别名方法：

```rust
impl ProcessContext {
    /// 获取栈指针（sp = x2）
    pub fn sp(&self) -> usize {
        self.x[1]  // x[1]对应x2
    }
    
    /// 设置栈指针
    pub fn set_sp(&mut self, sp: usize) {
        self.x[1] = sp;
    }
    
    /// 获取返回地址（ra = x1）
    pub fn ra(&self) -> usize {
        self.x[0]  // x[0]对应x1
    }
    
    /// 设置返回地址
    pub fn set_ra(&mut self, ra: usize) {
        self.x[0] = ra;
    }
    
    /// 获取参数寄存器a0（x10）
    pub fn a0(&self) -> usize {
        self.x[9]  // x[9]对应x10
    }
    
    /// 设置参数寄存器a0
    pub fn set_a0(&mut self, a0: usize) {
        self.x[9] = a0;
    }
}
```

**为什么下标这么奇怪？**

因为x0固定为0不保存，所以：
- `x[0]` 实际存储 `x1`（ra）
- `x[1]` 实际存储 `x2`（sp）
- `x[9]` 实际存储 `x10`（a0）

---

## 步骤5：完整代码

<details>
<summary><b>点击展开：os/src/process/context.rs 完整实现</b></summary>

```rust
//! 进程上下文
//!
//! 保存进程的CPU寄存器状态，用于上下文切换

/// 进程上下文结构
///
/// 保存RISC-V的所有需要保存的寄存器：
/// - 31个通用寄存器（x1-x31，x0固定为0）
/// - 3个CSR寄存器（sepc, sstatus, satp）
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct ProcessContext {
    /// 通用寄存器 x1-x31
    /// 注意：x[0]对应x1，x[1]对应x2，以此类推
    pub x: [usize; 31],
    
    /// sepc: Supervisor Exception Program Counter
    /// 异常返回地址
    pub sepc: usize,
    
    /// sstatus: Supervisor Status Register
    /// 处理器状态寄存器
    pub sstatus: usize,
    
    /// satp: Supervisor Address Translation and Protection
    /// 页表基址寄存器
    pub satp: usize,
}

impl ProcessContext {
    /// 创建空白上下文（所有寄存器初始化为0）
    pub const fn new() -> Self {
        ProcessContext {
            x: [0; 31],
            sepc: 0,
            sstatus: 0,
            satp: 0,
        }
    }
    
    /// 获取栈指针（sp = x2）
    pub fn sp(&self) -> usize {
        self.x[1]
    }
    
    /// 设置栈指针
    pub fn set_sp(&mut self, sp: usize) {
        self.x[1] = sp;
    }
    
    /// 获取返回地址（ra = x1）
    pub fn ra(&self) -> usize {
        self.x[0]
    }
    
    /// 设置返回地址
    pub fn set_ra(&mut self, ra: usize) {
        self.x[0] = ra;
    }
    
    /// 获取参数寄存器a0（x10）
    pub fn a0(&self) -> usize {
        self.x[9]
    }
    
    /// 设置参数寄存器a0（用于系统调用返回值）
    pub fn set_a0(&mut self, a0: usize) {
        self.x[9] = a0;
    }
    
    /// 设置程序计数器（下一条要执行的指令）
    pub fn set_pc(&mut self, pc: usize) {
        self.sepc = pc;
    }
    
    /// 获取程序计数器
    pub fn pc(&self) -> usize {
        self.sepc
    }
}

impl Default for ProcessContext {
    fn default() -> Self {
        Self::new()
    }
}
```

</details>

---

## 步骤6：在PCB中使用Context

现在更新 `os/src/process/pcb.rs`，添加context字段：

```rust
use super::{ProcessId, ProcessContext};

pub struct ProcessControlBlock {
    pid: ProcessId,
    state: ProcessState,
    
    // 新增：进程上下文
    context: ProcessContext,
    
    // ... 其他字段
}
```

---

## 知识点总结

### 核心概念

| 概念 | 说明 |
|------|------|
| **进程上下文** | 进程的CPU寄存器快照 |
| **上下文切换** | 保存当前进程上下文，恢复下一个进程上下文 |
| **通用寄存器** | x1-x31，31个 |
| **CSR寄存器** | sepc, sstatus, satp |

### 设计决策

| 决策 | 理由 |
|------|------|
| 用数组存储x1-x31 | 便于汇编代码循环访问 |
| 使用`#[repr(C)]` | 保证与汇编代码的内存布局一致 |
| 实现Copy | 上下文很小（272字节），复制开销低 |
| 提供别名方法 | 提高代码可读性 |

### 寄存器映射表

| 数组下标 | 实际寄存器 | 别名 |
|---------|-----------|------|
| x[0] | x1 | ra |
| x[1] | x2 | sp |
| x[2] | x3 | gp |
| x[9] | x10 | a0 |
| x[10] | x11 | a1 |

---

## 下一步

现在我们有了：
- ✅ 6.1.2 - PID分配器
- ✅ 6.1.3 - 进程状态枚举
- ✅ 6.1.4 - 进程上下文保存（本节）

下一节（6.1.5）将实现**完整的PCB结构**，整合所有组件。

---

## 思考题

1. 为什么x0寄存器不需要保存？
2. 为什么要用`#[repr(C)]`？
3. 上下文切换时，如果忘记保存某个寄存器会发生什么？

<details>
<summary>答案提示</summary>

1. x0硬件固定为0，无论写入什么值都是0
2. 保证字段顺序与汇编代码期望的一致
3. 进程恢复时该寄存器的值会错误，可能导致程序崩溃

</details>
