# 6.2.2 上下文切换(下) - 汇编实现

## 本节目标

- 用RISC-V汇编实现寄存器保存与恢复
- 实现 `__switch` 核心函数
- 理解栈帧布局设计
- 完成可测试的上下文切换

---

## 新增文件

```
os/src/process/
├── switch.S          # 新增：上下文切换汇编代码
└── mod.rs            # 修改：导出switch函数
```

---

## 步骤1：创建汇编文件

在 `os/src/process/` 目录下创建 `switch.S`：

```assembly
# os/src/process/switch.S
# 上下文切换核心函数

.section .text
.globl __switch
```

**说明**：
- `.section .text`：代码段
- `.globl __switch`：导出符号，让Rust可以调用

---

## 步骤2：定义函数签名

### Rust侧声明

首先在 `os/src/process/context.rs` 添加：

```rust
extern "C" {
    /// 上下文切换
    ///
    /// # 参数
    /// - a0: &mut ProcessContext (当前进程上下文)
    /// - a1: &ProcessContext (目标进程上下文)
    pub fn __switch(
        current_cx: *mut ProcessContext,
        next_cx: *const ProcessContext,
    );
}
```

### 调用约定

RISC-V函数调用约定：
- **a0（x10）**：第一个参数 = 当前上下文指针
- **a1（x11）**：第二个参数 = 目标上下文指针

---

## 步骤3：理解寄存器保存策略

### Caller-Saved vs Callee-Saved

RISC-V ABI规定：

| 寄存器 | 名称 | 保存责任 | 是否需要保存？ |
|--------|------|----------|----------------|
| x1 (ra) | 返回地址 | Callee-Saved | ✅ 是 |
| x2 (sp) | 栈指针 | Callee-Saved | ✅ 是 |
| x8-x9 | s0-s1 | Callee-Saved | ✅ 是 |
| x18-x27 | s2-s11 | Callee-Saved | ✅ 是 |
| x10-x17 | a0-a7 | Caller-Saved | ❌ 否* |
| x5-x7 | t0-t2 | Caller-Saved | ❌ 否* |

**\*注意**：对于上下文切换，我们要保存**所有31个寄存器**，因为：
- 这不是普通函数调用
- 需要完整恢复进程状态

---

## 步骤4：计算上下文字段偏移

回顾 `ProcessContext` 定义：

```rust
#[repr(C)]
pub struct ProcessContext {
    pub x: [usize; 31],     // 偏移0, 大小31*8=248字节
    pub sepc: usize,        // 偏移248
    pub sstatus: usize,     // 偏移256
    pub satp: usize,        // 偏移264
}
```

### 汇编中的偏移计算

```assembly
# x[0] (x1) 在偏移 0
# x[1] (x2) 在偏移 8
# x[2] (x3) 在偏移 16
# ...
# x[30] (x31) 在偏移 240
# sepc 在偏移 248
# sstatus 在偏移 256
# satp 在偏移 264
```

---

## 步骤5：实现保存上下文

### 保存通用寄存器

```assembly
# os/src/process/switch.S
__switch:
    # a0 = 当前上下文地址
    # a1 = 目标上下文地址

    # === 保存当前进程上下文到 a0 ===

    # 保存 x1-x31（跳过x0，它固定为0）
    sd x1,  0(a0)    # 保存 ra (返回地址)
    sd x2,  8(a0)    # 保存 sp (栈指针)
    sd x3,  16(a0)   # 保存 gp
    sd x4,  24(a0)   # 保存 tp
    sd x5,  32(a0)   # 保存 t0
    sd x6,  40(a0)   # 保存 t1
    sd x7,  48(a0)   # 保存 t2
    sd x8,  56(a0)   # 保存 s0/fp
    sd x9,  64(a0)   # 保存 s1
```

### 保存CSR寄存器

```assembly
    # 保存CSR寄存器
    csrr t0, sepc
    sd t0, 248(a0)       # 保存 sepc

    csrr t0, sstatus
    sd t0, 256(a0)       # 保存 sstatus

    csrr t0, satp
    sd t0, 264(a0)       # 保存 satp
```

**为什么用t0作为中转**？

- CSR寄存器不能直接保存到内存
- 必须先读到通用寄存器，再存储

---

## 步骤6：实现恢复上下文

### 恢复CSR寄存器

```assembly
    # === 恢复目标进程上下文从 a1 ===

    # 先恢复CSR寄存器
    ld t0, 248(a1)       # 加载 sepc
    csrw sepc, t0

    ld t0, 256(a1)       # 加载 sstatus
    csrw sstatus, t0

    ld t0, 264(a1)       # 加载 satp
    csrw satp, t0

    # 刷新TLB
    sfence.vma
```

### 恢复通用寄存器

```assembly
    # 恢复 x1-x31
    ld x1,  0(a1)    # 恢复 ra
    ld x2,  8(a1)    # 恢复 sp
    ld x3,  16(a1)   # 恢复 gp
    ld x4,  24(a1)   # 恢复 tp
    ld x5,  32(a1)   # 恢复 t0
    ld x6,  40(a1)   # 恢复 t1
    ld x7,  48(a1)   # 恢复 t2
    ld x8,  56(a1)   # 恢复 s0
    ld x9,  64(a1)   # 恢复 s1
```

**注意顺序**：
1. 先恢复CSR（包括页表）
2. 刷新TLB
3. 再恢复通用寄存器

---

## 步骤7：返回目标进程

```assembly
    # 返回到目标进程
    ret
```

**ret的作用**：
- `ret` 是 `jalr x0, 0(x1)` 的伪指令
- 跳转到 `ra`（x1）寄存器指向的地址
- 相当于跳转到目标进程保存的返回地址

---

## 步骤8：完整汇编代码

<details>
<summary><b>点击展开：os/src/process/switch.S 完整实现</b></summary>

```assembly
# os/src/process/switch.S
# 上下文切换核心函数

.section .text
.globl __switch

# void __switch(
#     ProcessContext *current_cx,  // a0
#     ProcessContext *next_cx      // a1
# )
__switch:
    # === 保存当前进程上下文到 a0 ===

    # 保存通用寄存器 x1-x31
    sd x1,  0(a0)
    sd x2,  8(a0)
    sd x3,  16(a0)
    sd x4,  24(a0)
    sd x5,  32(a0)
    sd x6,  40(a0)
    sd x7,  48(a0)
    sd x8,  56(a0)
    sd x9,  64(a0)
    sd x10, 72(a0)
    sd x11, 80(a0)
    sd x12, 88(a0)
    sd x13, 96(a0)
    sd x14, 104(a0)
    sd x15, 112(a0)
    sd x16, 120(a0)
    sd x17, 128(a0)
    sd x18, 136(a0)
    sd x19, 144(a0)
    sd x20, 152(a0)
    sd x21, 160(a0)
    sd x22, 168(a0)
    sd x23, 176(a0)
    sd x24, 184(a0)
    sd x25, 192(a0)
    sd x26, 200(a0)
    sd x27, 208(a0)
    sd x28, 216(a0)
    sd x29, 224(a0)
    sd x30, 232(a0)
    sd x31, 240(a0)

    # 保存CSR寄存器
    csrr t0, sepc
    sd t0, 248(a0)

    csrr t0, sstatus
    sd t0, 256(a0)

    csrr t0, satp
    sd t0, 264(a0)

    # === 恢复目标进程上下文从 a1 ===

    # 恢复CSR寄存器
    ld t0, 248(a1)
    csrw sepc, t0

    ld t0, 256(a1)
    csrw sstatus, t0

    ld t0, 264(a1)
    csrw satp, t0

    # 刷新TLB
    sfence.vma

    # 恢复通用寄存器 x1-x31
    ld x1,  0(a1)
    ld x2,  8(a1)
    ld x3,  16(a1)
    ld x4,  24(a1)
    ld x5,  32(a1)
    ld x6,  40(a1)
    ld x7,  48(a1)
    ld x8,  56(a1)
    ld x9,  64(a1)
    ld x10, 72(a1)
    ld x11, 80(a1)
    ld x12, 88(a1)
    ld x13, 96(a1)
    ld x14, 104(a1)
    ld x15, 112(a1)
    ld x16, 120(a1)
    ld x17, 128(a1)
    ld x18, 136(a1)
    ld x19, 144(a1)
    ld x20, 152(a1)
    ld x21, 160(a1)
    ld x22, 168(a1)
    ld x23, 176(a1)
    ld x24, 184(a1)
    ld x25, 192(a1)
    ld x26, 200(a1)
    ld x27, 208(a1)
    ld x28, 216(a1)
    ld x29, 224(a1)
    ld x30, 232(a1)
    ld x31, 240(a1)

    # 返回（跳转到ra指向的地址）
    ret
```

</details>

---

## 步骤9：配置构建系统

### 9.1 在Cargo.toml中包含汇编文件

编辑 `os/Cargo.toml`：

```toml
[package]
name = "os"
version = "0.1.0"
edition = "2021"

[dependencies]
# ... 其他依赖

[build-dependencies]
# 无需特殊配置，Rust自动支持.S文件
```

### 9.2 在mod.rs中导出函数

编辑 `os/src/process/mod.rs`：

```rust
pub mod pid;
pub mod pcb;
pub mod context;

// 导出switch函数
pub use context::__switch;

pub use pid::ProcessId;
pub use pcb::{ProcessState, ProcessControlBlock, ProcessHandle, create_process_handle};
pub use context::ProcessContext;
```

### 9.3 配置汇编文件编译

在 `os/src/process/context.rs` 添加：

```rust
use core::arch::global_asm;

// 引入汇编文件
global_asm!(include_str!("switch.S"));

extern "C" {
    pub fn __switch(
        current_cx: *mut ProcessContext,
        next_cx: *const ProcessContext,
    );
}
```

---

## 步骤10：实现高层切换函数

在 `os/src/process/pcb.rs` 添加切换方法：

```rust
impl ProcessControlBlock {
    /// 切换到目标进程
    ///
    /// # Safety
    /// 调用者必须确保目标进程的上下文有效
    pub unsafe fn switch_to(&mut self, target: &ProcessControlBlock) {
        __switch(
            &mut self.context as *mut ProcessContext,
            &target.context as *const ProcessContext,
        );
    }
}
```

---

## 步骤11：测试上下文切换

### 11.1 创建测试进程

在 `os/src/main.rs` 中添加：

```rust
use os::process::{create_process_handle, ProcessState};

fn test_context_switch() {
    println!("\n=== 测试上下文切换 ===");

    // 创建两个进程
    let process_a = create_process_handle("ProcessA", None);
    let process_b = create_process_handle("ProcessB", None);

    println!("进程A PID: {}", process_a.lock().pid());
    println!("进程B PID: {}", process_b.lock().pid());
}
```

### 11.2 设置初始上下文

```rust
fn init_process_context(
    process: &mut ProcessControlBlock,
    entry: fn() -> !,
    stack: usize,
) {
    // 设置栈指针
    process.context_mut().set_sp(stack);

    // 设置返回地址（进程入口）
    process.context_mut().set_ra(entry as usize);

    // 设置sstatus
    process.context_mut().sstatus = 0x00040020;
}
```

### 11.3 定义测试函数

```rust
fn process_a_main() -> ! {
    for i in 0..5 {
        println!("[进程A] 运行 {}", i);
    }
    loop {}
}

fn process_b_main() -> ! {
    for i in 0..5 {
        println!("[进程B] 运行 {}", i);
    }
    loop {}
}
```

---

## 知识点总结

### 1. 汇编指令速查

| 指令 | 作用 | 示例 |
|------|------|------|
| `sd rs, offset(rd)` | 存储双字 | `sd x1, 0(a0)` |
| `ld rd, offset(rs)` | 加载双字 | `ld x1, 0(a1)` |
| `csrr rd, csr` | 读CSR | `csrr t0, sepc` |
| `csrw csr, rs` | 写CSR | `csrw sepc, t0` |
| `sfence.vma` | 刷新TLB | `sfence.vma` |
| `ret` | 返回 | `ret` |

### 2. 为什么要保存a0和a1？

```assembly
sd x10, 72(a0)   # 保存a0
sd x11, 80(a0)   # 保存a1
```

虽然a0和a1是参数寄存器，但：
- 它们可能存储进程的临时数据
- 恢复时需要完整的寄存器状态

### 3. 栈的切换时机

```
保存当前sp → 保存到context.x[1]
恢复目标sp ← 从context.x[1]加载
```

栈切换发生在恢复x2（sp）时。

---

## 常见错误

### 错误1：忘记刷新TLB

```assembly
csrw satp, t0
# 缺少 sfence.vma ← 错误！
```

**后果**：访问到旧页表缓存的地址，数据错乱。

### 错误2：寄存器顺序错误

```assembly
# 错误：先恢复通用寄存器，再恢复satp
ld x1, 0(a1)
csrw satp, t0  # 此时a1可能已经改变！
```

**正确**：先恢复CSR，再恢复通用寄存器。

### 错误3：忘记保存某个寄存器

```assembly
# 漏掉了x28-x31
sd x27, 208(a0)
# 没有保存x28-x31 ← 错误！
```

**后果**：进程恢复后这些寄存器的值不对。

---

## 下一步

现在我们有了完整的上下文切换机制！

**6.3.1节**将实现：
- 进程调度器设计
- 就绪队列管理
- 进程选择算法

---

## 练习题

1. 为什么要用 `#[repr(C)]` 修饰 `ProcessContext`？
2. 如果不刷新TLB会出现什么问题？
3. `ret` 指令跳转到哪里？

<details>
<summary>答案提示</summary>

1. 保证字段按顺序排列，汇编可以用固定偏移访问
2. 可能访问到前一个进程的物理页，导致数据错误或页面错误
3. 跳转到 `ra`（x1）寄存器存储的地址，即目标进程保存的返回地址

</details>
