# 6.2.1 上下文切换（上）- 机制讲解

## 本节目标

- 理解为什么需要上下文切换
- 掌握上下文切换的完整流程
- 了解RISC-V寄存器保存与恢复机制
- 为下一节的汇编实现做准备

---

## 新增文件

本节**不新增代码文件**，仅为理论讲解。下一节（6.2.2）将实现汇编代码。

---

## 为什么需要上下文切换？

### 单核CPU的困境

假设你的电脑只有一个CPU核心：

```
时间线：
0ms: 进程A运行（计算）
1ms: 进程A运行（计算）
2ms: 进程A等待I/O（浪费CPU）
3ms: 进程A等待I/O（浪费CPU）
4ms: 进程A等待I/O（浪费CPU）
```

**问题**：在2-4ms期间，CPU空闲，但进程B、C也想运行！

### 解决方案：上下文切换

```
时间线：
0ms: 进程A运行（计算）
1ms: 进程A运行（计算）
2ms: 进程A阻塞 → 切换到进程B
3ms: 进程B运行（计算）
4ms: 进程B时间片用完 → 切换到进程C
```

**好处**：
- CPU利用率提高
- 多个进程"同时"运行（时间片轮转）
- 响应速度更快

---

## 什么是上下文切换？

**上下文切换（Context Switch）** = 保存当前进程状态 + 恢复下一个进程状态

### 类比：两人轮流看书

| 步骤 | 人A | 人B |
|------|-----|-----|
| 1 | 正在读第50页 | 等待 |
| 2 | **夹书签**（保存进度） | 等待 |
| 3 | 放下书 | **翻到书签**（恢复进度） |
| 4 | 等待 | 从第30页继续读 |

**书签 = 进程上下文**

---

## 进程上下文包含什么？

回顾6.1.4节，我们定义的 `ProcessContext`：

```rust
pub struct ProcessContext {
    pub x: [usize; 31],     // x1-x31通用寄存器
    pub sepc: usize,        // 异常返回地址
    pub sstatus: usize,     // 处理器状态
    pub satp: usize,        // 页表基址
}
```

### 为什么要保存这些？

1. **通用寄存器x1-x31**
   - 存储临时变量、函数参数、返回值
   - 例如：`x10 (a0)` 是函数返回值寄存器

2. **sepc（Supervisor Exception PC）**
   - 进程被中断时的指令地址
   - 恢复时从这里继续执行

3. **sstatus（Supervisor Status）**
   - 包含中断使能位、特权级等
   - 恢复时需要保持进程的中断状态

4. **satp（Supervisor Address Translation）**
   - 页表基址寄存器
   - 切换进程时需要切换页表

---

## 上下文切换的完整流程

### 流程图

```
当前进程: ProcessA (Running)
目标进程: ProcessB (Ready)

┌─────────────────────────────────┐
│  1. 触发切换（时间片/阻塞）     │
└─────────────────────────────────┘
              ↓
┌─────────────────────────────────┐
│  2. 保存ProcessA的上下文        │
│     - 保存x1-x31到A.context.x   │
│     - 保存sepc到A.context.sepc  │
│     - 保存sstatus等             │
└─────────────────────────────────┘
              ↓
┌─────────────────────────────────┐
│  3. 切换页表                    │
│     - satp ← B.context.satp     │
│     - sfence.vma（刷新TLB）     │
└─────────────────────────────────┘
              ↓
┌─────────────────────────────────┐
│  4. 恢复ProcessB的上下文        │
│     - x1-x31 ← B.context.x      │
│     - sepc ← B.context.sepc     │
│     - sstatus ← B.context.sstatus│
└─────────────────────────────────┘
              ↓
┌─────────────────────────────────┐
│  5. 返回ProcessB继续执行        │
│     - 执行sret指令              │
│     - PC ← sepc                 │
└─────────────────────────────────┘

新的当前进程: ProcessB (Running)
```

---

## 步骤详解

### 步骤1：触发切换的时机

上下文切换可能由以下事件触发：

1. **时间片耗尽**
   - 时钟中断发生
   - 调度器选择新进程

2. **进程主动让出CPU**
   - 调用 `yield()` 系统调用
   - 等待I/O（进入Blocked状态）

3. **进程退出**
   - 调用 `exit()` 系统调用
   - 切换到下一个就绪进程

4. **更高优先级进程就绪**
   - 抢占式调度
   - 优先级调度算法

---

### 步骤2：保存当前进程上下文

**关键问题**：在哪里保存？

**答案**：保存到当前进程的PCB中的 `context` 字段。

#### 伪代码

```rust
fn save_context(current_process: &mut ProcessControlBlock) {
    // 保存通用寄存器（汇编实现）
    current_process.context.x[0] = read_register_x1();
    current_process.context.x[1] = read_register_x2();
    // ... 保存x3-x31

    // 保存CSR寄存器
    current_process.context.sepc = read_csr!(sepc);
    current_process.context.sstatus = read_csr!(sstatus);
    current_process.context.satp = read_csr!(satp);
}
```

**注意**：这段代码实际上必须用汇编实现，因为：
- Rust无法直接访问所有寄存器
- 保存x1-x31需要精确的指令序列

---

### 步骤3：切换页表

为什么要切换页表？

- 每个进程有独立的虚拟地址空间
- 进程A的地址0x1000和进程B的地址0x1000指向不同物理内存
- 切换页表 = 切换地址空间

#### 页表切换代码（Rust）

```rust
fn switch_page_table(next_process: &ProcessControlBlock) {
    let new_satp = next_process.context.satp;

    unsafe {
        // 切换页表基址
        core::arch::asm!(
            "csrw satp, {0}",
            in(reg) new_satp
        );

        // 刷新TLB（Translation Lookaside Buffer）
        core::arch::asm!("sfence.vma");
    }
}
```

**sfence.vma的作用**：

- TLB是页表缓存
- 切换页表后必须刷新TLB
- 否则可能访问到旧进程的物理页

---

### 步骤4：恢复目标进程上下文

从目标进程的PCB中读取保存的上下文。

#### 伪代码

```rust
fn restore_context(next_process: &ProcessControlBlock) {
    // 恢复CSR寄存器
    write_csr!(sepc, next_process.context.sepc);
    write_csr!(sstatus, next_process.context.sstatus);

    // 恢复通用寄存器（汇编实现）
    write_register_x1(next_process.context.x[0]);
    write_register_x2(next_process.context.x[1]);
    // ... 恢复x3-x31
}
```

---

### 步骤5：返回目标进程

使用 `sret` 指令返回：

```assembly
sret
```

**sret指令做了什么？**

1. `PC ← sepc`（跳转到保存的指令地址）
2. 恢复特权级（根据sstatus.SPP）
3. 恢复中断使能位（根据sstatus.SPIE）

---

## 栈的切换

### 问题：进程有独立的栈吗？

**是的**！每个进程有自己的栈指针（sp寄存器 = x2）。

### 栈切换流程

```
ProcessA运行时：
  sp指向ProcessA的栈顶

上下文切换：
  1. 保存ProcessA.context.x[1] = sp（保存栈指针）
  2. sp ← ProcessB.context.x[1]（切换栈指针）

ProcessB运行时：
  sp指向ProcessB的栈顶
```

**重要**：栈指针存储在 `context.x[1]`（x2 = sp）。

---

## 第一次调度的特殊情况

### 问题：新创建的进程没有上下文怎么办?

**答案**：手动构造一个初始上下文。

#### 初始上下文示例

```rust
impl ProcessContext {
    /// 为新进程创建初始上下文
    pub fn new_user_context(
        entry_point: usize,    // 进程入口地址
        user_stack: usize,     // 用户栈地址
    ) -> Self {
        let mut context = ProcessContext::new();

        // 设置入口地址
        context.sepc = entry_point;

        // 设置栈指针（x2 = sp）
        context.x[1] = user_stack;

        // 设置sstatus：允许中断，用户态
        context.sstatus = 0x00040020;

        context
    }
}
```

**sstatus的值**：

- Bit 5 (SPIE) = 1：返回后允许中断
- Bit 8 (SPP) = 0：返回到用户态

---

## 关键数据结构总结

### ProcessContext（上下文）

```rust
pub struct ProcessContext {
    pub x: [usize; 31],     // 31个通用寄存器
    pub sepc: usize,        // 返回地址
    pub sstatus: usize,     // 处理器状态
    pub satp: usize,        // 页表基址
}
```

### ProcessControlBlock（PCB）

```rust
pub struct ProcessControlBlock {
    pid: ProcessId,
    state: ProcessState,
    context: ProcessContext,  // ← 上下文存储在这里
    // ... 其他字段
}
```

---

## 上下文切换的性能开销

### 典型开销

| 操作 | 时间开销 |
|------|----------|
| 保存寄存器 | ~50 cycles |
| 恢复寄存器 | ~50 cycles |
| 切换页表 | ~10 cycles |
| TLB刷新 | ~100 cycles |
| **总计** | **~210 cycles** |

**注意**：
- 实际开销还包括缓存失效（Cache Miss）
- 频繁切换会影响性能
- 因此时间片不能太小（通常5-10ms）

---

## 与异常处理的区别

### 异常处理

```
用户程序 → 异常 → 内核处理 → 返回原程序
```

- 保存：内核临时保存寄存器到栈
- 恢复：立即恢复，返回原地址

### 上下文切换

```
进程A → 切换 → 进程B → 切换 → 进程A
```

- 保存：永久保存到PCB.context
- 恢复：可能在很久以后才恢复

---

## 关键技术点

### 1. 为什么用汇编？

```rust
// ❌ 无法用纯Rust实现
fn save_all_registers() {
    let x1 = ???;  // Rust没有读取x1的方法
    let x2 = ???;
    // ...
}
```

**必须用汇编**：

```assembly
sd x1, 0(a0)   # 保存x1到内存
sd x2, 8(a0)   # 保存x2到内存
# ...
```

### 2. repr(C)的作用

```rust
#[repr(C)]  // ← 必须添加
pub struct ProcessContext {
    pub x: [usize; 31],
    // ...
}
```

**原因**：
- 汇编代码需要按固定偏移访问字段
- `#[repr(C)]` 保证字段顺序不变
- 计算偏移：x[0]在偏移0，x[1]在偏移8（64位）

---

## 下一步

本节我们理解了上下文切换的**机制**和**流程**。

**6.2.2节**将实现：
- 用汇编保存/恢复所有寄存器
- 实现 `__switch` 核心函数
- 设计栈帧布局
- 完成可测试的上下文切换

---

## 练习题

1. 为什么不保存x0寄存器？
2. 如果忘记刷新TLB（sfence.vma）会怎样？
3. 新进程第一次调度时，sepc应该设置为什么值？

<details>
<summary>答案提示</summary>

1. x0在RISC-V中硬件固定为0，读取永远是0，写入无效
2. 可能访问到前一个进程的物理页，导致数据错乱或段错误
3. 进程的入口地址（entry_point），通常是main函数或_start

</details>
