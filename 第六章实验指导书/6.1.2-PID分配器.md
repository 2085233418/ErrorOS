# 6.1.2 PID分配器实现

## 本节新增文件

```
os/src/process/
├── mod.rs          # 进程管理模块入口（新建）
└── pid.rs          # PID分配器实现（新建）
```

---

## 为什么需要PID分配器？

在操作系统中，每个进程都需要一个**唯一的标识符**（Process ID，简称PID）。就像图书馆给每本书一个编号，操作系统给每个进程分配一个PID。

PID必须满足：
- ✅ **唯一性**：不同进程的PID不能相同
- ✅ **单调性**：新进程的PID应该递增（方便调试）
- ✅ **线程安全**：多个CPU核心同时创建进程时不能冲突

---

## 步骤1：创建进程管理模块

首先创建进程管理模块的目录结构。

### 1.1 创建 `os/src/process/mod.rs`

```rust
//! 进程管理模块
//!
//! 提供进程的创建、调度、销毁等核心功能

pub mod pid;

// 重新导出常用类型
pub use pid::ProcessId;
```

### 1.2 在 `os/src/lib.rs` 中注册模块

找到模块声明部分，添加：

```rust
pub mod process;
```

现在可以通过 `os::process::ProcessId` 访问PID类型。

---

## 步骤2：设计ProcessId类型

### 2.1 为什么用Newtype模式？

我们不直接使用 `usize` 作为PID，而是用一个新类型包装它：

```rust
pub struct ProcessId(usize);
```

**好处**：
- 🎯 **类型安全**：不会把普通整数误当作PID
- 🎯 **语义清晰**：看到 `ProcessId` 就知道是进程ID
- 🎯 **易于扩展**：将来可以添加验证逻辑

**错误示例**（没有Newtype）：
```rust
let age: usize = 25;
let pid: usize = 1;
if age == pid { ... }  // 编译通过，但语义错误！
```

**正确示例**（使用Newtype）：
```rust
let age: usize = 25;
let pid: ProcessId = ProcessId(1);
if age == pid { ... }  // 编译错误！类型不匹配
```

### 2.2 创建 `os/src/process/pid.rs`

先写类型定义和基础方法：

```rust
//! PID（进程标识符）分配器

use core::sync::atomic::{AtomicUsize, Ordering};
use core::fmt;

/// 进程ID的类型安全包装
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub struct ProcessId(usize);
```

**代码说明**：
- `AtomicUsize` - 原子类型，保证线程安全
- `Ordering` - 内存顺序，控制原子操作的同步语义
- `derive` 宏自动实现常用trait：
  - `Debug` - 可以用 `{:?}` 打印
  - `Clone, Copy` - 可以按值复制（PID很小，复制成本低）
  - `PartialEq, Eq` - 可以用 `==` 比较
  - `PartialOrd, Ord` - 可以用 `<` 比较

---

## 步骤3：实现PID分配逻辑

### 3.1 核心：原子递增计数器

**设计思路**：
1. 用一个全局静态变量存储"下一个可用的PID"
2. 每次分配时，原子地递增这个变量
3. 从1开始分配（PID 0通常保留给内核）

### 3.2 实现 `new()` 方法

在 `pid.rs` 中添加：

```rust
impl ProcessId {
    /// 分配一个新的PID
    pub fn new() -> Self {
        static NEXT_PID: AtomicUsize = AtomicUsize::new(1);

        let pid = NEXT_PID.fetch_add(1, Ordering::Relaxed);
        ProcessId(pid)
    }
}
```

**关键点解析**：

1. **`static NEXT_PID`** - 全局静态变量，整个程序只有一份
2. **`AtomicUsize::new(1)`** - 初始值为1，第一个进程从PID 1开始
3. **`fetch_add(1, Ordering::Relaxed)`** - 原子操作，分两步：
   - **fetch**：读取当前值
   - **add**：把当前值加1
   - **返回**：加之前的旧值
4. **`Ordering::Relaxed`** - 最宽松的内存顺序，性能最好

**为什么是Relaxed？**

PID分配不需要严格的内存顺序约束，只要保证原子性即可：
- ❌ 不需要 `SeqCst`（顺序一致性）- PID分配不影响其他数据
- ❌ 不需要 `Acquire/Release` - 没有依赖其他内存操作
- ✅ 只需要 `Relaxed` - 保证原子递增即可

### 3.3 原子操作示例

假设有两个CPU核心同时调用 `ProcessId::new()`：

```
时刻  |  NEXT_PID  |  CPU 0             |  CPU 1
------|-----------|--------------------|-----------------
  0   |     1     |                    |
  1   |     1     | fetch_add(1) 开始  |
  2   |     1     | 读取到 1           | fetch_add(1) 开始
  3   |     2     | 写入 2             | 读取到 1 (❌被阻塞)
  4   |     2     | 返回 1             |
  5   |     2     |                    | 读取到 2
  6   |     3     |                    | 写入 3
  7   |     3     |                    | 返回 2
```

**结果**：CPU 0 得到 PID 1，CPU 1 得到 PID 2，没有冲突！

---

## 步骤4：添加辅助方法

### 4.1 转换方法

```rust
impl ProcessId {
    /// 获取PID的数值
    pub fn as_usize(self) -> usize {
        self.0
    }

    /// 从数值创建PID（用于反序列化等场景）
    pub const fn from_usize(pid: usize) -> Self {
        ProcessId(pid)
    }
}
```

### 4.2 特殊PID判断

```rust
impl ProcessId {
    /// 判断是否是init进程（PID 1）
    pub fn is_init(self) -> bool {
        self.0 == 1
    }
}
```

**为什么PID 1特殊？**

在Unix/Linux系统中，PID 1 是 `init` 进程（所有进程的祖先）。它有特殊职责：
- 🔹 系统启动时第一个创建
- 🔹 所有孤儿进程会被重新挂到init下
- 🔹 系统关闭时最后退出

### 4.3 格式化输出

```rust
impl fmt::Display for ProcessId {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.0)
    }
}
```

现在可以用 `println!("PID: {}", pid)` 直接打印PID了。

---

## 步骤5：完整代码

<details>
<summary><b>点击展开：os/src/process/pid.rs 完整实现</b></summary>

```rust
//! PID（进程标识符）分配器
//!
//! 提供线程安全的PID分配功能

use core::sync::atomic::{AtomicUsize, Ordering};
use core::fmt;

/// 进程ID的类型安全包装
///
/// 使用Newtype模式包装usize，提供类型安全
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub struct ProcessId(usize);

impl ProcessId {
    /// 分配一个新的PID
    ///
    /// 使用原子操作保证线程安全，PID从1开始单调递增
    ///
    /// # 示例
    /// ```
    /// let pid1 = ProcessId::new();  // PID 1
    /// let pid2 = ProcessId::new();  // PID 2
    /// assert!(pid2 > pid1);
    /// ```
    pub fn new() -> Self {
        static NEXT_PID: AtomicUsize = AtomicUsize::new(1);

        let pid = NEXT_PID.fetch_add(1, Ordering::Relaxed);
        ProcessId(pid)
    }

    /// 获取PID的数值
    ///
    /// # 示例
    /// ```
    /// let pid = ProcessId::new();
    /// let num: usize = pid.as_usize();
    /// ```
    pub fn as_usize(self) -> usize {
        self.0
    }

    /// 从数值创建PID
    ///
    /// 用于反序列化、测试等场景
    ///
    /// # 示例
    /// ```
    /// let pid = ProcessId::from_usize(42);
    /// assert_eq!(pid.as_usize(), 42);
    /// ```
    pub const fn from_usize(pid: usize) -> Self {
        ProcessId(pid)
    }

    /// 判断是否是init进程（PID 1）
    ///
    /// init进程是系统中第一个进程，有特殊的权限和职责
    pub fn is_init(self) -> bool {
        self.0 == 1
    }
}

impl fmt::Display for ProcessId {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.0)
    }
}

impl Default for ProcessId {
    /// 默认值为PID 0（通常表示无效或内核）
    fn default() -> Self {
        ProcessId(0)
    }
}
```

</details>

---

## 步骤6：测试PID分配器

### 6.1 验证基本功能

在 `os/src/main.rs` 的 `kernel_main()` 中添加测试代码（临时）：

```rust
// 临时测试代码
use os::process::ProcessId;

println!("测试PID分配器...");
let pid1 = ProcessId::new();
let pid2 = ProcessId::new();
let pid3 = ProcessId::new();

println!("pid1 = {}", pid1);  // 输出：pid1 = 1
println!("pid2 = {}", pid2);  // 输出：pid2 = 2
println!("pid3 = {}", pid3);  // 输出：pid3 = 3

assert!(pid1.is_init());      // ✓ 第一个进程是init
assert!(pid2 > pid1);         // ✓ PID单调递增
assert_ne!(pid1, pid2);       // ✓ PID唯一
```

### 6.2 运行验证

```bash
cd os
cargo run
```

如果看到：
```
测试PID分配器...
pid1 = 1
pid2 = 2
pid3 = 3
```

说明PID分配器工作正常！测试完成后可以删除这段临时代码。

---

## 知识点总结

### 核心概念

| 概念 | 说明 | 作用 |
|------|------|------|
| **Newtype模式** | 用新类型包装已有类型 | 类型安全、语义清晰 |
| **原子类型** | `AtomicUsize` | 线程安全的整数 |
| **原子操作** | `fetch_add` | 不可分割的"读-改-写" |
| **内存顺序** | `Ordering::Relaxed` | 控制原子操作的同步语义 |

### 设计决策

| 决策 | 原因 |
|------|------|
| 为什么用Newtype？ | 防止把普通整数误当作PID |
| 为什么用AtomicUsize？ | 多核CPU可能同时分配PID |
| 为什么从1开始？ | PID 0通常保留给内核，PID 1给init进程 |
| 为什么用Relaxed？ | PID分配不需要严格的内存顺序 |

### 常见问题

**Q1: PID会用完吗？**

`usize` 在64位系统上最大是 2^64，足够用。如果真的用完了，可以实现PID回收机制（后续章节）。

**Q2: 为什么不用Mutex而用Atomic？**

- `Mutex` 需要等待、加锁、解锁，开销大
- `AtomicUsize` 直接在CPU指令级别保证原子性，性能高

**Q3: 如果两个CPU同时读到同一个值怎么办？**

不会！`fetch_add` 是原子操作，CPU硬件保证不会冲突。

---

## 下一步

现在我们有了PID分配器，下一节将实现**进程状态枚举**，定义进程的生命周期状态。

---

## 练习题

1. **修改起始PID**：把第一个PID改为100，观察变化
2. **添加最大值检查**：如果PID超过1000就panic
3. **实现PID回收**：进程退出后，把PID放回空闲列表

<details>
<summary>练习1提示</summary>

修改 `AtomicUsize::new(1)` 为 `AtomicUsize::new(100)`

</details>
