# 6.3.2 轮转调度实现

## 本节目标

- 实现完整的轮转调度流程
- 配置时钟中断触发调度
- 实现时间片消耗机制
- 完成多进程切换测试

---

## 新增/修改文件

```
os/src/
├── trap/
│   └── mod.rs            # 新增：陷阱（中断/异常）处理模块
├── interrupts.rs         # 修改：改为兼容层，重导出trap模块
└── process/scheduler.rs  # 修改：完善调度逻辑
```

**重要**：从本节开始，我们将中断处理从 `interrupts.rs` 迁移到 `trap/` 目录，以便更好地组织代码。

---

## ⚠️ 前置步骤：创建 trap 模块

### 为什么需要 trap 模块？

在 RISC-V 架构中，**Trap（陷阱）** 是中断（Interrupt）和异常（Exception）的统称：

- **中断**：外部事件（如时钟、键盘）
- **异常**：程序错误（如非法指令、页错误）
- **系统调用**：用户态主动陷入内核（ecall 指令）

将这些统一放在 `trap` 模块中更符合 RISC-V 的概念模型。

### 迁移步骤

#### 步骤1：创建 trap 目录和模块

在 `os/src/` 下创建 `trap` 目录：

```bash
mkdir -p os/src/trap
```

#### 步骤2：创建 trap/mod.rs

创建 `os/src/trap/mod.rs`，将原来 `interrupts.rs` 的内容迁移过来。

<details>
<summary>完整代码：os/src/trap/mod.rs（点击展开）</summary>

```rust
/*
 * ============================================
 * RISC-V 陷阱（Trap）处理模块
 * ============================================
 * 功能：处理 RISC-V 中断（Interrupt）和异常（Exception）
 *
 * RISC-V 陷阱机制：
 * - stvec：陷阱向量基址寄存器
 * - scause：陷阱原因寄存器
 * - sepc：陷阱发生时的程序计数器
 * - stval：陷阱附加信息（如出错地址）
 * - sstatus：状态寄存器
 *
 * 支持的中断类型：
 * - 时钟中断（SupervisorTimer）
 * - 外部中断（SupervisorExternal）
 * - 软件中断（SupervisorSoft）
 *
 * 支持的异常类型：
 * - 系统调用（UserEnvCall）
 * - 页错误（Page Fault）
 * - 非法指令（Illegal Instruction）
 * - 断点（Breakpoint）
 * ============================================
 */

use crate::{serial_println, println};
use riscv::register::{
    scause::{self, Exception, Interrupt, Trap},
    sepc, stval, stvec,
};

/// 初始化陷阱处理系统
pub fn init() {
    unsafe {
        // 设置陷阱向量地址（Direct 模式）
        stvec::write(trap_handler as usize, stvec::TrapMode::Direct);
    }

    serial_println!("[INTERRUPT] Trap vector initialized");

    // 启用定时器中断
    unsafe {
        riscv::register::sie::set_stimer();
    }

    // 设置第一次定时器中断
    set_next_timer();

    serial_println!("[INTERRUPT] Timer interrupt enabled");
}

/// 统一的陷阱处理入口
#[no_mangle]
pub extern "C" fn trap_handler() {
    let scause = scause::read();
    let stval = stval::read();
    let sepc = sepc::read();

    match scause.cause() {
        // 中断处理
        Trap::Interrupt(interrupt) => {
            match interrupt {
                Interrupt::SupervisorTimer => {
                    timer_interrupt_handler();
                }
                Interrupt::SupervisorExternal => {
                    external_interrupt_handler();
                }
                Interrupt::SupervisorSoft => {
                    software_interrupt_handler();
                }
                _ => {
                    panic!(
                        "Unhandled interrupt!\n\
                        scause: {:?}\n\
                        sepc: {:#x}\n\
                        stval: {:#x}",
                        scause.cause(), sepc, stval
                    );
                }
            }
        }

        // 异常处理
        Trap::Exception(exception) => {
            match exception {
                Exception::Breakpoint => {
                    breakpoint_handler(sepc);
                }
                Exception::LoadPageFault |
                Exception::StorePageFault |
                Exception::InstructionPageFault => {
                    page_fault_handler(scause.cause(), stval, sepc);
                }
                Exception::IllegalInstruction => {
                    illegal_instruction_handler(sepc, stval);
                }
                Exception::UserEnvCall => {
                    syscall_handler(sepc);
                }
                _ => {
                    panic!(
                        "Unhandled exception!\n\
                        scause: {:?}\n\
                        sepc: {:#x}\n\
                        stval: {:#x}",
                        scause.cause(), sepc, stval
                    );
                }
            }
        }
    }
}

// 时钟中断处理
fn timer_interrupt_handler() {
    crate::task::keyboard::poll_keyboard();
    set_next_timer();
}

// 外部中断处理
fn external_interrupt_handler() {
    serial_println!("[INTERRUPT] External interrupt received");
}

// 软件中断处理
fn software_interrupt_handler() {
    serial_println!("[INTERRUPT] Software interrupt received");
}

// 断点异常处理
fn breakpoint_handler(sepc: usize) {
    serial_println!("[EXCEPTION] Breakpoint at {:#x}", sepc);
    println!("EXCEPTION: BREAKPOINT at {:#x}", sepc);
    riscv::register::sepc::write(sepc + 2);
}

// 页错误处理
fn page_fault_handler(cause: Trap, stval: usize, sepc: usize) {
    serial_println!(
        "[EXCEPTION] Page Fault\n\
        Type: {:?}\n\
        Address: {:#x}\n\
        PC: {:#x}",
        cause, stval, sepc
    );
    println!("EXCEPTION: PAGE FAULT");
    println!("Accessed Address: {:#x}", stval);
    println!("Exception PC: {:#x}", sepc);
    println!("Fault Type: {:?}", cause);
    crate::hlt_loop();
}

// 非法指令处理
fn illegal_instruction_handler(sepc: usize, stval: usize) {
    panic!(
        "EXCEPTION: ILLEGAL INSTRUCTION\n\
        PC: {:#x}\n\
        Instruction: {:#x}",
        sepc, stval
    );
}

// 系统调用处理
fn syscall_handler(sepc: usize) {
    let context = unsafe { crate::syscall::SyscallContext::from_registers() };
    let result = crate::syscall::syscall_dispatcher(&context);
    unsafe {
        context.set_return_value(result);
    }
    riscv::register::sepc::write(sepc + 4);
}

// 中断控制函数
pub fn without_interrupts<F, R>(f: F) -> R
where
    F: FnOnce() -> R,
{
    use riscv::register::sstatus;
    let sie = sstatus::read().sie();
    if sie {
        unsafe { riscv::register::sstatus::clear_sie(); }
    }
    let ret = f();
    if sie {
        unsafe { riscv::register::sstatus::set_sie(); }
    }
    ret
}

pub fn enable_interrupts() {
    unsafe {
        riscv::register::sstatus::set_sie();
    }
}

pub fn disable_interrupts() {
    unsafe {
        riscv::register::sstatus::clear_sie();
    }
}

// 设置下一次定时器中断
fn set_next_timer() {
    const TIMER_INTERVAL: u64 = 1_000_000; // 100ms @ 10MHz
    let time = riscv::register::time::read64();
    sbi_set_timer(time + TIMER_INTERVAL);
}

// SBI 调用：设置定时器
fn sbi_set_timer(stime_value: u64) {
    unsafe {
        core::arch::asm!(
            "mv a0, {0}",
            "li a7, 0",
            "ecall",
            in(reg) stime_value,
            out("a0") _,
            out("a1") _,
            options(nostack)
        );
    }
}
```

</details>

**关键点**：

1. **初始化函数名**：`init()` 而不是 `init_idt()`（更简洁）
2. **模块路径**：`os/src/trap/mod.rs`（目录结构）
3. **功能完整**：包含所有中断和异常处理

#### 步骤3：修改 lib.rs 导出 trap 模块

在 `os/src/lib.rs` 中添加 trap 模块：

```rust
pub mod serial;      // 串口驱动
pub mod console;     // 控制台输出
pub mod interrupts;  // 中断处理（旧，兼容用）
pub mod trap;        // 陷阱处理（新，第6章）✨
pub mod memory;      // 内存管理
// ... 其他模块
```

#### 步骤4：修改 interrupts.rs 为兼容层

将 `os/src/interrupts.rs` 改为兼容层，重导出 trap 模块的功能：

```rust
/*
 * ============================================
 * 兼容性模块：中断处理
 * ============================================
 *
 * ⚠️ 本模块已废弃，仅用于向后兼容
 *
 * 从第6章开始，中断和异常处理已迁移到 trap 模块。
 * 新代码请使用 trap 模块。
 * ============================================
 */

// 重导出 trap 模块的所有公共项
pub use crate::trap::{
    init as init_idt,           // 兼容旧名称
    trap_handler,
    enable_interrupts,
    disable_interrupts,
    without_interrupts,
};
```

**这样做的好处**：

- ✅ 旧代码仍然可以使用 `interrupts::init_idt()`
- ✅ 新代码使用 `trap::init()` 更清晰
- ✅ 不会破坏现有的第5章代码

#### 步骤5：测试编译

```bash
cd os
cargo build
```

应该能成功编译，没有任何错误。

#### 步骤6：验证运行

```bash
cargo run
```

系统应该正常启动，输出：

```
Welcome to Error OS!
[INIT] Initializing RISC-V OS
[INTERRUPT] Trap vector initialized
[INTERRUPT] Timer interrupt enabled
...
```

### 迁移完成检查清单

- [x] 创建 `os/src/trap/mod.rs`
- [x] 在 `lib.rs` 中添加 `pub mod trap;`
- [x] 修改 `interrupts.rs` 为兼容层
- [x] 编译成功
- [x] 运行正常

**恭喜！** 现在你的代码结构更清晰，可以继续后续章节了。

---

## 回顾：轮转调度原理

```
时间线：
0ms: ProcessA运行（时间片=5）
1ms: tick → 时间片=4
2ms: tick → 时间片=3
3ms: tick → 时间片=2
4ms: tick → 时间片=1
5ms: tick → 时间片=0 → 切换到ProcessB
6ms: ProcessB运行（时间片=5）
...
```

**核心思想**：
- 每个进程获得固定时间片
- 时间片用完，放回队尾
- 调度下一个进程

---

## 步骤1：配置时钟中断

### 1.1 RISC-V时钟中断机制

RISC-V使用SBI提供的时钟服务：

```rust
// os/src/sbi.rs（假设已有）
const SBI_SET_TIMER: usize = 0;

pub fn set_timer(stime_value: u64) {
    sbi_call(SBI_SET_TIMER, stime_value, 0, 0);
}
```

**原理**：
- 向SBI请求在指定时间触发中断
- 到达时间后触发 `Supervisor Timer Interrupt`

---

### 1.2 实现时钟初始化

创建 `os/src/timer.rs`：

```rust
//! 时钟中断管理

use crate::sbi;

/// 时钟频率（QEMU中为10MHz）
const CLOCK_FREQ: usize = 10_000_000;

/// 时间片长度（10ms = 100000 ticks）
const TICKS_PER_SLICE: usize = CLOCK_FREQ / 100;
```

**计算**：
- CLOCK_FREQ = 10,000,000 Hz（每秒10M次）
- 10ms = 0.01秒
- TICKS = 10,000,000 × 0.01 = 100,000

---

### 1.3 读取当前时间

```rust
/// 读取当前时间（CSR: time寄存器）
pub fn get_time() -> usize {
    let time: usize;
    unsafe {
        core::arch::asm!(
            "rdtime {0}",
            out(reg) time
        );
    }
    time
}
```

**rdtime指令**：
- 读取硬件时钟计数器
- 返回自系统启动以来的tick数

---

### 1.4 设置下一次中断

```rust
/// 设置下一次时钟中断
pub fn set_next_trigger() {
    let next = get_time() + TICKS_PER_SLICE;
    sbi::set_timer(next as u64);
}
```

**流程**：
1. 读取当前时间
2. 加上时间片长度
3. 请求SBI在该时间触发中断

---

### 1.5 初始化时钟

```rust
/// 初始化时钟中断
pub fn init() {
    // 使能时钟中断（设置sie.STIE位）
    unsafe {
        core::arch::asm!(
            "csrsi sie, 0x20"  // STIE = bit 5
        );
    }

    // 设置第一次时钟中断
    set_next_trigger();

    println!("[Timer] 时钟中断已初始化（时间片=10ms）");
}
```

---

## 步骤2：处理时钟中断

### 2.1 识别时钟中断

在 `os/src/trap/mod.rs` 中添加：

```rust
use riscv::register::scause::{Trap, Interrupt};

#[no_mangle]
pub fn trap_handler(cx: &mut TrapContext) {
    let scause = scause::read();
    let stval = stval::read();

    match scause.cause() {
        // 时钟中断
        Trap::Interrupt(Interrupt::SupervisorTimer) => {
            handle_timer_interrupt();
        }

        // 其他异常...
        _ => {
            panic!("未处理的异常: {:?}, stval={:#x}", scause.cause(), stval);
        }
    }
}
```

---

### 2.2 实现时钟中断处理

```rust
use crate::timer;
use crate::process;

fn handle_timer_interrupt() {
    // 1. 设置下一次时钟中断
    timer::set_next_trigger();

    // 2. 当前进程时间片-1
    let should_schedule = tick_current_process();

    // 3. 如果时间片用完，执行调度
    if should_schedule {
        process::schedule();
    }
}
```

**流程**：
1. 立即设置下一次中断（否则只会触发一次）
2. 消耗当前进程的时间片
3. 如果时间片为0，触发调度

---

### 2.3 实现时间片消耗

```rust
/// 当前进程时间片-1
///
/// 返回：true表示需要重新调度
fn tick_current_process() -> bool {
    use crate::process::SCHEDULER;

    let mut scheduler = SCHEDULER.lock();

    if let Some(ref current) = scheduler.current {
        let mut pcb = current.lock();

        // 消耗1个时间片
        let should_schedule = pcb.tick();

        if should_schedule {
            println!("[Scheduler] 进程 {} 时间片用完", pcb.pid());
            return true;
        }
    }

    false
}
```

---

## 步骤3：完善调度器

### 3.1 修改schedule方法

在 `os/src/process/scheduler.rs` 中修改：

```rust
impl RoundRobinScheduler {
    /// 执行一次调度（完整版）
    pub fn schedule(&mut self) {
        // 1. 保存旧进程引用
        let old = self.current.take();

        // 2. 将旧进程放回就绪队列
        if let Some(old_process) = old.as_ref() {
            let state = old_process.lock().state();

            // 只有Running状态才放回队列
            if state == ProcessState::Running {
                old_process.lock().set_state(ProcessState::Ready);
                old_process.lock().reset_time_slice();
                self.ready_queue.push(old_process.clone());
            }
        }

        // 3. 选择下一个进程
        if let Some(next) = self.pick_next() {
            println!("[Scheduler] 切换到进程 {}", next.lock().pid());

            // 4. 执行上下文切换
            if let Some(old_process) = old {
                unsafe {
                    let mut old_pcb = old_process.lock();
                    let next_pcb = next.lock();

                    old_pcb.switch_to(&next_pcb);
                }
            }

            self.current = Some(next);
        } else {
            // 无就绪进程
            println!("[Scheduler] 无就绪进程，执行idle");
            idle();
        }
    }
}
```

**关键点**：
- 使用 `take()` 取出旧进程，避免借用冲突
- 只切换Running状态的进程
- 调用 `switch_to()` 执行上下文切换

---

## 步骤4：初始化调度系统

### 4.1 在kernel_main中初始化

```rust
// os/src/main.rs

pub fn kernel_main() {
    println!("ERROR OS 启动中...");

    // 初始化中断系统
    trap::init();

    // 初始化时钟中断
    timer::init();

    // 创建测试进程
    test_scheduler();

    // 开始调度
    process::schedule();

    // 不应该到达这里
    panic!("kernel_main should not return");
}
```

---

### 4.2 创建测试进程

```rust
fn test_scheduler() {
    use crate::process::{create_process_handle, add_process};

    println!("\n=== 创建测试进程 ===");

    // 创建进程A
    let process_a = create_process_handle("ProcessA", None);
    init_test_process(&process_a, process_a_main);
    add_process(process_a);

    // 创建进程B
    let process_b = create_process_handle("ProcessB", None);
    init_test_process(&process_b, process_b_main);
    add_process(process_b);

    // 创建进程C
    let process_c = create_process_handle("ProcessC", None);
    init_test_process(&process_c, process_c_main);
    add_process(process_c);

    println!("就绪进程数: {}", process::ready_count());
}
```

---

### 4.3 初始化进程上下文

```rust
use crate::config::USER_STACK_SIZE;

fn init_test_process(
    process: &ProcessHandle,
    entry: fn() -> !,
) {
    // 分配用户栈
    let stack = alloc_user_stack();

    let mut pcb = process.lock();

    // 设置入口地址（ra寄存器）
    pcb.context_mut().set_ra(entry as usize);

    // 设置栈指针（sp寄存器）
    pcb.context_mut().set_sp(stack + USER_STACK_SIZE);

    // 设置sstatus（用户态，允许中断）
    pcb.context_mut().sstatus = 0x00040020;
}
```

**栈分配**：

```rust
fn alloc_user_stack() -> usize {
    use alloc::vec::Vec;

    // 分配4KB栈空间
    let mut stack = Vec::with_capacity(USER_STACK_SIZE);
    unsafe { stack.set_len(USER_STACK_SIZE); }

    let stack_bottom = stack.as_ptr() as usize;

    // 防止栈被回收
    core::mem::forget(stack);

    stack_bottom
}
```

---

### 4.4 定义测试进程函数

```rust
fn process_a_main() -> ! {
    for i in 0..10 {
        println!("[进程A] 第{}次运行", i);
        // 模拟工作
        for _ in 0..100000 {
            unsafe { core::arch::asm!("nop"); }
        }
    }
    println!("[进程A] 退出");
    loop {}
}

fn process_b_main() -> ! {
    for i in 0..10 {
        println!("[进程B] 第{}次运行", i);
        for _ in 0..100000 {
            unsafe { core::arch::asm!("nop"); }
        }
    }
    println!("[进程B] 退出");
    loop {}
}

fn process_c_main() -> ! {
    for i in 0..10 {
        println!("[进程C] 第{}次运行", i);
        for _ in 0..100000 {
            unsafe { core::arch::asm!("nop"); }
        }
    }
    println!("[进程C] 退出");
    loop {}
}
```

---

## 步骤5：测试运行

### 预期输出

```
ERROR OS 启动中...
[Trap] 中断系统已初始化
[Timer] 时钟中断已初始化（时间片=10ms）

=== 创建测试进程 ===
就绪进程数: 3

[Scheduler] 切换到进程 1
[进程A] 第0次运行
[进程A] 第1次运行
[Scheduler] 进程 1 时间片用完
[Scheduler] 切换到进程 2
[进程B] 第0次运行
[进程B] 第1次运行
[Scheduler] 进程 2 时间片用完
[Scheduler] 切换到进程 3
[进程C] 第0次运行
[Scheduler] 进程 3 时间片用完
[Scheduler] 切换到进程 1
[进程A] 第2次运行
...
```

**观察**：
- 进程按顺序轮流执行
- 每个进程运行约10ms后切换
- 实现了时间片轮转

---

## 步骤6：添加调度统计

### 6.1 统计上下文切换次数

在 `RoundRobinScheduler` 中添加：

```rust
pub struct RoundRobinScheduler {
    ready_queue: ReadyQueue,
    current: Option<ProcessHandle>,
    switch_count: usize,  // 新增：切换次数
}

impl RoundRobinScheduler {
    pub fn schedule(&mut self) {
        // ... 原有代码

        if let Some(next) = self.pick_next() {
            self.switch_count += 1;  // 统计切换次数

            println!(
                "[Scheduler] 第{}次切换：→ 进程{}",
                self.switch_count,
                next.lock().pid()
            );

            // ... 原有代码
        }
    }
}
```

---

### 6.2 打印调度统计

```rust
impl RoundRobinScheduler {
    pub fn print_stats(&self) {
        println!("\n=== 调度统计 ===");
        println!("总切换次数: {}", self.switch_count);
        println!("当前就绪进程: {}", self.ready_queue.len());
    }
}
```

---

## 知识点总结

### 时间片轮转算法

```
就绪队列: [A, B, C]
             ↓
          选择A运行
             ↓
        时钟中断（10ms后）
             ↓
         时间片用完？
         Yes ↓     No → 继续运行
     放回队尾 [B, C, A]
             ↓
          选择B运行
```

### 关键组件

| 组件 | 作用 |
|------|------|
| **时钟中断** | 定期触发，驱动调度 |
| **时间片计数** | 跟踪进程运行时间 |
| **就绪队列** | 存储等待运行的进程 |
| **上下文切换** | 保存/恢复进程状态 |

### 时间片大小权衡

| 时间片大小 | 优点 | 缺点 |
|-----------|------|------|
| **1ms** | 响应极快 | 切换开销占比大（~20%） |
| **10ms** | 平衡 | 较好的响应和效率 |
| **100ms** | 开销小 | 响应慢，不适合交互 |

**典型值**：Linux使用4-10ms。

---

## 常见问题

### 问题1：进程只切换一次就停止

**原因**：忘记在时钟中断处理中调用 `set_next_trigger()`。

**解决**：

```rust
fn handle_timer_interrupt() {
    timer::set_next_trigger();  // ← 必须添加！
    // ...
}
```

---

### 问题2：调度器死锁

**原因**：在持有锁的情况下触发中断，中断处理又尝试获取锁。

**解决**：使用 `spin::Mutex` 并确保中断处理快速完成。

```rust
// ❌ 错误：长时间持有锁
let scheduler = SCHEDULER.lock();
do_long_work();  // 可能触发中断

// ✅ 正确：最小化锁持有时间
{
    let scheduler = SCHEDULER.lock();
    scheduler.quick_operation();
}  // 锁立即释放
```

---

### 问题3：进程不切换

**原因**：时钟中断未使能。

**解决**：

```rust
// 检查sie寄存器的STIE位（bit 5）
pub fn check_timer_enabled() {
    let sie: usize;
    unsafe {
        core::arch::asm!("csrr {}, sie", out(reg) sie);
    }
    println!("sie={:#x}, STIE={}", sie, (sie >> 5) & 1);
}
```

---

## 下一步

第6章的**核心内容**已完成！

现在你已经实现了：
- ✅ PCB数据结构（6.1）
- ✅ 上下文切换（6.2）
- ✅ 轮转调度器（6.3）

**6.4节**将实现：
- fork系统调用（进程创建）
- exec系统调用（进程执行）
- exit系统调用（进程退出）
- wait系统调用（进程等待）

---

## 练习题

1. 如果时间片设置为0会怎样？
2. 如何实现优先级调度？
3. 为什么要在时钟中断处理的开头调用 `set_next_trigger()`？

<details>
<summary>答案提示</summary>

1. 每次时钟中断都会触发调度，导致频繁切换，性能极差
2. 使用优先级队列替代FIFO队列，每次选择优先级最高的进程
3. 因为如果后面的代码panic或出错,至少下一次中断还能触发,避免系统挂死

</details>
