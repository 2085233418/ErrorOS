# 6.3.2 轮转调度实现

## 本节目标

- 实现完整的轮转调度流程
- 配置时钟中断触发调度
- 实现时间片消耗机制
- 完成多进程切换测试

---

## 新增/修改文件

```
os/src/
├── timer.rs              # 新增：时钟中断处理
├── trap/mod.rs           # 修改：添加时钟中断处理
└── process/scheduler.rs  # 修改：完善调度逻辑
```

---

## 回顾：轮转调度原理

```
时间线：
0ms: ProcessA运行（时间片=5）
1ms: tick → 时间片=4
2ms: tick → 时间片=3
3ms: tick → 时间片=2
4ms: tick → 时间片=1
5ms: tick → 时间片=0 → 切换到ProcessB
6ms: ProcessB运行（时间片=5）
...
```

**核心思想**：
- 每个进程获得固定时间片
- 时间片用完，放回队尾
- 调度下一个进程

---

## 步骤1：配置时钟中断

### 1.1 RISC-V时钟中断机制

RISC-V使用SBI提供的时钟服务：

```rust
// os/src/sbi.rs（假设已有）
const SBI_SET_TIMER: usize = 0;

pub fn set_timer(stime_value: u64) {
    sbi_call(SBI_SET_TIMER, stime_value, 0, 0);
}
```

**原理**：
- 向SBI请求在指定时间触发中断
- 到达时间后触发 `Supervisor Timer Interrupt`

---

### 1.2 实现时钟初始化

创建 `os/src/timer.rs`：

```rust
//! 时钟中断管理

use crate::sbi;

/// 时钟频率（QEMU中为10MHz）
const CLOCK_FREQ: usize = 10_000_000;

/// 时间片长度（10ms = 100000 ticks）
const TICKS_PER_SLICE: usize = CLOCK_FREQ / 100;
```

**计算**：
- CLOCK_FREQ = 10,000,000 Hz（每秒10M次）
- 10ms = 0.01秒
- TICKS = 10,000,000 × 0.01 = 100,000

---

### 1.3 读取当前时间

```rust
/// 读取当前时间（CSR: time寄存器）
pub fn get_time() -> usize {
    let time: usize;
    unsafe {
        core::arch::asm!(
            "rdtime {0}",
            out(reg) time
        );
    }
    time
}
```

**rdtime指令**：
- 读取硬件时钟计数器
- 返回自系统启动以来的tick数

---

### 1.4 设置下一次中断

```rust
/// 设置下一次时钟中断
pub fn set_next_trigger() {
    let next = get_time() + TICKS_PER_SLICE;
    sbi::set_timer(next as u64);
}
```

**流程**：
1. 读取当前时间
2. 加上时间片长度
3. 请求SBI在该时间触发中断

---

### 1.5 初始化时钟

```rust
/// 初始化时钟中断
pub fn init() {
    // 使能时钟中断（设置sie.STIE位）
    unsafe {
        core::arch::asm!(
            "csrsi sie, 0x20"  // STIE = bit 5
        );
    }

    // 设置第一次时钟中断
    set_next_trigger();

    println!("[Timer] 时钟中断已初始化（时间片=10ms）");
}
```

---

## 步骤2：处理时钟中断

### 2.1 识别时钟中断

在 `os/src/trap/mod.rs` 中添加：

```rust
use riscv::register::scause::{Trap, Interrupt};

#[no_mangle]
pub fn trap_handler(cx: &mut TrapContext) {
    let scause = scause::read();
    let stval = stval::read();

    match scause.cause() {
        // 时钟中断
        Trap::Interrupt(Interrupt::SupervisorTimer) => {
            handle_timer_interrupt();
        }

        // 其他异常...
        _ => {
            panic!("未处理的异常: {:?}, stval={:#x}", scause.cause(), stval);
        }
    }
}
```

---

### 2.2 实现时钟中断处理

```rust
use crate::timer;
use crate::process;

fn handle_timer_interrupt() {
    // 1. 设置下一次时钟中断
    timer::set_next_trigger();

    // 2. 当前进程时间片-1
    let should_schedule = tick_current_process();

    // 3. 如果时间片用完，执行调度
    if should_schedule {
        process::schedule();
    }
}
```

**流程**：
1. 立即设置下一次中断（否则只会触发一次）
2. 消耗当前进程的时间片
3. 如果时间片为0，触发调度

---

### 2.3 实现时间片消耗

```rust
/// 当前进程时间片-1
///
/// 返回：true表示需要重新调度
fn tick_current_process() -> bool {
    use crate::process::SCHEDULER;

    let mut scheduler = SCHEDULER.lock();

    if let Some(ref current) = scheduler.current {
        let mut pcb = current.lock();

        // 消耗1个时间片
        let should_schedule = pcb.tick();

        if should_schedule {
            println!("[Scheduler] 进程 {} 时间片用完", pcb.pid());
            return true;
        }
    }

    false
}
```

---

## 步骤3：完善调度器

### 3.1 修改schedule方法

在 `os/src/process/scheduler.rs` 中修改：

```rust
impl RoundRobinScheduler {
    /// 执行一次调度（完整版）
    pub fn schedule(&mut self) {
        // 1. 保存旧进程引用
        let old = self.current.take();

        // 2. 将旧进程放回就绪队列
        if let Some(old_process) = old.as_ref() {
            let state = old_process.lock().state();

            // 只有Running状态才放回队列
            if state == ProcessState::Running {
                old_process.lock().set_state(ProcessState::Ready);
                old_process.lock().reset_time_slice();
                self.ready_queue.push(old_process.clone());
            }
        }

        // 3. 选择下一个进程
        if let Some(next) = self.pick_next() {
            println!("[Scheduler] 切换到进程 {}", next.lock().pid());

            // 4. 执行上下文切换
            if let Some(old_process) = old {
                unsafe {
                    let mut old_pcb = old_process.lock();
                    let next_pcb = next.lock();

                    old_pcb.switch_to(&next_pcb);
                }
            }

            self.current = Some(next);
        } else {
            // 无就绪进程
            println!("[Scheduler] 无就绪进程，执行idle");
            idle();
        }
    }
}
```

**关键点**：
- 使用 `take()` 取出旧进程，避免借用冲突
- 只切换Running状态的进程
- 调用 `switch_to()` 执行上下文切换

---

## 步骤4：初始化调度系统

### 4.1 在kernel_main中初始化

```rust
// os/src/main.rs

pub fn kernel_main() {
    println!("ERROR OS 启动中...");

    // 初始化中断系统
    trap::init();

    // 初始化时钟中断
    timer::init();

    // 创建测试进程
    test_scheduler();

    // 开始调度
    process::schedule();

    // 不应该到达这里
    panic!("kernel_main should not return");
}
```

---

### 4.2 创建测试进程

```rust
fn test_scheduler() {
    use crate::process::{create_process_handle, add_process};

    println!("\n=== 创建测试进程 ===");

    // 创建进程A
    let process_a = create_process_handle("ProcessA", None);
    init_test_process(&process_a, process_a_main);
    add_process(process_a);

    // 创建进程B
    let process_b = create_process_handle("ProcessB", None);
    init_test_process(&process_b, process_b_main);
    add_process(process_b);

    // 创建进程C
    let process_c = create_process_handle("ProcessC", None);
    init_test_process(&process_c, process_c_main);
    add_process(process_c);

    println!("就绪进程数: {}", process::ready_count());
}
```

---

### 4.3 初始化进程上下文

```rust
use crate::config::USER_STACK_SIZE;

fn init_test_process(
    process: &ProcessHandle,
    entry: fn() -> !,
) {
    // 分配用户栈
    let stack = alloc_user_stack();

    let mut pcb = process.lock();

    // 设置入口地址（ra寄存器）
    pcb.context_mut().set_ra(entry as usize);

    // 设置栈指针（sp寄存器）
    pcb.context_mut().set_sp(stack + USER_STACK_SIZE);

    // 设置sstatus（用户态，允许中断）
    pcb.context_mut().sstatus = 0x00040020;
}
```

**栈分配**：

```rust
fn alloc_user_stack() -> usize {
    use alloc::vec::Vec;

    // 分配4KB栈空间
    let mut stack = Vec::with_capacity(USER_STACK_SIZE);
    unsafe { stack.set_len(USER_STACK_SIZE); }

    let stack_bottom = stack.as_ptr() as usize;

    // 防止栈被回收
    core::mem::forget(stack);

    stack_bottom
}
```

---

### 4.4 定义测试进程函数

```rust
fn process_a_main() -> ! {
    for i in 0..10 {
        println!("[进程A] 第{}次运行", i);
        // 模拟工作
        for _ in 0..100000 {
            unsafe { core::arch::asm!("nop"); }
        }
    }
    println!("[进程A] 退出");
    loop {}
}

fn process_b_main() -> ! {
    for i in 0..10 {
        println!("[进程B] 第{}次运行", i);
        for _ in 0..100000 {
            unsafe { core::arch::asm!("nop"); }
        }
    }
    println!("[进程B] 退出");
    loop {}
}

fn process_c_main() -> ! {
    for i in 0..10 {
        println!("[进程C] 第{}次运行", i);
        for _ in 0..100000 {
            unsafe { core::arch::asm!("nop"); }
        }
    }
    println!("[进程C] 退出");
    loop {}
}
```

---

## 步骤5：测试运行

### 预期输出

```
ERROR OS 启动中...
[Trap] 中断系统已初始化
[Timer] 时钟中断已初始化（时间片=10ms）

=== 创建测试进程 ===
就绪进程数: 3

[Scheduler] 切换到进程 1
[进程A] 第0次运行
[进程A] 第1次运行
[Scheduler] 进程 1 时间片用完
[Scheduler] 切换到进程 2
[进程B] 第0次运行
[进程B] 第1次运行
[Scheduler] 进程 2 时间片用完
[Scheduler] 切换到进程 3
[进程C] 第0次运行
[Scheduler] 进程 3 时间片用完
[Scheduler] 切换到进程 1
[进程A] 第2次运行
...
```

**观察**：
- 进程按顺序轮流执行
- 每个进程运行约10ms后切换
- 实现了时间片轮转

---

## 步骤6：添加调度统计

### 6.1 统计上下文切换次数

在 `RoundRobinScheduler` 中添加：

```rust
pub struct RoundRobinScheduler {
    ready_queue: ReadyQueue,
    current: Option<ProcessHandle>,
    switch_count: usize,  // 新增：切换次数
}

impl RoundRobinScheduler {
    pub fn schedule(&mut self) {
        // ... 原有代码

        if let Some(next) = self.pick_next() {
            self.switch_count += 1;  // 统计切换次数

            println!(
                "[Scheduler] 第{}次切换：→ 进程{}",
                self.switch_count,
                next.lock().pid()
            );

            // ... 原有代码
        }
    }
}
```

---

### 6.2 打印调度统计

```rust
impl RoundRobinScheduler {
    pub fn print_stats(&self) {
        println!("\n=== 调度统计 ===");
        println!("总切换次数: {}", self.switch_count);
        println!("当前就绪进程: {}", self.ready_queue.len());
    }
}
```

---

## 知识点总结

### 时间片轮转算法

```
就绪队列: [A, B, C]
             ↓
          选择A运行
             ↓
        时钟中断（10ms后）
             ↓
         时间片用完？
         Yes ↓     No → 继续运行
     放回队尾 [B, C, A]
             ↓
          选择B运行
```

### 关键组件

| 组件 | 作用 |
|------|------|
| **时钟中断** | 定期触发，驱动调度 |
| **时间片计数** | 跟踪进程运行时间 |
| **就绪队列** | 存储等待运行的进程 |
| **上下文切换** | 保存/恢复进程状态 |

### 时间片大小权衡

| 时间片大小 | 优点 | 缺点 |
|-----------|------|------|
| **1ms** | 响应极快 | 切换开销占比大（~20%） |
| **10ms** | 平衡 | 较好的响应和效率 |
| **100ms** | 开销小 | 响应慢，不适合交互 |

**典型值**：Linux使用4-10ms。

---

## 常见问题

### 问题1：进程只切换一次就停止

**原因**：忘记在时钟中断处理中调用 `set_next_trigger()`。

**解决**：

```rust
fn handle_timer_interrupt() {
    timer::set_next_trigger();  // ← 必须添加！
    // ...
}
```

---

### 问题2：调度器死锁

**原因**：在持有锁的情况下触发中断，中断处理又尝试获取锁。

**解决**：使用 `spin::Mutex` 并确保中断处理快速完成。

```rust
// ❌ 错误：长时间持有锁
let scheduler = SCHEDULER.lock();
do_long_work();  // 可能触发中断

// ✅ 正确：最小化锁持有时间
{
    let scheduler = SCHEDULER.lock();
    scheduler.quick_operation();
}  // 锁立即释放
```

---

### 问题3：进程不切换

**原因**：时钟中断未使能。

**解决**：

```rust
// 检查sie寄存器的STIE位（bit 5）
pub fn check_timer_enabled() {
    let sie: usize;
    unsafe {
        core::arch::asm!("csrr {}, sie", out(reg) sie);
    }
    println!("sie={:#x}, STIE={}", sie, (sie >> 5) & 1);
}
```

---

## 下一步

第6章的**核心内容**已完成！

现在你已经实现了：
- ✅ PCB数据结构（6.1）
- ✅ 上下文切换（6.2）
- ✅ 轮转调度器（6.3）

**6.4节**将实现：
- fork系统调用（进程创建）
- exec系统调用（进程执行）
- exit系统调用（进程退出）
- wait系统调用（进程等待）

---

## 练习题

1. 如果时间片设置为0会怎样？
2. 如何实现优先级调度？
3. 为什么要在时钟中断处理的开头调用 `set_next_trigger()`？

<details>
<summary>答案提示</summary>

1. 每次时钟中断都会触发调度，导致频繁切换，性能极差
2. 使用优先级队列替代FIFO队列，每次选择优先级最高的进程
3. 因为如果后面的代码panic或出错,至少下一次中断还能触发,避免系统挂死

</details>
