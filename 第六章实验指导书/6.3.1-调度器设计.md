# 6.3.1 调度器设计

## 本节目标

- 理解进程调度的目标和策略
- 设计调度器接口
- 实现就绪队列管理
- 为轮转调度算法做准备

---

## 新增文件

```
os/src/process/
├── scheduler.rs      # 新增：调度器实现
└── mod.rs            # 修改：导出调度器
```

---

## 什么是进程调度？

**进程调度（Process Scheduling）** = 决定哪个进程获得CPU执行权

### 类比：餐厅叫号系统

```
就绪队列：[003号, 007号, 012号]
              ↓
         调度器选择
              ↓
         003号就餐（Running）
              ↓
         时间到/主动离开
              ↓
    回到队尾 或 离开餐厅
```

---

## 调度的目标

### 1. 公平性（Fairness）
- 每个进程都应该有机会运行
- 不能让某个进程永久饥饿

### 2. 响应速度（Responsiveness）
- 交互式程序要快速响应
- 用户不应感到卡顿

### 3. 吞吐量（Throughput）
- 单位时间完成更多任务
- 减少上下文切换开销

### 4. CPU利用率（CPU Utilization）
- 尽量让CPU忙碌
- 进程阻塞时立即切换到其他进程

**权衡**：这些目标常常互相冲突！

---

## 调度时机

### 何时触发调度？

1. **时间片耗尽**
   - 时钟中断触发
   - 当前进程被抢占

2. **进程主动让出CPU**
   - 调用 `yield()` 系统调用
   - 进入Blocked状态（等待I/O）

3. **进程退出**
   - 调用 `exit()` 系统调用
   - 必须选择下一个进程

4. **新进程就绪**（可选）
   - fork创建子进程
   - I/O完成，进程从Blocked→Ready

---

## 调度器接口设计

### 核心方法

```rust
pub trait Scheduler {
    /// 添加进程到就绪队列
    fn add_process(&mut self, process: ProcessHandle);

    /// 选择下一个运行的进程
    fn pick_next(&mut self) -> Option<ProcessHandle>;

    /// 移除进程（进程退出时）
    fn remove_process(&mut self, pid: ProcessId);

    /// 获取就绪进程数量
    fn ready_count(&self) -> usize;
}
```

---

## 就绪队列设计

### 简单队列实现

```rust
use alloc::collections::VecDeque;
use alloc::vec::Vec;

pub struct ReadyQueue {
    /// 就绪进程队列（FIFO）
    queue: VecDeque<ProcessHandle>,
}

impl ReadyQueue {
    /// 创建空队列
    pub fn new() -> Self {
        ReadyQueue {
            queue: VecDeque::new(),
        }
    }
}
```

**为什么用VecDeque？**

- 支持高效的队首/队尾操作
- `push_back()` 添加到队尾 O(1)
- `pop_front()` 从队首取出 O(1)

---

## 步骤1：实现就绪队列基本操作

### 1.1 添加进程

```rust
impl ReadyQueue {
    /// 添加进程到队尾
    pub fn push(&mut self, process: ProcessHandle) {
        // 确保进程是Ready状态
        let state = process.lock().state();
        assert_eq!(state, ProcessState::Ready);

        self.queue.push_back(process);
    }
}
```

### 1.2 取出进程

```rust
impl ReadyQueue {
    /// 从队首取出进程
    pub fn pop(&mut self) -> Option<ProcessHandle> {
        self.queue.pop_front()
    }
}
```

### 1.3 查询队列

```rust
impl ReadyQueue {
    /// 获取就绪进程数量
    pub fn len(&self) -> usize {
        self.queue.len()
    }

    /// 判断队列是否为空
    pub fn is_empty(&self) -> bool {
        self.queue.is_empty()
    }
}
```

---

## 步骤2：实现调度器结构

### 2.1 定义调度器

```rust
use spin::Mutex;
use alloc::sync::Arc;

/// 简单轮转调度器
pub struct RoundRobinScheduler {
    /// 就绪队列
    ready_queue: ReadyQueue,

    /// 当前运行进程
    current: Option<ProcessHandle>,
}
```

**字段说明**：
- `ready_queue`：等待运行的进程队列
- `current`：正在CPU上执行的进程

---

### 2.2 创建调度器

```rust
impl RoundRobinScheduler {
    /// 创建新调度器
    pub const fn new() -> Self {
        RoundRobinScheduler {
            ready_queue: ReadyQueue::new(),
            current: None,
        }
    }
}
```

**注意**：用 `const fn` 允许在编译时初始化。

---

## 步骤3：实现调度器核心方法

### 3.1 添加进程

```rust
impl RoundRobinScheduler {
    /// 添加进程到就绪队列
    pub fn add_process(&mut self, process: ProcessHandle) {
        // 设置进程为Ready状态
        process.lock().set_state(ProcessState::Ready);

        // 添加到队列
        self.ready_queue.push(process);
    }
}
```

---

### 3.2 选择下一个进程

```rust
impl RoundRobinScheduler {
    /// 选择下一个运行的进程（轮转算法）
    ///
    /// 返回：Some(进程) 或 None（无就绪进程）
    pub fn pick_next(&mut self) -> Option<ProcessHandle> {
        // 从就绪队列取出队首进程
        if let Some(next) = self.ready_queue.pop() {
            // 设置为Running状态
            next.lock().set_state(ProcessState::Running);

            // 重置时间片
            next.lock().reset_time_slice();

            Some(next)
        } else {
            None
        }
    }
}
```

**流程**：
1. 从就绪队列取出队首进程
2. 设置状态为Running
3. 重置时间片
4. 返回进程句柄

---

### 3.3 进程让出CPU

```rust
impl RoundRobinScheduler {
    /// 当前进程让出CPU（时间片用完或主动yield）
    ///
    /// 将当前进程放回就绪队列尾部
    pub fn yield_current(&mut self) {
        if let Some(current) = self.current.take() {
            // 如果进程还是Running状态，转为Ready
            let state = current.lock().state();
            if state == ProcessState::Running {
                current.lock().set_state(ProcessState::Ready);

                // 重置时间片
                current.lock().reset_time_slice();

                // 放回队尾
                self.ready_queue.push(current);
            }
        }
    }
}
```

**关键点**：
- `take()` 取出当前进程，同时将 `current` 设为 `None`
- 只有Running状态的进程才放回队列
- Blocked/Zombie状态的进程不加入队列

---

### 3.4 移除进程

```rust
impl RoundRobinScheduler {
    /// 移除进程（进程退出时调用）
    pub fn remove_process(&mut self, pid: ProcessId) {
        // 从就绪队列移除
        self.ready_queue.queue.retain(|p| {
            p.lock().pid() != pid
        });

        // 如果是当前进程，清空current
        if let Some(ref current) = self.current {
            if current.lock().pid() == pid {
                self.current = None;
            }
        }
    }
}
```

---

## 步骤4：实现进程切换逻辑

### 4.1 执行调度

```rust
impl RoundRobinScheduler {
    /// 执行一次调度
    ///
    /// 保存当前进程上下文，切换到下一个进程
    pub fn schedule(&mut self) {
        // 1. 将当前进程放回就绪队列
        self.yield_current();

        // 2. 选择下一个进程
        if let Some(next) = self.pick_next() {
            self.current = Some(next.clone());

            // 3. 执行上下文切换（在下一节实现完整调用）
            // __switch(&mut old_cx, &next_cx);
        } else {
            // 无就绪进程，执行idle
            idle();
        }
    }
}
```

### 4.2 空闲进程

```rust
/// 没有就绪进程时执行idle
fn idle() {
    loop {
        // 等待中断
        unsafe {
            core::arch::asm!("wfi");  // Wait For Interrupt
        }
    }
}
```

**wfi指令**：
- 让CPU进入低功耗状态
- 等待中断唤醒
- 省电模式

---

## 步骤5：全局调度器实例

### 5.1 定义全局调度器

```rust
use spin::Mutex;
use lazy_static::lazy_static;

lazy_static! {
    /// 全局调度器
    pub static ref SCHEDULER: Mutex<RoundRobinScheduler> = {
        Mutex::new(RoundRobinScheduler::new())
    };
}
```

### 5.2 提供便捷接口

```rust
/// 添加进程到调度器
pub fn add_process(process: ProcessHandle) {
    SCHEDULER.lock().add_process(process);
}

/// 执行调度
pub fn schedule() {
    SCHEDULER.lock().schedule();
}

/// 当前进程主动让出CPU
pub fn yield_now() {
    SCHEDULER.lock().yield_current();
    SCHEDULER.lock().schedule();
}
```

---

## 步骤6：完整代码

<details>
<summary><b>点击展开：os/src/process/scheduler.rs 完整实现</b></summary>

```rust
//! 进程调度器

use super::{ProcessHandle, ProcessId, ProcessState};
use alloc::collections::VecDeque;
use spin::Mutex;
use lazy_static::lazy_static;

/// 就绪队列
pub struct ReadyQueue {
    queue: VecDeque<ProcessHandle>,
}

impl ReadyQueue {
    pub const fn new() -> Self {
        ReadyQueue {
            queue: VecDeque::new(),
        }
    }

    pub fn push(&mut self, process: ProcessHandle) {
        self.queue.push_back(process);
    }

    pub fn pop(&mut self) -> Option<ProcessHandle> {
        self.queue.pop_front()
    }

    pub fn len(&self) -> usize {
        self.queue.len()
    }

    pub fn is_empty(&self) -> bool {
        self.queue.is_empty()
    }
}

/// 轮转调度器
pub struct RoundRobinScheduler {
    ready_queue: ReadyQueue,
    current: Option<ProcessHandle>,
}

impl RoundRobinScheduler {
    pub const fn new() -> Self {
        RoundRobinScheduler {
            ready_queue: ReadyQueue::new(),
            current: None,
        }
    }

    pub fn add_process(&mut self, process: ProcessHandle) {
        process.lock().set_state(ProcessState::Ready);
        self.ready_queue.push(process);
    }

    pub fn pick_next(&mut self) -> Option<ProcessHandle> {
        if let Some(next) = self.ready_queue.pop() {
            next.lock().set_state(ProcessState::Running);
            next.lock().reset_time_slice();
            Some(next)
        } else {
            None
        }
    }

    pub fn yield_current(&mut self) {
        if let Some(current) = self.current.take() {
            let state = current.lock().state();
            if state == ProcessState::Running {
                current.lock().set_state(ProcessState::Ready);
                current.lock().reset_time_slice();
                self.ready_queue.push(current);
            }
        }
    }

    pub fn remove_process(&mut self, pid: ProcessId) {
        self.ready_queue.queue.retain(|p| {
            p.lock().pid() != pid
        });

        if let Some(ref current) = self.current {
            if current.lock().pid() == pid {
                self.current = None;
            }
        }
    }

    pub fn schedule(&mut self) {
        self.yield_current();

        if let Some(next) = self.pick_next() {
            self.current = Some(next);
        } else {
            idle();
        }
    }

    pub fn ready_count(&self) -> usize {
        self.ready_queue.len()
    }
}

fn idle() {
    loop {
        unsafe {
            core::arch::asm!("wfi");
        }
    }
}

lazy_static! {
    pub static ref SCHEDULER: Mutex<RoundRobinScheduler> = {
        Mutex::new(RoundRobinScheduler::new())
    };
}

pub fn add_process(process: ProcessHandle) {
    SCHEDULER.lock().add_process(process);
}

pub fn schedule() {
    SCHEDULER.lock().schedule();
}

pub fn yield_now() {
    SCHEDULER.lock().yield_current();
    SCHEDULER.lock().schedule();
}

pub fn ready_count() -> usize {
    SCHEDULER.lock().ready_count()
}
```

</details>

---

## 步骤7：更新mod.rs

```rust
// os/src/process/mod.rs
pub mod pid;
pub mod pcb;
pub mod context;
pub mod scheduler;  // 新增

pub use pid::ProcessId;
pub use pcb::{ProcessState, ProcessControlBlock, ProcessHandle, create_process_handle};
pub use context::{ProcessContext, __switch};
pub use scheduler::{add_process, schedule, yield_now, ready_count};  // 新增
```

---

## 调度算法对比

| 算法 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| **先来先服务(FCFS)** | 简单，公平 | 短任务等待长任务 | 批处理系统 |
| **轮转(Round-Robin)** | 响应快，公平 | 上下文切换开销 | 分时系统 |
| **优先级调度** | 重要任务优先 | 低优先级饥饿 | 实时系统 |
| **多级反馈队列** | 自适应 | 复杂 | 通用操作系统 |

我们实现的是**轮转调度**，因为它简单且适合教学。

---

## 知识点总结

### 就绪队列的作用

```
进程生命周期：
创建 → Ready → Running → Ready → ... → Exit
        ↑        ↓
      就绪队列   调度器选择
```

### 调度器职责

1. **维护就绪队列**：管理等待CPU的进程
2. **选择进程**：根据算法选择下一个运行的进程
3. **上下文切换**：保存/恢复进程状态
4. **时间片管理**：控制进程运行时间

---

## 下一步

现在我们有了调度器的框架！

**6.3.2节**将实现：
- 完整的轮转调度流程
- 时间片中断处理
- 真正的多进程切换测试

---

## 练习题

1. 为什么就绪队列用VecDeque而不是Vec？
2. 如果 `pick_next()` 返回None，系统应该做什么？
3. 时间片设置为1ms和100ms有什么区别？

<details>
<summary>答案提示</summary>

1. VecDeque支持O(1)的队首/队尾操作，适合FIFO队列；Vec的pop(0)是O(n)
2. 执行idle进程，用wfi指令进入低功耗等待中断
3. 1ms：响应快但上下文切换开销大；100ms：开销小但响应慢，需要权衡

</details>
