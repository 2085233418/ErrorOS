# 6.1.5 PCB完整实现

## 本节目标

- 整合前面所有组件
- 实现完整的PCB结构体
- 实现PCB的创建、管理方法
- 理解Arc<Mutex<>>的使用

---

## 回顾已完成的组件

现在我们已经有了：
- ✅ **ProcessId** (6.1.2) - PID分配器
- ✅ **ProcessState** (6.1.3) - 进程状态枚举
- ✅ **ProcessContext** (6.1.4) - 进程上下文

本节将把它们整合到PCB中。

---

## 步骤1：定义完整的PCB结构

在 `os/src/process/pcb.rs` 中添加：

```rust
use super::{ProcessId, ProcessContext};
use alloc::vec::Vec;

/// 进程控制块
pub struct ProcessControlBlock {
    // === 身份信息 ===
    pid: ProcessId,
    name: &'static str,
    
    // === 状态信息 ===
    state: ProcessState,
    exit_code: Option<i32>,
    
    // === 关系信息 ===
    parent_pid: Option<ProcessId>,
    children: Vec<ProcessId>,
    
    // === 执行上下文 ===
    context: ProcessContext,
    
    // === 调度信息 ===
    time_slice: usize,
    priority: usize,
}
```

**注意**：暂时不包含地址空间（AddressSpace），那是虚拟内存部分。

---

## 步骤2：实现PCB创建

```rust
impl ProcessControlBlock {
    /// 创建新进程
    pub fn new(
        pid: ProcessId,
        name: &'static str,
        parent_pid: Option<ProcessId>,
    ) -> Self {
        ProcessControlBlock {
            pid,
            name,
            state: ProcessState::Ready,
            exit_code: None,
            parent_pid,
            children: Vec::new(),
            context: ProcessContext::new(),
            time_slice: 5,     // 默认时间片
            priority: 1,       // 默认优先级
        }
    }
}
```

---

## 步骤3：实现状态管理方法

### 3.1 状态查询和设置

```rust
impl ProcessControlBlock {
    /// 获取进程状态
    pub fn state(&self) -> ProcessState {
        self.state
    }
    
    /// 设置进程状态
    pub fn set_state(&mut self, state: ProcessState) {
        self.state = state;
    }
    
    /// 判断是否可运行
    pub fn is_runnable(&self) -> bool {
        self.state == ProcessState::Ready
    }
}
```

### 3.2 PID相关方法

```rust
impl ProcessControlBlock {
    /// 获取PID
    pub fn pid(&self) -> ProcessId {
        self.pid
    }
    
    /// 获取父进程PID
    pub fn parent_pid(&self) -> Option<ProcessId> {
        self.parent_pid
    }
}
```

---

## 步骤4：实现时间片管理

```rust
impl ProcessControlBlock {
    /// 消耗1个时间片
    /// 
    /// 返回true表示时间片用完，需要重新调度
    pub fn tick(&mut self) -> bool {
        if self.time_slice > 0 {
            self.time_slice -= 1;
        }
        self.time_slice == 0
    }
    
    /// 重置时间片
    pub fn reset_time_slice(&mut self) {
        self.time_slice = 5;
    }
    
    /// 获取剩余时间片
    pub fn time_slice(&self) -> usize {
        self.time_slice
    }
}
```

**为什么需要时间片？**

防止某个进程长时间占用CPU，保证公平性。

---

## 步骤5：实现父子关系管理

```rust
impl ProcessControlBlock {
    /// 添加子进程
    pub fn add_child(&mut self, pid: ProcessId) {
        self.children.push(pid);
    }
    
    /// 移除子进程
    pub fn remove_child(&mut self, pid: ProcessId) {
        self.children.retain(|&p| p != pid);
    }
    
    /// 获取子进程列表
    pub fn children(&self) -> &[ProcessId] {
        &self.children
    }
}
```

---

## 步骤6：实现退出码管理

```rust
impl ProcessControlBlock {
    /// 设置退出码并转为Zombie状态
    pub fn set_exit_code(&mut self, code: i32) {
        self.exit_code = Some(code);
        self.state = ProcessState::Zombie;
    }
    
    /// 获取退出码
    pub fn exit_code(&self) -> Option<i32> {
        self.exit_code
    }
}
```

---

## 步骤7：使用Arc<Mutex<>>包装

### 7.1 为什么需要Arc<Mutex<>>？

**Arc（原子引用计数）**：
- 多个地方可能持有同一个进程
- 例如：调度器、父进程、子进程列表

**Mutex（互斥锁）**：
- 多个CPU核心可能同时访问
- 保证数据一致性

### 7.2 定义ProcessHandle类型

```rust
use alloc::sync::Arc;
use spin::Mutex;

/// 进程句柄（共享所有权的PCB）
pub type ProcessHandle = Arc<Mutex<ProcessControlBlock>>;
```

### 7.3 创建辅助函数

```rust
/// 创建进程句柄
pub fn create_process_handle(
    name: &'static str,
    parent_pid: Option<ProcessId>,
) -> ProcessHandle {
    let pid = ProcessId::new();
    let pcb = ProcessControlBlock::new(pid, name, parent_pid);
    Arc::new(Mutex::new(pcb))
}
```

**使用示例**：

```rust
// 创建init进程
let init = create_process_handle("init", None);

// 访问PCB
let pid = init.lock().pid();
init.lock().set_state(ProcessState::Running);
```

---

## 步骤8：完整代码

<details>
<summary><b>点击展开：os/src/process/pcb.rs 完整实现</b></summary>

```rust
//! 进程控制块（PCB）

use super::{ProcessId, ProcessContext};
use core::fmt;
use alloc::vec::Vec;
use alloc::sync::Arc;
use spin::Mutex;

/// 进程状态枚举
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ProcessState {
    Ready,
    Running,
    Blocked,
    Zombie,
}

impl ProcessState {
    pub fn can_transition_to(self, target: ProcessState) -> bool {
        use ProcessState::*;
        match (self, target) {
            (Ready, Running) => true,
            (Running, Ready) => true,
            (Running, Blocked) => true,
            (Running, Zombie) => true,
            (Blocked, Ready) => true,
            (Zombie, _) => false,
            _ => false,
        }
    }
    
    pub fn description(self) -> &'static str {
        match self {
            ProcessState::Ready => "就绪",
            ProcessState::Running => "运行",
            ProcessState::Blocked => "阻塞",
            ProcessState::Zombie => "僵尸",
        }
    }
    
    pub fn is_terminal(self) -> bool {
        self == ProcessState::Zombie
    }
}

impl fmt::Display for ProcessState {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let s = match self {
            ProcessState::Ready => "Ready",
            ProcessState::Running => "Running",
            ProcessState::Blocked => "Blocked",
            ProcessState::Zombie => "Zombie",
        };
        write!(f, "{}", s)
    }
}

/// 进程控制块
pub struct ProcessControlBlock {
    pid: ProcessId,
    name: &'static str,
    state: ProcessState,
    exit_code: Option<i32>,
    parent_pid: Option<ProcessId>,
    children: Vec<ProcessId>,
    context: ProcessContext,
    time_slice: usize,
    priority: usize,
}

impl ProcessControlBlock {
    /// 创建新进程
    pub fn new(
        pid: ProcessId,
        name: &'static str,
        parent_pid: Option<ProcessId>,
    ) -> Self {
        ProcessControlBlock {
            pid,
            name,
            state: ProcessState::Ready,
            exit_code: None,
            parent_pid,
            children: Vec::new(),
            context: ProcessContext::new(),
            time_slice: 5,
            priority: 1,
        }
    }
    
    // === 状态管理 ===
    pub fn state(&self) -> ProcessState {
        self.state
    }
    
    pub fn set_state(&mut self, state: ProcessState) {
        self.state = state;
    }
    
    pub fn is_runnable(&self) -> bool {
        self.state == ProcessState::Ready
    }
    
    // === PID相关 ===
    pub fn pid(&self) -> ProcessId {
        self.pid
    }
    
    pub fn parent_pid(&self) -> Option<ProcessId> {
        self.parent_pid
    }
    
    pub fn name(&self) -> &'static str {
        self.name
    }
    
    // === 时间片管理 ===
    pub fn tick(&mut self) -> bool {
        if self.time_slice > 0 {
            self.time_slice -= 1;
        }
        self.time_slice == 0
    }
    
    pub fn reset_time_slice(&mut self) {
        self.time_slice = 5;
    }
    
    pub fn time_slice(&self) -> usize {
        self.time_slice
    }
    
    pub fn set_priority(&mut self, priority: usize) {
        self.priority = priority;
    }
    
    pub fn priority(&self) -> usize {
        self.priority
    }
    
    // === 父子关系管理 ===
    pub fn add_child(&mut self, pid: ProcessId) {
        self.children.push(pid);
    }
    
    pub fn remove_child(&mut self, pid: ProcessId) {
        self.children.retain(|&p| p != pid);
    }
    
    pub fn children(&self) -> &[ProcessId] {
        &self.children
    }
    
    // === 退出码管理 ===
    pub fn set_exit_code(&mut self, code: i32) {
        self.exit_code = Some(code);
        self.state = ProcessState::Zombie;
    }
    
    pub fn exit_code(&self) -> Option<i32> {
        self.exit_code
    }
    
    // === 上下文访问 ===
    pub fn context_mut(&mut self) -> &mut ProcessContext {
        &mut self.context
    }
    
    pub fn context(&self) -> &ProcessContext {
        &self.context
    }
}

/// 进程句柄（共享所有权的PCB）
pub type ProcessHandle = Arc<Mutex<ProcessControlBlock>>;

/// 创建进程句柄
pub fn create_process_handle(
    name: &'static str,
    parent_pid: Option<ProcessId>,
) -> ProcessHandle {
    let pid = ProcessId::new();
    let pcb = ProcessControlBlock::new(pid, name, parent_pid);
    Arc::new(Mutex::new(pcb))
}
```

</details>

---

## 步骤9：更新mod.rs导出

```rust
// os/src/process/mod.rs
pub mod pid;
pub mod pcb;
pub mod context;
pub mod visualization;  // 如果有

pub use pid::ProcessId;
pub use pcb::{ProcessState, ProcessControlBlock, ProcessHandle, create_process_handle};
pub use context::ProcessContext;
```

---

## 步骤10：测试PCB

在 `os/src/main.rs` 中添加测试：

```rust
use os::process::create_process_handle;

println!("\n测试PCB...");

// 创建init进程
let init = create_process_handle("init", None);
println!("创建进程: PID={}", init.lock().pid());

// 测试状态转换
init.lock().set_state(os::process::ProcessState::Running);
println!("状态: {}", init.lock().state());

// 测试时间片
for i in 1..=5 {
    let should_schedule = init.lock().tick();
    println!("Tick {}: 剩余时间片={}, 需要调度={}", 
        i, init.lock().time_slice(), should_schedule);
}
```

---

## 知识点总结

### PCB字段总览

| 类别 | 字段 | 用途 |
|------|------|------|
| 身份 | pid, name | 唯一标识 |
| 状态 | state, exit_code | 生命周期管理 |
| 关系 | parent_pid, children | 进程树 |
| 上下文 | context | CPU状态 |
| 调度 | time_slice, priority | 调度策略 |

### Arc<Mutex<>>使用要点

```rust
// 创建
let process = Arc::new(Mutex::new(pcb));

// 访问（自动加锁）
let pid = process.lock().pid();

// 修改（自动加锁）
process.lock().set_state(ProcessState::Running);

// 克隆句柄（共享同一个PCB）
let process2 = Arc::clone(&process);
```

---

## 下一步

6.1节完成！现在我们有了完整的PCB实现。

下一步（6.2节）将实现**上下文切换**，真正让多个进程切换执行。

---

## 练习题

1. 为什么要用Option包装exit_code？
2. 如果不用Arc<Mutex<>>会有什么问题？
3. 时间片用完但进程还没结束怎么办？

<details>
<summary>答案提示</summary>

1. 运行中的进程没有退出码
2. 会出现所有权转移问题，无法多处持有
3. 重置时间片，把进程放回就绪队列

</details>
