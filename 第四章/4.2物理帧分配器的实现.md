# 第3章：物理帧分配器的实现

## 引言

在前面的章节中，我们了解了为什么需要虚拟内存，但在实现虚拟内存之前，我们需要先解决一个基础问题：**如何将之前的简单堆内存分配器升级到物理页帧分配器？**

目前 os 中的堆分配器使用 `init_heap_simple`，它直接在物理内存上初始化堆，没有任何物理内存管理机制。这在实现虚拟内存时会遇到问题，因为虚拟内存需要动态分配物理页帧来建立映射。

本章将教你实现一个简单的**物理帧分配器**，为后续的虚拟内存管理打下基础。

---

## 1. 理论基础：什么是物理帧？

### 1.1 物理内存的组织方式

在 RISC-V 架构中，物理内存以**页（Page）**为单位进行管理，每个页的大小是 **4 KB（4096 字节）**。

```
物理内存（QEMU virt 机器，128 MB）：
┌────────────────────────────────────────────────┐
│  0x80000000                    0x88000000      │
├────────┬────────┬────────┬────────┬───────────-┤
│ 内核    │  4KB   │  4KB   │  4KB   │    ...    │
│ 代码    │  页帧   │  页帧  │  页帧   │    ...    │ 
└────────┴────────┴────────┴────────┴───────────┘
         ↑        ↑        ↑
      帧编号0    帧编号1   帧编号2
```

**关键概念**：
- **物理页帧（Physical Frame）**：物理内存中的一个 4 KB 单元
- **帧编号（Frame Number）**：物理帧的索引，从 0 开始
- **帧地址**：`帧编号 × 4096`

### 1.2 为什么需要物理帧分配器？

在 os 中，`init_heap_simple` 的实现方式：

```rust
pub fn init_heap_simple(kernel_end_addr: usize) -> Result<(), &'static str> {
    let heap_start = align_up(kernel_end_addr, 4096);
    unsafe {
        ALLOCATOR.lock().init(heap_start, HEAP_SIZE);
    }
    Ok(())
}
```

**问题**：
- ❌ **没有记录哪些物理内存已被使用**
- ❌ **无法动态分配物理页帧**
- ❌ **不支持虚拟内存所需的页表分配**

## 2. 设计物理帧分配器

### 2.1 分配器的核心功能

我们需要实现一个简单的物理帧分配器，提供两个基本功能：

| 功能 | 说明 |
|------|------|
| `allocate()` | 分配一个物理帧，返回帧的起始地址 |
| `deallocate()` | 释放一个物理帧（当前实现为空，可扩展） |

### 2.2 分配策略

我们采用**线性分配策略**（类似 Bump 分配器）：

```
初始状态：
┌────────┬─────────────────────────────────┐
│ 内核    │         可分配区域               │
└────────┴─────────────────────────────────┘
         ↑                                 ↑
    kernel_end                       memory_end
    next_frame（下一个可分配的帧）
```

**分配过程**：
1. 从 `next_frame` 位置分配
2. `next_frame` 向后移动一个帧
3. 重复直到达到 `memory_end`

### 2.3 数据结构设计

```rust
/// 物理帧分配器
pub struct SimpleFrameAllocator {
    next_frame: usize,    // 下一个可分配的帧编号
    end_frame: usize,     // 最后一个可用的帧编号
}
```

**说明**：
- `next_frame`：下一个可分配的帧编号（不是地址，是编号）
- `end_frame`：物理内存结束位置对应的帧编号

---

## 3. 代码实现：步骤1 - 创建 memory 模块

### 3.1 创建文件结构

在 `src` 目录下创建 `memory` 文件夹和 `mod.rs` 文件：

```
src/
├── memory/
│   └── mod.rs    # 新建
├── allocator.rs
├── lib.rs
└── main.rs
```

### 3.2 定义常量

在 `src/memory/mod.rs` 中添加：

```rust
// src/memory/mod.rs

/// 页大小（4KB）
pub const PAGE_SIZE: usize = 4096;
```

**说明**：
- `PAGE_SIZE = 4096`：RISC-V Sv39 标准页大小

---

## 4. 代码实现：步骤2 - 实现物理地址抽象

在继续实现分配器之前，我们先定义物理地址和物理帧的抽象类型。

### 4.1 定义物理地址类型

```rust
/// RISC-V 物理地址
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
#[repr(transparent)]
pub struct PhysAddr(usize);

impl PhysAddr {
    /// 创建新的物理地址
    pub const fn new(addr: usize) -> Self {
        PhysAddr(addr)
    }

    /// 获取地址值
    pub const fn as_usize(self) -> usize {
        self.0
    }
}
```


### 4.2 定义物理帧类型

```rust
/// 物理帧（4KB 对齐的物理内存块）
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct PhysFrame {
    start_address: PhysAddr,
}

impl PhysFrame {
    /// 获取包含给定物理地址的帧
    pub fn containing_address(addr: PhysAddr) -> Self {
        PhysFrame {
            start_address: PhysAddr::new(addr.as_usize() & !0xFFF),
        }
    }

    /// 获取帧的起始地址
    pub fn start_address(self) -> PhysAddr {
        self.start_address
    }
}
```

**关键操作**：
- `addr & !0xFFF`：清除低 12 位，将地址向下对齐到 4 KB 边界
- `!0xFFF = 0xFFFFF...FFF000`（低 12 位为 0）

**示例**：
```
地址 0x80001234：
0x80001234 & !0xFFF = 0x80001000  （向下对齐到 4KB）
```

---

## 5. 代码实现：步骤3 - 实现物理帧分配器

### 5.1 定义分配器结构

```rust
/// 简单的物理帧分配器
///
/// # 说明
/// 从固定的物理内存区域分配帧
/// QEMU virt 机器的物理内存布局：
/// - 0x80000000 - 0x88000000（128MB）
pub struct SimpleFrameAllocator {
    next_frame: usize,
    end_frame: usize,
}
```

### 5.2 实现构造函数

```rust
impl SimpleFrameAllocator {
    /// 创建新的帧分配器
    ///
    /// # 参数
    /// - `kernel_end`: 内核结束地址
    /// - `memory_end`: 物理内存结束地址
    pub fn new(kernel_end: usize, memory_end: usize) -> Self {
        // 将地址转换为帧编号
        let next_frame = (kernel_end + PAGE_SIZE - 1) / PAGE_SIZE;
        let end_frame = memory_end / PAGE_SIZE;

        crate::serial_println!(
            "[MEMORY] Frame allocator initialized: {:#x} - {:#x}",
            next_frame * PAGE_SIZE,
            end_frame * PAGE_SIZE
        );

        SimpleFrameAllocator {
            next_frame,
            end_frame,
        }
    }
}
```

**计算解析**：

```
假设：
kernel_end = 0x80400000（内核结束地址）
memory_end = 0x88000000（128 MB 物理内存结束）

计算 next_frame：
next_frame = (0x80400000 + 4096 - 1) / 4096
           = 0x80400FFF / 4096
           = 525313（帧编号）

计算 end_frame：
end_frame = 0x88000000 / 4096
          = 557056（帧编号）

可分配帧数：557056 - 525313 = 31743 个帧
可分配内存：31743 × 4096 ≈ 124 MB
```

### 5.3 实现分配方法

```rust
impl SimpleFrameAllocator {
    /// 分配一个物理帧
    pub fn allocate(&mut self) -> Option<PhysFrame> {
        if self.next_frame >= self.end_frame {
            return None;  // 内存耗尽
        }

        let frame = PhysFrame::containing_address(PhysAddr::new(
            self.next_frame * PAGE_SIZE,
        ));
        self.next_frame += 1;

        Some(frame)
    }
}
```

**分配流程**：
1. 检查是否还有可用帧（`next_frame < end_frame`）
2. 计算当前帧的物理地址：`next_frame × PAGE_SIZE`
3. 创建 `PhysFrame` 对象
4. 移动 `next_frame` 指针
5. 返回分配的帧

**示例**：
```
第一次调用 allocate()：
next_frame = 525313
物理地址 = 525313 × 4096 = 0x80401000
返回：PhysFrame(0x80401000)
next_frame 变为 525314

第二次调用 allocate()：
next_frame = 525314
物理地址 = 525314 × 4096 = 0x80402000
返回：PhysFrame(0x80402000)
next_frame 变为 525315
```

### 5.4 实现释放方法（占位符）

```rust
impl SimpleFrameAllocator {
    /// 释放一个物理帧（当前实现为空，可扩展）
    pub fn deallocate(&mut self, _frame: PhysFrame) {
        // TODO: 实现帧回收
        // 可以使用位图或链表来跟踪空闲帧
    }
}
```

**说明**：
- 当前是简单的线性分配器，不支持回收
- 实际系统中可以用位图（Bitmap）或空闲链表来实现回收

---

## 6. 代码实现：步骤4 - 封装内存管理器

### 6.1 创建内存管理器

```rust
/// 内存管理器
pub struct MemoryManager {
    pub frame_allocator: SimpleFrameAllocator,
}

impl MemoryManager {
    /// 初始化内存管理器
    pub fn new(kernel_end: usize, memory_end: usize) -> Self {
        MemoryManager {
            frame_allocator: SimpleFrameAllocator::new(kernel_end, memory_end),
        }
    }
}
```

**设计考虑**：
- `MemoryManager` 是顶层接口，封装所有内存管理功能
- 目前只包含 `frame_allocator`，后续可以添加其他管理器

### 6.2 实现初始化函数

```rust
/// 初始化内存管理
///
/// # 功能
/// - 初始化物理帧分配器
/// - 设置虚拟内存映射（后续章节）
///
/// # 参数
/// - `kernel_end`: 内核结束地址
pub fn init(kernel_end: usize) -> MemoryManager {
    // QEMU virt 机器的物理内存：0x80000000 - 0x88000000（128MB）
    const MEMORY_START: usize = 0x8000_0000;
    const MEMORY_SIZE: usize = 128 * 1024 * 1024; // 128 MB
    let memory_end = MEMORY_START + MEMORY_SIZE;

    crate::serial_println!("[MEMORY] Initializing memory management");
    crate::serial_println!("[MEMORY] Kernel end: {:#x}", kernel_end);
    crate::serial_println!("[MEMORY] Memory range: {:#x} - {:#x}", MEMORY_START, memory_end);

    MemoryManager::new(kernel_end, memory_end)
}
```

**QEMU virt 机器内存布局**：
```
0x80000000 - 0x88000000（128 MB）
├─ 0x80000000: 内核代码起始
├─ kernel_end: 内核代码结束
├─ 可分配区域（约 124 MB）
└─ 0x88000000: 物理内存结束
```

---

## 7. 代码实现：步骤5 - 修改堆分配器

现在我们有了物理帧分配器，需要修改 `allocator.rs` 中的 `init_heap`，使其使用物理帧分配器。

### 7.1 理解需求

**原来的 `init_heap_simple`**：
```rust
pub fn init_heap_simple(kernel_end_addr: usize) -> Result<(), &'static str> {
    let heap_start = align_up(kernel_end_addr, 4096);
    // 直接使用物理内存，没有分配机制
    unsafe {
        ALLOCATOR.lock().init(heap_start, HEAP_SIZE);
    }
    Ok(())
}
```

**新的 `init_heap` 需要**：
1. 计算堆需要的页数
2. 通过物理帧分配器分配物理帧
3. 初始化堆分配器

### 7.2 实现 init_heap

在 `src/allocator.rs` 中添加或修改：

```rust
/// 初始化堆分配器（使用物理帧分配器）
///
/// # 功能
/// - 计算堆需要的页数
/// - 通过物理帧分配器分配物理帧
/// - 初始化全局分配器
///
/// # 参数
/// - `frame_allocator`: 物理帧分配器
pub fn init_heap(
    frame_allocator: &mut crate::memory::SimpleFrameAllocator,
) -> Result<(), &'static str> {
    use crate::{serial_println, memory::PAGE_SIZE};

    serial_println!("[ALLOCATOR] Initializing heap at {:#x}", HEAP_START);
    serial_println!("[ALLOCATOR] Heap size: {} bytes", HEAP_SIZE);

    // 计算需要的页数
    let page_count = (HEAP_SIZE + PAGE_SIZE - 1) / PAGE_SIZE;
    serial_println!("[ALLOCATOR] Allocating {} pages for heap", page_count);

    // 分配物理帧
    for _i in 0..page_count {
        let _frame = frame_allocator
            .allocate()
            .ok_or("Failed to allocate frame for heap")?;
    }

    // 初始化分配器
    unsafe {
        ALLOCATOR.lock().init(HEAP_START, HEAP_SIZE);
    }

    serial_println!("[ALLOCATOR] Heap initialized successfully");
    Ok(())
}
```

**代码解析**：

```
假设 HEAP_SIZE = 1 MB = 1048576 字节

计算页数：
page_count = (1048576 + 4096 - 1) / 4096
           = 1052671 / 4096
           = 256 页

分配过程：
循环 256 次，每次调用 frame_allocator.allocate()
- 第1次：分配帧 @ 0x80401000
- 第2次：分配帧 @ 0x80402000
- ...
- 第256次：分配帧 @ 0x80500000

最终：堆占用 256 个物理页帧，共 1 MB
```

### 7.3 为什么要预先分配物理帧？

**问题**：堆分配器在 `0x80400000` 初始化，但物理内存可能没有准备好？

**答案**：
- 在**物理内存管理阶段**（os），预分配确保物理内存可用
- 在**虚拟内存管理阶段**（os_new），预分配的物理帧会被映射到虚拟地址

**当前阶段**：
```
虚拟地址空间（尚未启用）    物理内存空间
                          ┌────────────┐
                          │ 内核代码    │ 0x80000000
                          ├────────────┤
                          │ 堆（1MB）   │ 0x80400000 ← 预分配256个帧
                          ├────────────┤
                          │ 可用内存    │
                          └────────────┘ 0x88000000
```

**下一阶段（虚拟内存）**：
```
虚拟地址空间              物理内存空间
┌────────────┐            ┌────────────┐
│ 堆（1MB）   │            │ 物理帧1     │
│ 0x80400000 │ ─映射─>     │ 物理帧2     │
│            │            │ ...        │
└────────────┘            └────────────┘
```

---

## 8. 代码实现：步骤6 - 集成到系统

### 8.1 在 lib.rs 中声明模块

打开 `src/lib.rs`，在模块声明中添加：

```rust
// src/lib.rs

pub mod serial;
pub mod console;
pub mod interrupts;
pub mod memory;      // 新增
pub mod allocator;
pub mod task;
```

### 8.2 在 main.rs 中使用

打开 `src/main.rs`，修改 `kernel_main` 函数：

**原来的代码**：
```rust
pub extern "C" fn kernel_main() -> ! {
    use os::allocator;

    println!("Welcome to Error OS!");

    extern "C" {
        static kernel_end: u8;
    }
    let kernel_end_addr = unsafe { &kernel_end as *const u8 as usize };

    // 旧的初始化方式
    allocator::init_heap_simple(kernel_end_addr)
        .expect("heap initialization failed");

    // ... 后续代码
}
```

**修改为**：
```rust
pub extern "C" fn kernel_main() -> ! {
    use os::memory;
    use os::allocator;

    println!("Welcome to Error OS!");

    extern "C" {
        static kernel_end: u8;
    }
    let kernel_end_addr = unsafe { &kernel_end as *const u8 as usize };

    // 1. 初始化内存管理（包含物理帧分配器）
    let mut memory_manager = memory::init(kernel_end_addr);

    // 2. 使用物理帧分配器初始化堆
    allocator::init_heap(&mut memory_manager.frame_allocator)
        .expect("heap initialization failed");

    // 测试堆分配
    let heap_value = Box::new(41);
    println!("Heap test: {:?}", heap_value);

    let mut vec = Vec::new();
    for i in 0..100 {
        vec.push(i);
    }
    println!("Vec test passed, length: {}", vec.len());

    // ... 后续代码
}
```

## 10. 编译和测试

### 10.1 编译项目

```bash
cargo build --target riscv64gc-unknown-none-elf
```

### 10.2 运行项目

```bash
qemu-system-riscv64 \
    -machine virt \
    -nographic \
    -bios none \
    -kernel target/riscv64gc-unknown-none-elf/debug/os
```

### 10.3 预期输出

```
Welcome to Error OS!
[MEMORY] Initializing memory management
[MEMORY] Kernel end: 0x80400abc
[MEMORY] Memory range: 0x80000000 - 0x88000000
[MEMORY] Frame allocator initialized: 0x80401000 - 0x88000000
[ALLOCATOR] Initializing heap at 0x80400000
[ALLOCATOR] Heap size: 1048576 bytes
[ALLOCATOR] Allocating 256 pages for heap
[ALLOCATOR] Heap initialized successfully
Heap test: 41
Vec test passed, length: 100
```

**输出解析**：
- `Kernel end: 0x80400abc`：内核代码结束地址
- `Frame allocator initialized: 0x80401000 - 0x88000000`：可分配区域
- `Allocating 256 pages for heap`：为堆分配了 256 个物理帧
- `Heap test` 和 `Vec test`：堆分配功能正常

---

## 11. 深入理解：物理帧分配的意义

### 11.1 对比：修改前后的区别

**修改前（init_heap_simple）**：
```
内存使用方式：
┌────────┬─────────────────────┐
│ 内核    │  直接使用物理内存      │
└────────┴─────────────────────┘
         ↑
       直接初始化堆，没有管理机制
```

**修改后（init_heap）**：
```
内存管理层次：
┌─────────────────────────────────────┐
│       堆分配器（用户可见）             │
├─────────────────────────────────────┤
│    物理帧分配器（内核管理）             │
├─────────────────────────────────────┤
│       物理内存（硬件）                 │
└─────────────────────────────────────┘
```

### 11.2 为虚拟内存做准备

有了物理帧分配器，我们可以：



**1. 分配页表**（下一章）：
```rust
// 分配根页表
let root_table_frame = frame_allocator.allocate()?;
let root_table_addr = root_table_frame.start_address();

// 分配二级页表
let l1_table_frame = frame_allocator.allocate()?;
```

**2. 按需分配物理内存**：
```rust
// 只在需要时分配物理帧
for page in virtual_pages {
    let frame = frame_allocator.allocate()?;
    map_page(page, frame);  // 建立映射
}
```

**3. 实现地址空间隔离**：
```rust
// 为每个进程分配独立的物理帧
let process_a_frames = allocate_frames_for_process(&mut allocator, 100);
let process_b_frames = allocate_frames_for_process(&mut allocator, 100);
```

### 11.3 内存分配的层次结构

```
用户程序
    │
    │ Box::new(), Vec::push()
    ↓
全局堆分配器（FixedSizeBlockAllocator）
    │
    │ 管理 1 MB 堆空间
    ↓
物理帧分配器（SimpleFrameAllocator）
    │
    │ 分配 4 KB 物理帧
    ↓
物理内存（128 MB）
```

---

## 12. 练习和思考

### 12.1 练习题

**练习1**：计算物理帧编号
```
已知：物理地址 = 0x80405678
求：帧编号 = ?

提示：帧编号 = 地址 / PAGE_SIZE
```

<details>
<summary>答案</summary>

```
帧编号 = 0x80405678 / 4096
       = 2148847224 / 4096
       = 524421

验证：
524421 × 4096 = 0x80405000（帧起始地址）
```
</details>

**练习2**：计算堆需要的页数
```
已知：HEAP_SIZE = 2 MB
求：需要多少个物理帧？
```

<details>
<summary>答案</summary>

```
page_count = (2 × 1024 × 1024 + 4096 - 1) / 4096
           = 2097151 / 4096
           = 512 页
```
</details>

### 12.2 思考题

1. **为什么使用线性分配而不是更复杂的算法？**
   - 提示：考虑实现复杂度和使用场景

2. **如何实现 `deallocate()` 方法？**
   - 提示：可以使用位图或链表

3. **如果物理内存不足会发生什么？**
   - 提示：`allocate()` 返回 `None`

---

## 13. 总结

本章我们实现了物理帧分配器，为虚拟内存管理奠定了基础。

### 13.1 核心概念

| 概念 | 说明 |
|------|------|
| **物理帧（PhysFrame）** | 4 KB 对齐的物理内存块 |
| **帧编号** | 物理帧的索引，从 0 开始 |
| **物理帧分配器** | 管理物理帧的分配和释放 |
| **线性分配策略** | 顺序分配，简单高效 |

### 13.2 实现的功能

✅ **PhysAddr** 和 **PhysFrame** 类型
✅ **SimpleFrameAllocator** 物理帧分配器
✅ **MemoryManager** 内存管理器封装
✅ **init_heap** 使用物理帧分配器初始化堆

### 13.3 下一步

在下一章《从物理内存到虚拟内存的代码实现》中，我们将：
1. 实现虚拟地址类型
2. 实现三级页表遍历
3. 实现页面映射函数
4. 创建内核地址空间
5. 激活虚拟内存

有了物理帧分配器，我们已经准备好进入虚拟内存的世界！

---

## 附录：完整代码清单

### A.1 src/memory/mod.rs

```rust
// src/memory/mod.rs

pub const PAGE_SIZE: usize = 4096;

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
#[repr(transparent)]
pub struct PhysAddr(usize);

impl PhysAddr {
    pub const fn new(addr: usize) -> Self {
        PhysAddr(addr)
    }

    pub const fn as_usize(self) -> usize {
        self.0
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct PhysFrame {
    start_address: PhysAddr,
}

impl PhysFrame {
    pub fn containing_address(addr: PhysAddr) -> Self {
        PhysFrame {
            start_address: PhysAddr::new(addr.as_usize() & !0xFFF),
        }
    }

    pub fn start_address(self) -> PhysAddr {
        self.start_address
    }
}

pub struct SimpleFrameAllocator {
    next_frame: usize,
    end_frame: usize,
}

impl SimpleFrameAllocator {
    pub fn new(kernel_end: usize, memory_end: usize) -> Self {
        let next_frame = (kernel_end + PAGE_SIZE - 1) / PAGE_SIZE;
        let end_frame = memory_end / PAGE_SIZE;

        crate::serial_println!(
            "[MEMORY] Frame allocator initialized: {:#x} - {:#x}",
            next_frame * PAGE_SIZE,
            end_frame * PAGE_SIZE
        );

        SimpleFrameAllocator {
            next_frame,
            end_frame,
        }
    }

    pub fn allocate(&mut self) -> Option<PhysFrame> {
        if self.next_frame >= self.end_frame {
            return None;
        }

        let frame = PhysFrame::containing_address(PhysAddr::new(
            self.next_frame * PAGE_SIZE,
        ));
        self.next_frame += 1;

        Some(frame)
    }

    pub fn deallocate(&mut self, _frame: PhysFrame) {
        // TODO: 实现帧回收
    }
}

pub struct MemoryManager {
    pub frame_allocator: SimpleFrameAllocator,
}

impl MemoryManager {
    pub fn new(kernel_end: usize, memory_end: usize) -> Self {
        MemoryManager {
            frame_allocator: SimpleFrameAllocator::new(kernel_end, memory_end),
        }
    }
}

pub fn init(kernel_end: usize) -> MemoryManager {
    const MEMORY_START: usize = 0x8000_0000;
    const MEMORY_SIZE: usize = 128 * 1024 * 1024; // 128 MB
    let memory_end = MEMORY_START + MEMORY_SIZE;

    crate::serial_println!("[MEMORY] Initializing memory management");
    crate::serial_println!("[MEMORY] Kernel end: {:#x}", kernel_end);
    crate::serial_println!("[MEMORY] Memory range: {:#x} - {:#x}", MEMORY_START, memory_end);

    MemoryManager::new(kernel_end, memory_end)
}
```

### A.2 src/allocator.rs 修改部分

```rust
// 在 src/allocator.rs 中添加

pub fn init_heap(
    frame_allocator: &mut crate::memory::SimpleFrameAllocator,
) -> Result<(), &'static str> {
    use crate::{serial_println, memory::PAGE_SIZE};

    serial_println!("[ALLOCATOR] Initializing heap at {:#x}", HEAP_START);
    serial_println!("[ALLOCATOR] Heap size: {} bytes", HEAP_SIZE);

    let page_count = (HEAP_SIZE + PAGE_SIZE - 1) / PAGE_SIZE;
    serial_println!("[ALLOCATOR] Allocating {} pages for heap", page_count);

    for _i in 0..page_count {
        let _frame = frame_allocator
            .allocate()
            .ok_or("Failed to allocate frame for heap")?;
    }

    unsafe {
        ALLOCATOR.lock().init(HEAP_START, HEAP_SIZE);
    }

    serial_println!("[ALLOCATOR] Heap initialized successfully");
    Ok(())
}
```

### A.3 src/main.rs 修改部分

```rust
// 在 kernel_main 函数中

use os::memory;
use os::allocator;

extern "C" {
    static kernel_end: u8;
}
let kernel_end_addr = unsafe { &kernel_end as *const u8 as usize };

// 初始化内存管理
let mut memory_manager = memory::init(kernel_end_addr);

// 初始化堆分配器
allocator::init_heap(&mut memory_manager.frame_allocator)
    .expect("heap initialization failed");
```

