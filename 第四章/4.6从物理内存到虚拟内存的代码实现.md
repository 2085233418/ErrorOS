# 4.4：从物理内存管理到虚拟内存管理的代码实现

## 引言

在前面的章节中，我们理解了：
- **第1章**：为什么需要虚拟内存（解决隔离和碎片问题）
- **第2章**：物理帧分配器的实现（基础设施）
- **第3章**：三级页表的工作原理（理论基础）

现在，我们将在前3章的基础上，通过编写一个**页表测试函数**来驱动虚拟内存功能的实现。我们将从 `main.rs` 开始，按照实际使用需求，逐步构建所需的类型和函数。

## 前置要求

⚠️ **重要**：在开始本章之前，你必须完成**第2章：物理帧分配器的实现**，确保已经实现：
- ✅ `PhysAddr` 和 `PhysFrame` 类型
- ✅ `SimpleFrameAllocator` 物理帧分配器
- ✅ `MemoryManager` 内存管理器
- ✅ `memory::init()` 初始化函数
- ✅ `allocator::init_heap()` 堆分配器升级

---

## 实现思路：从使用到定义

本章采用**需求驱动**的教学方式：

1. **从 main.rs 开始**：编写页表测试函数，定义我们需要什么功能
2. **遇到缺少的类型/函数**：去 memory 模块实现它
3. **返回 main.rs**：继续编写测试代码
4. **循环往复**：直到完成所有功能



---

## 步骤1：在 main.rs 中创建测试函数框架

打开 `src/main.rs`，在 `kernel_main` 函数中添加测试函数调用：

### 1.1 在 kernel_main 中调用测试函数

找到 `kernel_main` 函数，在堆分配器初始化后添加：

```rust
pub extern "C" fn kernel_main() -> ! {
    use os::memory;
    use os::allocator;

    println!("Welcome to Error OS!");

    extern "C" {
        static kernel_end: u8;
    }
    let kernel_end_addr = unsafe { &kernel_end as *const u8 as usize };

    // 初始化内存管理
    let mut memory_manager = memory::init(kernel_end_addr);

    // 初始化堆分配器
    allocator::init_heap(&mut memory_manager.frame_allocator)
        .expect("heap initialization failed");

    // 测试堆分配
    let heap_value = Box::new(41);
    println!("Heap test: {:?}", heap_value);

    // ======== 新增：测试页表功能 ========
    test_page_table_features(&mut memory_manager);
    // ===================================

    println!("Kernel execution completed!");
    os::hlt_loop();
}
```

### 1.2 创建测试函数框架

在 `kernel_main` 函数后面添加测试函数：

```rust
/// 测试页表功能
fn test_page_table_features(memory_manager: &mut os::memory::MemoryManager) {
    println!("\n[1] 创建测试页表...");

    // 分配一个物理帧作为页表
    let test_page_table_frame = memory_manager.frame_allocator
        .allocate()
        .expect("Failed to allocate page table");

    // TODO: 将物理帧转换为页表
    // TODO: 创建虚拟地址和物理地址
    // TODO: 调用 map_page 建立映射
    // TODO: 调用 walk_page_table 验证映射

    println!("页表测试完成！");
}
```

**当前进度**：我们有了测试函数框架，但缺少：
- `PageTable` 类型
- `VirtAddr` 和 `PhysAddr` 的虚拟地址（第3章只有物理地址）
- `map_page` 和 `walk_page_table` 函数

---

## 步骤2：实现 PageTable 类型

回到测试函数，我们需要将物理帧转换为页表。这需要 `PageTable` 类型。

### 2.1 test_page_table_features（main.rs）

我们希望在测试函数中这样写：

```rust
// 将物理帧转换为页表指针
let test_page_table = unsafe {
    &mut *(test_page_table_frame.start_address().as_usize() as *mut PageTable)
};
test_page_table.zero();
```



### 2.2 实现 PageTable（memory/mod.rs）

打开 `src/memory/mod.rs`，在文件中添加页表相关的常量和类型。

#### 2.2.1 添加常量

在 `PAGE_SIZE` 常量后面添加：

```rust
/// 页大小（4KB）
pub const PAGE_SIZE: usize = 4096;

/// 页表项数量（新增）
pub const PAGE_TABLE_ENTRIES: usize = 512;
```

**说明**：Sv39 页表包含 512 个条目（2⁹ = 512）

#### 2.2.2 定义页表项

```rust
/// 页表项（64 位）
#[repr(transparent)]
#[derive(Clone, Copy)]
pub struct PageTableEntry {
    entry: usize,
}

impl PageTableEntry {
    /// 创建空的页表项
    pub const fn new() -> Self {
        PageTableEntry { entry: 0 }
    }
}
```

**说明**：
- 页表项是 64 位（8 字节）
- `#[repr(transparent)]`：保证内存布局与 `usize` 一致
- 初始值为 0 表示无效

#### 2.2.3 定义页表

```rust
/// 页表（512 个条目，4KB 对齐）
#[repr(align(4096))]
pub struct PageTable {
    entries: [PageTableEntry; PAGE_TABLE_ENTRIES],
}

impl PageTable {
    /// 创建新的空页表
    pub const fn new() -> Self {
        PageTable {
            entries: [PageTableEntry::new(); PAGE_TABLE_ENTRIES],
        }
    }

    /// 清空页表
    pub fn zero(&mut self) {
        for entry in self.entries.iter_mut() {
            *entry = PageTableEntry::new();
        }
    }
}
```

**关键点**：
- `#[repr(align(4096))]`：页表必须 4 KB 对齐（RISC-V 硬件要求）
- `entries` 数组：512 个条目 × 8 字节 = 4096 字节 = 1 个物理页帧
- `zero()` 方法：将所有页表项清零

### 2.3 为什么使用 unsafe？

回到测试函数中的代码：

```rust
let test_page_table = unsafe {
    &mut *(test_page_table_frame.start_address().as_usize() as *mut PageTable)
};
```

**解释**：
- 我们将物理地址（`usize`）转换为指针（`*mut PageTable`）
- 这个操作是 `unsafe` 的，因为：
  1. Rust 无法验证这个地址是否有效
  2. Rust 无法验证是否有其他引用指向同一内存
  3. 我们需要保证该地址指向的内存已经分配且有效

**但在这里是安全的**：
- 我们刚刚通过 `frame_allocator.allocate()` 分配了这个物理帧
- 物理帧的地址一定是有效的
- 我们是唯一持有这个引用的代码

---

## 步骤3：实现 VirtAddr 类型

继续编写测试函数，我们需要创建虚拟地址和物理地址：

### 3.1 test_page_table_features（main.rs）

```rust
let vaddr = VirtAddr::new(0x1000_0000);  // 虚拟地址
let paddr = PhysAddr::new(0x8100_0000);  // 物理地址
```



### 3.2 VirtAddr（memory/mod.rs）

在 `PhysAddr` 定义之前添加虚拟地址类型：

```rust
/// RISC-V Sv39 虚拟地址
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
#[repr(transparent)]
pub struct VirtAddr(usize);

impl VirtAddr {
    /// 创建新的虚拟地址
    pub const fn new(addr: usize) -> Self {
        VirtAddr(addr)
    }

    /// 获取地址值
    pub const fn as_usize(self) -> usize {
        self.0
    }

    /// 获取可变指针
    pub fn as_mut_ptr<T>(self) -> *mut T {
        self.0 as *mut T
    }
}
```


### 3.3 添加 VPN 提取方法

虚拟地址需要提取三级页表的索引（VPN）和页内偏移：

```rust
impl VirtAddr {
    /// 获取页偏移（低 12 位）
    pub const fn page_offset(self) -> usize {
        self.0 & 0xFFF
    }

    /// 获取 VPN[0]（12-20 位）
    pub const fn vpn0(self) -> usize {
        (self.0 >> 12) & 0x1FF
    }

    /// 获取 VPN[1]（21-29 位）
    pub const fn vpn1(self) -> usize {
        (self.0 >> 21) & 0x1FF
    }

    /// 获取 VPN[2]（30-38 位）
    pub const fn vpn2(self) -> usize {
        (self.0 >> 30) & 0x1FF
    }
}
```

**说明**：
- `page_offset()`：提取低 12 位，用于在 4 KB 页内定位字节
- `vpn0()`、`vpn1()`、`vpn2()`：提取三级页表的索引
- `0x1FF = 0b1_1111_1111`：9 位掩码

**示例**：
```
虚拟地址：0x12345678
VPN[2] = (0x12345678 >> 30) & 0x1FF = 0
VPN[1] = (0x12345678 >> 21) & 0x1FF = 145
VPN[0] = (0x12345678 >> 12) & 0x1FF = 69
Offset = 0x12345678 & 0xFFF = 0x678
```

---

## 步骤4：实现页表标志位

继续测试函数，我们需要设置页表项的标志位：

### 4.1 test_page_table_features（main.rs）

```rust
let flags = PageTableFlags::Read as usize
    | PageTableFlags::Write as usize
    | PageTableFlags::Valid as usize;
```


### 4.2 PageTableFlags（memory/mod.rs）

在 `PageTableEntry` 定义之前添加：

```rust
/// 页表项标志位
#[repr(u64)]
#[derive(Debug, Clone, Copy)]
pub enum PageTableFlags {
    Valid = 1 << 0,      // V: 有效位
    Read = 1 << 1,       // R: 可读
    Write = 1 << 2,      // W: 可写
    Execute = 1 << 3,    // X: 可执行
    User = 1 << 4,       // U: 用户可访问
    Global = 1 << 5,     // G: 全局映射
    Accessed = 1 << 6,   // A: 访问位
    Dirty = 1 << 7,      // D: 脏位
}
```

**说明**：
- 这些标志位对应 RISC-V Sv39 页表项的低 8 位
- 可以通过按位或（`|`）组合多个标志

**常见组合**：
```rust
// 代码段：可读、可执行，不可写
PageTableFlags::Read | PageTableFlags::Execute

// 数据段：可读、可写，不可执行
PageTableFlags::Read | PageTableFlags::Write
```

---

## 步骤5：实现 map_page 函数

现在我们要调用 `map_page` 来建立虚拟地址到物理地址的映射：

### 5.1 test_page_table_features（main.rs）

```rust
use os::memory::map_page;

match map_page(
    test_page_table,
    vaddr,
    paddr,
    flags,
    &mut memory_manager.frame_allocator
) {
    Ok(_) => println!("✓ 页面映射成功"),
    Err(e) => println!("✗ 页面映射失败: {}", e),
}
```

**问题**：
- `map_page` 函数不存在
- 需要在 `memory/paging.rs` 中实现

### 5.2 创建 paging.rs 文件

创建 `src/memory/paging.rs` 文件。

#### 5.2.1 添加模块声明

在 `src/memory/mod.rs` 文件开头添加：

```rust
pub mod paging;
```

#### 5.2.2 导入必要类型

在 `src/memory/paging.rs` 中添加：

```rust
use super::{
    PhysAddr, VirtAddr, PageTable, PageTableEntry,
    PageTableFlags, PhysFrame, SimpleFrameAllocator, PAGE_SIZE
};
```

### 5.3 实现 PageTableEntry 的核心方法

在实现 `map_page` 之前，我们需要给 `PageTableEntry` 添加一些方法。

回到 `src/memory/mod.rs`，在 `PageTableEntry` 的 `impl` 块中添加：

```rust
impl PageTableEntry {
    /// 创建空的页表项
    pub const fn new() -> Self {
        PageTableEntry { entry: 0 }
    }

    /// 判断是否有效
    pub fn is_valid(&self) -> bool {
        (self.entry & 1) != 0
    }

    /// 判断是否为叶子节点（映射到物理页）
    pub fn is_leaf(&self) -> bool {
        (self.entry & 0xE) != 0 // R/W/X 任意一位为 1
    }

    /// 获取物理页号（PPN）
    pub fn ppn(&self) -> usize {
        (self.entry >> 10) & 0xFFF_FFFF_FFFF
    }

    /// 获取物理地址
    pub fn phys_addr(&self) -> PhysAddr {
        PhysAddr::new(self.ppn() << 12)
    }

    /// 设置页表项
    pub fn set(&mut self, ppn: usize, flags: usize) {
        self.entry = (ppn << 10) | flags;
    }
}
```

**关键方法**：
- `is_valid()`：检查 V 位（第 0 位）
- `is_leaf()`：检查 R/W/X 位，任意一位为 1 表示叶子节点
- `ppn()`：提取 44 位物理页号（第 10-53 位）
- `phys_addr()`：将 PPN 左移 12 位得到物理地址
- `set()`：设置页表项

**页表项结构**：
```
64 位页表项：
┌───────────┬──────────────────────────┬────┬──────────────────┐
│  保留位    │  物理页号（PPN）           │RSW │   标志位          │
│ (10 bits) │    (44 bits)             │(2) │  (8 bits)        │
└───────────┴──────────────────────────┴────┴──────────────────┘
 63       54 53                      10 9  8  7 6 5 4 3 2 1 0
                                              D A G U X W R V
```

### 5.4 添加 PageTable 的访问方法

在 `src/memory/mod.rs` 的 `PageTable` 实现中添加：

```rust
impl PageTable {
    /// 创建新的空页表
    pub const fn new() -> Self {
        PageTable {
            entries: [PageTableEntry::new(); PAGE_TABLE_ENTRIES],
        }
    }

    /// 获取页表项
    pub fn get_entry(&self, index: usize) -> &PageTableEntry {
        &self.entries[index]
    }

    /// 获取可变页表项
    pub fn get_entry_mut(&mut self, index: usize) -> &mut PageTableEntry {
        &mut self.entries[index]
    }

    /// 清空页表
    pub fn zero(&mut self) {
        for entry in self.entries.iter_mut() {
            *entry = PageTableEntry::new();
        }
    }
}
```

### 5.5 实现 map_page（memory/paging.rs）

现在回到 `src/memory/paging.rs`，实现 `map_page` 函数：

```rust
/// 映射单个页面
///
/// # 功能
/// 建立虚拟地址到物理地址的映射，自动分配中间页表
///
/// # 参数
/// - `root_table`: 根页表（可变引用）
/// - `vaddr`: 虚拟地址
/// - `paddr`: 物理地址
/// - `flags`: 页表标志位
/// - `allocator`: 帧分配器（用于分配中间页表）
pub fn map_page(
    root_table: &mut PageTable,
    vaddr: VirtAddr,
    paddr: PhysAddr,
    flags: usize,
    allocator: &mut SimpleFrameAllocator,
) -> Result<(), &'static str> {
    // 第1步：获取或创建 Level 1 页表
    let vpn2 = vaddr.vpn2();
    let pte2 = root_table.get_entry_mut(vpn2);

    let table1 = if !pte2.is_valid() {
        // Level 1 页表不存在，需要分配
        let frame = allocator.allocate().ok_or("Out of memory")?;
        let table1_paddr = frame.start_address();

        // 设置页表项：指向下一级页表，只设置 Valid 位
        pte2.set(table1_paddr.as_usize() >> 12, PageTableFlags::Valid as usize);

        // 清空新页表
        let table1 = unsafe {
            &mut *(table1_paddr.as_usize() as *mut PageTable)
        };
        table1.zero();
        table1
    } else {
        // Level 1 页表已存在，直接使用
        unsafe {
            &mut *(pte2.phys_addr().as_usize() as *mut PageTable)
        }
    };

    // 第2步：获取或创建 Level 0 页表
    let vpn1 = vaddr.vpn1();
    let pte1 = table1.get_entry_mut(vpn1);

    let table0 = if !pte1.is_valid() {
        let frame = allocator.allocate().ok_or("Out of memory")?;
        let table0_paddr = frame.start_address();

        pte1.set(table0_paddr.as_usize() >> 12, PageTableFlags::Valid as usize);

        let table0 = unsafe {
            &mut *(table0_paddr.as_usize() as *mut PageTable)
        };
        table0.zero();
        table0
    } else {
        unsafe {
            &mut *(pte1.phys_addr().as_usize() as *mut PageTable)
        }
    };

    // 第3步：设置最终映射
    let vpn0 = vaddr.vpn0();
    let pte0 = table0.get_entry_mut(vpn0);

    if pte0.is_valid() {
        return Err("Page already mapped");
    }

    // 设置叶子页表项：物理地址 + 标志位
    pte0.set(paddr.as_usize() >> 12, flags | PageTableFlags::Valid as usize);

    // 第4步：刷新 TLB
    unsafe {
        core::arch::asm!(
            "sfence.vma {0}, zero",
            in(reg) vaddr.as_usize(),
        );
    }

    Ok(())
}
```

**关键点**：

1. **三级页表遍历**：VPN[2] → VPN[1] → VPN[0]
2. **按需分配**：如果中间页表不存在，自动分配
3. **清空新页表**：避免随机数据导致错误
4. **刷新 TLB**：使用 `sfence.vma` 指令，确保新映射立即生效

**映射过程**：
```
虚拟地址 0x10000000
    ↓
VPN[2]=0 → 根页表[0] → 如果无效，分配 Level 1 页表
    ↓
VPN[1]=256 → Level 1 页表[256] → 如果无效，分配 Level 0 页表
    ↓
VPN[0]=0 → Level 0 页表[0] → 设置映射到物理地址
    ↓
物理地址 = PPN << 12
```

### 5.6 在 mod.rs 中重新导出

在 `src/memory/mod.rs` 文件末尾添加：

```rust
// 重新导出页表管理函数
pub use paging::map_page;
```

---

## 步骤6：实现 walk_page_table 函数

测试函数中，我们需要验证映射是否成功：

### 6.1 test_page_table_features（main.rs）

```rust
use os::memory::walk_page_table;

let root_paddr = test_page_table_frame.start_address();

match walk_page_table(root_paddr, vaddr) {
    Some(result_paddr) => {
        if result_paddr.as_usize() == paddr.as_usize() {
            println!("✓ 地址转换验证成功!");
        }
    }
    None => println!("✗ 页面未映射"),
}
```

**问题**：
- `walk_page_table` 函数不存在

### 6.2 实现 walk_page_table（memory/paging.rs）

在 `src/memory/paging.rs` 中添加：

```rust
/// 遍历页表，将虚拟地址转换为物理地址
///
/// # 功能
/// 执行三级页表遍历，查找虚拟地址对应的物理地址
///
/// # 参数
/// - `root_paddr`: 根页表的物理地址
/// - `vaddr`: 要转换的虚拟地址
///
/// # 返回
/// - Some(PhysAddr): 转换成功，返回物理地址
/// - None: 页面未映射
pub fn walk_page_table(root_paddr: PhysAddr, vaddr: VirtAddr) -> Option<PhysAddr> {
    // 第1步：获取根页表
    let root_table = unsafe {
        &*(root_paddr.as_usize() as *const PageTable)
    };

    // 第2步：Level 2 查找
    let vpn2 = vaddr.vpn2();
    let pte2 = root_table.get_entry(vpn2);

    if !pte2.is_valid() {
        return None;  // 页面未映射
    }

    if pte2.is_leaf() {
        // 1GB 大页
        let offset = vaddr.as_usize() & 0x3FFF_FFFF;
        return Some(PhysAddr::new(pte2.phys_addr().as_usize() + offset));
    }

    // 第3步：Level 1 查找
    let table1 = unsafe {
        &*(pte2.phys_addr().as_usize() as *const PageTable)
    };
    let vpn1 = vaddr.vpn1();
    let pte1 = table1.get_entry(vpn1);

    if !pte1.is_valid() {
        return None;
    }

    if pte1.is_leaf() {
        // 2MB 大页
        let offset = vaddr.as_usize() & 0x1F_FFFF;
        return Some(PhysAddr::new(pte1.phys_addr().as_usize() + offset));
    }

    // 第4步：Level 0 查找
    let table0 = unsafe {
        &*(pte1.phys_addr().as_usize() as *const PageTable)
    };
    let vpn0 = vaddr.vpn0();
    let pte0 = table0.get_entry(vpn0);

    if !pte0.is_valid() {
        return None;
    }

    // 第5步：计算最终物理地址
    let offset = vaddr.page_offset();
    Some(PhysAddr::new(pte0.phys_addr().as_usize() + offset))
}
```

**关键点**：
- 三级遍历：Level 2 → Level 1 → Level 0
- 每级检查有效性和是否为叶子节点（大页）
- 最终物理地址 = 物理页帧起始地址 + 页内偏移
- 支持 1GB、2MB、4KB 三种页大小

### 6.3 在 mod.rs 中重新导出

在 `src/memory/mod.rs` 文件的重新导出部分添加：

```rust
// 重新导出页表管理函数
pub use paging::{map_page, walk_page_table};
```

---

## 步骤7：完整的测试函数

现在我们已经实现了所有需要的功能，可以完成测试函数了：

```rust
/// 测试页表功能
fn test_page_table_features(memory_manager: &mut os::memory::MemoryManager) {
    use os::memory::{VirtAddr, PhysAddr, PageTable, PageTableFlags};
    use os::memory::{map_page, walk_page_table};

    println!("\n========================================");
    println!("  开始测试页表功能");
    println!("========================================\n");

    println!("[1] 创建测试页表...");

    // 分配一个物理帧作为页表
    let test_page_table_frame = memory_manager.frame_allocator
        .allocate()
        .expect("Failed to allocate page table");

    // 将物理帧转换为页表
    let test_page_table = unsafe {
        &mut *(test_page_table_frame.start_address().as_usize() as *mut PageTable)
    };
    test_page_table.zero();

    println!("    ✓ 页表已创建\n");

    // 测试1：映射一个页面
    println!("[2] 测试页面映射...");
    let vaddr = VirtAddr::new(0x1000_0000);  // 虚拟地址
    let paddr = PhysAddr::new(0x8100_0000);  // 物理地址

    let flags = PageTableFlags::Read as usize
        | PageTableFlags::Write as usize
        | PageTableFlags::Valid as usize;

    match map_page(
        test_page_table,
        vaddr,
        paddr,
        flags,
        &mut memory_manager.frame_allocator
    ) {
        Ok(_) => println!("    ✓ 页面映射成功\n"),
        Err(e) => println!("    ✗ 页面映射失败: {}\n", e),
    }

    // 测试2：遍历页表验证映射
    println!("[3] 测试页表遍历...");
    let root_paddr = test_page_table_frame.start_address();

    match walk_page_table(root_paddr, vaddr) {
        Some(result_paddr) => {
            if result_paddr.as_usize() == paddr.as_usize() {
                println!("    ✓ 地址转换验证成功!\n");
            } else {
                println!("    ✗ 地址转换错误\n");
            }
        }
        None => println!("    ✗ 页面未映射\n"),
    }

    // 测试3：映射多个页面
    println!("[4] 映射多个连续页面...");
    for i in 0..3 {
        let v = VirtAddr::new(0x2000_0000 + i * 0x1000);
        let p = PhysAddr::new(0x8200_0000 + i * 0x1000);

        match map_page(
            test_page_table,
            v,
            p,
            flags,
            &mut memory_manager.frame_allocator
        ) {
            Ok(_) => {},
            Err(e) => println!("    ✗ 页面 {} 映射失败: {}", i, e),
        }
    }
    println!("    ✓ 所有页面映射成功\n");

    println!("========================================");
    println!("  页表功能测试完成！");
    println!("========================================\n");
}
```

---



## 步骤9：编译和测试

### 9.1 编译项目

```bash
cargo build --target riscv64gc-unknown-none-elf
```

### 9.2 运行项目

```bash
qemu-system-riscv64 \
    -machine virt \
    -nographic \
    -bios none \
    -kernel target/riscv64gc-unknown-none-elf/debug/os
```

### 9.3 预期输出

```
Welcome to Error OS!
[MEMORY] Initializing memory management
[MEMORY] Kernel end: 0x80XXXXXX
[MEMORY] Memory range: 0x80000000 - 0x88000000
[MEMORY] Frame allocator initialized: 0x80XXXXXX - 0x88000000
[ALLOCATOR] Initializing heap at 0x80400000
[ALLOCATOR] Heap size: 1048576 bytes
[ALLOCATOR] Allocating 256 pages for heap
[ALLOCATOR] Heap initialized successfully
Heap test: 41

========================================
  开始测试页表功能
========================================

[1] 创建测试页表...
    ✓ 页表已创建

[2] 测试页面映射...
    ✓ 页面映射成功

[3] 测试页表遍历...
    ✓ 地址转换验证成功!

[4] 映射多个连续页面...
    ✓ 所有页面映射成功

========================================
  页表功能测试完成！
========================================

Kernel execution completed!
```

---

## 总结

通过本章的学习，我们采用**需求驱动**的方式，从 `main.rs` 的测试函数出发，逐步实现了虚拟内存管理的核心功能。

### 实现路径回顾

```
1. main.rs (test_page_table_features)
   ↓ 需要 PageTable
2. memory/mod.rs (实现 PageTable)
   ↓ 需要 VirtAddr
3. memory/mod.rs (实现 VirtAddr)
   ↓ 需要 PageTableFlags
4. memory/mod.rs (实现 PageTableFlags)
   ↓ 需要 map_page
5. memory/paging.rs (实现 map_page)
   ↓ 需要 walk_page_table
6. memory/paging.rs (实现 walk_page_table)
   ↓ 需要 AddressSpace
7. memory/address_space.rs (实现 AddressSpace)
   ↓
8. 完成！
```

### 核心实现清单

**第3章已完成**：
- ✅ `PhysAddr` 和 `PhysFrame`
- ✅ `SimpleFrameAllocator`
- ✅ `MemoryManager`

**第4章新增**：
- ✅ `VirtAddr` 和 `Page`
- ✅ `PageTableEntry` 和 `PageTable`
- ✅ `PageTableFlags`
- ✅ `map_page()` - 建立映射
- ✅ `walk_page_table()` - 地址转换
- ✅ `AddressSpace` - 地址空间抽象
- ✅ `create_kernel_address_space()` - 内核地址空间

### 核心技术点

1. **三级页表遍历**：VPN[2] → VPN[1] → VPN[0] → 物理地址
2. **按需分配**：映射时自动分配中间页表
3. **TLB 管理**：使用 `sfence.vma` 刷新 TLB
4. **类型安全**：虚拟地址和物理地址使用不同类型
5. **恒等映射**：内核代码段使用恒等映射

### 学习方法优势

采用**需求驱动**的方式学习有以下优势：

1. **符合思维习惯**：从使用者角度出发，更自然
2. **理解依赖关系**：清楚为什么需要每个函数
3. **即时验证**：每实现一个功能就可以测试
4. **目标明确**：知道最终要实现什么功能

恭喜你完成了虚拟内存管理的实现！这是操作系统中最核心的功能之一。
