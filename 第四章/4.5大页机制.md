## 1. 大页机制：更高效的内存映射

### 1.1 什么是大页？

到目前为止，我们讨论的都是 **4 KB 页**，需要**三级查询**才能完成地址转换。但 RISC-V Sv39 还支持**大页**，可以在**中间级别**就停止查询。

**标准页 vs 大页**：

```
标准 4KB 页（三级查询）：
satp → Level 2 → Level 1 → Level 0 → 物理页帧 (4KB)

2MB 大页（二级查询）：
satp → Level 2 → Level 1 → 物理页帧 (2MB)
                           ↑
                      在这里停止！

1GB 大页（一级查询）：
satp → Level 2 → 物理页帧 (1GB)
                 ↑
            在这里停止！
```

### 1.2 大页的判断条件

**如何判断一个 PTE 是否指向大页？**

回顾 PTE 的结构：

```
页表项（64 位）：

63        54 53                      10 9  8  7 6 5 4 3 2 1 0
┌───────────┬──────────────────────────┬────┬──────────────────┐
│  保留位    │  物理页号（PPN）           │RSW │   标志位          │
│ (10 bits) │    (44 bits)             │(2) │  (8 bits)        │
└───────────┴──────────────────────────┴────┴──────────────────┘
                                              D A G U X W R V
```

**判断规则**：

```rust
if PTE.V == 1 && (PTE.R == 1 || PTE.W == 1 || PTE.X == 1) {
    // 这是一个叶子节点（大页或标准页）
    // 从当前 PTE 直接取出物理页号，完成地址转换
} else if PTE.V == 1 {
    // 这是一个指针节点
    // PTE 指向下一级页表，继续查询
} else {
    // 无效页表项
    return None;
}
```

**关键点**：
- **V = 1 且 R/W/X 不全为 0**：这是**叶子节点**，直接映射到物理页帧
- **V = 1 且 R/W/X 全为 0**：这是**指针节点**，指向下一级页表
- **V = 0**：无效页表项

### 1.3 大页的地址转换

**核心思想**：将物理页号和页内偏移"接起来"。

#### 物理地址 = 物理页号 << 12 + 页内偏移

但在大页中，"页内偏移"的位数不同：

```
标准 4KB 页（Level 0）：
┌──────────────┬────────────┐
│ 物理页号 44位 │ 偏移 12位   │
└──────────────┴────────────┘
页大小 = 2^12 = 4KB

2MB 大页（Level 1）：
┌──────────────┬────────────┐
│ 物理页号 44位 │ 偏移 21位   │  ← VPN[0] (9位) + Offset (12位)
└──────────────┴────────────┘
页大小 = 2^21 = 2MB

1GB 大页（Level 2）：
┌──────────────┬────────────┐
│ 物理页号 44位 │ 偏移 30位   │  ← VPN[1] (9位) + VPN[0] (9位) + Offset (12位)
└──────────────┴────────────┘
页大小 = 2^30 = 1GB
```

**关键理解**：
- 在**中途停止**时，**未使用的 VPN 部分**会和**原始页内偏移**一起，形成更大的"大页页内偏移"
- 物理地址 = (物理页号 << 12) + 大页页内偏移

### 1.4 大页地址转换的具体例子

#### 例子 1：2MB 大页

假设我们要访问虚拟地址 `0x0040_1234`，并且 Level 1 页表项是一个大页。

**步骤 1：分解虚拟地址**

```
虚拟地址：0x0040_1234

二进制：
  0000 0000 0100 0000 0001 0010 0011 0100
  └───┬───┘└───┬───┘└───┬───┘└─────┬─────┘
   VPN[2]   VPN[1]   VPN[0]    Offset
     0        2       0x9       0x234
    (0)      (2)      (9)       (564)
```

**步骤 2：查询 Level 2 页表**

```
从 satp 获取根页表地址
   ↓
使用 VPN[2] = 0 查询
   ↓
得到 Level 1 页表地址
```

**步骤 3：查询 Level 1 页表（发现大页）**

```
使用 VPN[1] = 2 查询 Level 1 页表
   ↓
得到 PTE1：
  V = 1, R = 1, W = 1, X = 0  ← R/W/X 不全为 0
  PPN = 0x80100
   ↓
判断：这是一个叶子节点（2MB 大页）！
```

**步骤 4：计算大页页内偏移**

```
2MB 大页的页内偏移 = VPN[0] + Offset
                   = 9 位 + 12 位 = 21 位

具体计算：
VPN[0] = 0x9 (二进制: 000001001)
Offset = 0x234 (二进制: 001000110100)

拼接：
000001001 001000110100
└── 9 ──┘└──── 12 ────┘
= 0b000001001001000110100
= 0x9234
= 37,428 字节
```

**步骤 5：计算最终物理地址**

```
物理地址 = (PPN << 12) + 大页页内偏移
         = (0x80100 << 12) + 0x9234
         = 0x80100000 + 0x9234
         = 0x80109234
```

**完整过程可视化**：

```
虚拟地址：0x0040_1234
┌──────┬──────┬──────┬────────┐
│ VPN2 │ VPN1 │ VPN0 │ Offset │
│  0   │  2   │ 0x9  │ 0x234  │
└──────┴──────┴──────┴────────┘
   ↓      ↓      └───────┬──────┘
   │      │              ↓
   │      │      大页页内偏移 (21位)
   │      │         0x9234
   │      ↓
   │   Level 1 [2]
   │   PTE: PPN=0x80100, R=1,W=1
   │        ↓
   │    发现大页！
   ↓
satp (根页表)

物理地址计算：
= (0x80100 << 12) + 0x9234
= 0x80100000 + 0x9234
= 0x80109234

┌────────────────────────────┐
│   2MB 物理页帧              │
│   起始地址: 0x80100000      │
│   +0x0000: [数据]           │
│   ...                      │
│   +0x9234: [目标数据] ◄─────┼─ 这里！
│   ...                      │
│   +0x1FFFFF: [数据]         │
│   (2MB = 0x200000)         │
└────────────────────────────┘
```

#### 例子 2：1GB 大页

假设访问虚拟地址 `0x8020_0400`，Level 2 页表项是 1GB 大页。

**步骤 1：分解虚拟地址**

```
虚拟地址：0x8020_0400

二进制：
  1000 0000 0010 0000 0000 0100 0000 0000
  └───┬───┘└───┬───┘└───┬───┘└─────┬─────┘
   VPN[2]   VPN[1]   VPN[0]    Offset
     4       0x10       0       0x400
    (4)      (16)      (0)      (1024)
```

**步骤 2：查询 Level 2 页表（发现大页）**

```
从 satp 获取根页表地址
   ↓
使用 VPN[2] = 4 查询
   ↓
得到 PTE2：
  V = 1, R = 1, W = 1, X = 1  ← R/W/X 不全为 0
  PPN = 0x80000
   ↓
判断：这是一个叶子节点（1GB 大页）！
```

**步骤 3：计算大页页内偏移**

```
1GB 大页的页内偏移 = VPN[1] + VPN[0] + Offset
                   = 9 位 + 9 位 + 12 位 = 30 位

具体计算：
VPN[1] = 0x10  (二进制: 000010000)
VPN[0] = 0x0   (二进制: 000000000)
Offset = 0x400 (二进制: 010000000000)

拼接：
000010000 000000000 010000000000
└── 9 ──┘└── 9 ──┘└──── 12 ────┘
= 0b000010000000000000010000000000
= 0x2000400
= 33,555,456 字节
```

**步骤 4：计算最终物理地址**

```
物理地址 = (PPN << 12) + 大页页内偏移
         = (0x80000 << 12) + 0x2000400
         = 0x80000000 + 0x2000400
         = 0x82000400
```

### 1.5 大页的优势

**1. 减少页表层级，节省内存访问**

```
标准 4KB 页：3 次页表查询
2MB 大页：   2 次页表查询（减少 33%）
1GB 大页：   1 次页表查询（减少 66%）
```

**2. 减少页表项数量，节省内存**

```
映射 1GB 内存需要的页表项：

使用 4KB 页：
= 1GB / 4KB = 262,144 个页表项

使用 2MB 大页：
= 1GB / 2MB = 512 个页表项（减少 512 倍！）

使用 1GB 大页：
= 1GB / 1GB = 1 个页表项（减少 262,144 倍！）
```

**3. 显著提升 TLB 命中率**

```
TLB 容量：64 项

使用 4KB 页：
64 项 × 4KB = 256 KB 覆盖范围

使用 2MB 大页：
64 项 × 2MB = 128 MB 覆盖范围（提升 512 倍！）

使用 1GB 大页：
64 项 × 1GB = 64 GB 覆盖范围（提升 262,144 倍！）
```

**实际场景**：
- **内核代码段**：几 MB 到几十 MB，权限相同（RX），适合用 2MB 大页
- **大型数据库缓存**：几 GB，权限相同（RW），适合用 1GB 大页
- **应用程序堆栈**：权限频繁变化，适合用 4KB 标准页

### 1.6 大页的代码体现

在我们的 `walk_page_table` 函数中，已经实现了大页的支持：

```rust
pub fn walk_page_table(root_paddr: PhysAddr, vaddr: VirtAddr) -> Option<PhysAddr> {
    let root_table = unsafe { &*(root_paddr.as_usize() as *const PageTable) };

    // Level 2 查找
    let vpn2 = vaddr.vpn2();
    let pte2 = root_table.get_entry(vpn2);

    if !pte2.is_valid() {
        return None;
    }

    // ⚠️ 检查是否为 1GB 大页
    if pte2.is_leaf() {  // R/W/X 不全为 0
        // 1GB 大页：偏移 = VPN[1] (9位) + VPN[0] (9位) + Offset (12位) = 30位
        let offset = vaddr.as_usize() & 0x3FFF_FFFF;  // 30位掩码
        return Some(PhysAddr::new(pte2.phys_addr().as_usize() + offset));
    }

    // Level 1 查找
    let table1 = unsafe { &*(pte2.phys_addr().as_usize() as *const PageTable) };
    let vpn1 = vaddr.vpn1();
    let pte1 = table1.get_entry(vpn1);

    if !pte1.is_valid() {
        return None;
    }

    // ⚠️ 检查是否为 2MB 大页
    if pte1.is_leaf() {  // R/W/X 不全为 0
        // 2MB 大页：偏移 = VPN[0] (9位) + Offset (12位) = 21位
        let offset = vaddr.as_usize() & 0x1F_FFFF;  // 21位掩码
        return Some(PhysAddr::new(pte1.phys_addr().as_usize() + offset));
    }

    // Level 0 查找（标准 4KB 页）
    let table0 = unsafe { &*(pte1.phys_addr().as_usize() as *const PageTable) };
    let vpn0 = vaddr.vpn0();
    let pte0 = table0.get_entry(vpn0);

    if !pte0.is_valid() {
        return None;
    }

    // 4KB 页：偏移 = Offset (12位)
    let offset = vaddr.page_offset();  // 12位
    Some(PhysAddr::new(pte0.phys_addr().as_usize() + offset))
}
```

### 1.7 大页机制总结

```
Sv39 支持的三种页大小：

┌─────────┬────────┬──────────┬────────────────┬──────────────┐
│ 页大小   │ 停止层级│ 页内偏移  │    覆盖能力     │   适用场景    │
├─────────┼────────┼──────────┼────────────────┼──────────────┤
│  4 KB   │ Level 0│  12 位   │   4,096 字节    │ 通用映射     │
│  2 MB   │ Level 1│  21 位   │  2,097,152 字节 │ 大块数据     │
│  1 GB   │ Level 2│  30 位   │1,073,741,824字节│ 巨大连续区域 │
└─────────┴────────┴──────────┴────────────────┴──────────────┘

判断条件：
PTE.V = 1 且 (PTE.R = 1 或 PTE.W = 1 或 PTE.X = 1)
  ↓
这是叶子节点，停止查询，使用大页机制

地址转换：
物理地址 = (PPN << 12) + 大页页内偏移
         = 物理页帧起始地址 + (未使用的VPN + Offset)

核心优势：
✓ 减少页表层级（1-2 次内存访问）
✓ 减少页表项数量（节省内存）
✓ 提升 TLB 命中率（覆盖更大范围）
✓ 整体提升访存性能
```

---

## 2. 完整的地址转换总结

### 2.1 标准地址转换（4KB 页）

```
虚拟地址 (39位)
┌──────┬──────┬──────┬────────┐
│ VPN2 │ VPN1 │ VPN0 │ Offset │
│ 9位  │ 9位  │ 9位  │  12位  │
└──────┴──────┴──────┴────────┘
   ↓      ↓      ↓       ↓
satp → L2 → L1 → L0 → 物理页帧
                        + Offset
                          ↓
                      物理地址 (56位)

TLB 加速：
- 首次访问：3 次内存访问
- 后续访问：0 次内存访问（TLB 命中）
```

### 2.2 大页地址转换（2MB/1GB）

```
2MB 大页：
┌──────┬──────┬────────────────┐
│ VPN2 │ VPN1 │  VPN0 + Offset │
│ 9位  │ 9位  │     21位        │
└──────┴──────┴────────────────┘
   ↓      ↓           ↓
satp → L2 → L1(叶子)  → 物理页帧 (2MB)
                        + 大页偏移 (21位)
                          ↓
                      物理地址

1GB 大页：
┌──────┬────────────────────────┐
│ VPN2 │  VPN1 + VPN0 + Offset  │
│ 9位  │        30位             │
└──────┴────────────────────────┘
   ↓              ↓
satp → L2(叶子) → 物理页帧 (1GB)
                  + 大页偏移 (30位)
                    ↓
                物理地址
```

### 2.3 完整的性能优化策略

```
第一层优化：三级页表
✓ 解决空间浪费（1GB → ~100KB）
✗ 引入性能开销（3 次内存访问）

第二层优化：TLB
✓ 缓存最近转换（4 次 → 1 次访问）
✓ 利用程序局部性
✗ 容量有限（32-128 项）

第三层优化：大页
✓ 减少页表层级（3次 → 1-2次）
✓ 提升 TLB 覆盖率（256KB → 128MB）
✓ 节省页表内存（262144项 → 512项）
✗ 需要大块连续内存

综合效果：
相比线性映射（1GB）+ 直接访问（1次）：
- 空间开销：降低 99.99%（1GB → 100KB）
- 时间开销：接近零（TLB 命中率 >95%）
```

恭喜你完成了虚拟内存映射机制的完整学习！你现在理解了：
- 三级页表如何工作
- TLB 如何加速地址转换
- 大页如何进一步提升性能
- 完整的 RISC-V Sv39 分页机制

