# 4.1：为什么需要虚拟内存

## 引言

在之前的内核代码实现中，我们采用的是**直接物理内存管理**的方式：内核代码、应用程序以及各种数据结构都直接放置在同一个物理地址空间中。这种简单的内存管理方式存在严重的问题：

**当前的内存布局**：
```
物理内存（0x80000000 - 0x88000000）：
┌──────────┬──────────┬──────────┬──────────┐
│ 内核代码   │ 应用程序A │ 应用程序B │   空闲    │
└──────────┴──────────┴──────────┴──────────┘
```
---

## 1. 物理内存管理的局限性

### 1.1 内存碎片化

```
初始状态（128 MB 物理内存）：
┌────────────────────────────────────┐
│          128 MB 空闲                │  0x80000000 - 0x88000000
└────────────────────────────────────┘

加载程序 A（32 MB）：
┌──────────┬─────────────────────────┐
│   A      │    96 MB 空闲            │
└──────────┴─────────────────────────┘
0x80000000  0x82000000

加载程序 B（32 MB）：
┌──────────┬──────────┬──────────────┐
│   A      │    B     │  64 MB 空闲   │
└──────────┴──────────┴──────────────┘
           0x82000000  0x84000000

卸载程序 A：
┌──────────┬──────────┬──────────────┐
│  空闲     │    B     │  64 MB 空闲  │  ← 碎片产生！
└──────────┴──────────┴──────────────┘

尝试加载程序 C（84 MB）：
❌ 失败！虽然总共有 96 MB 空闲（32+64），
   但不连续，无法分配 84 MB 连续空间
```

**问题**：频繁加载和卸载程序后，内存变得支离破碎，大块连续空间越来越少。

### 1.2 进程隔离困难

程序 A 和程序 B 同时运行：

```
物理内存布局：
┌──────────┬──────────┬──────────────┐
│   A      │    B     │    空闲       │
└──────────┴──────────┴──────────────┘
0x80000000  0x82000000
```

程序 A 的代码：
```rust
let data = 0x82000000 as *mut u32;  // 错误地访问了程序 B 的内存
unsafe { *data = 0xDEADBEEF; }      // 破坏了程序 B 的数据！
```

❌ 程序 A 可以随意访问程序 B 的内存
❌ 一个程序的 bug 可以破坏其他程序
❌ 恶意程序可以窃取其他程序的数据

## 2. 虚拟内存的优势

虚拟内存通过在**虚拟地址**和**物理地址**之间建立映射，优雅地解决了上述所有问题。

### 2.1 解决内存碎片

使用虚拟内存后：

```
程序 C 的虚拟地址空间（连续）：
┌────────────────────────────────────┐
│   程序 C （64 MB，连续虚拟地址）       │
└────────────────────────────────────┘
0x00000000 - 0x04000000

映射到物理内存（可以不连续）：
物理内存：
┌──────────┬──────────┬──────────────┐
│  32 MB   │    B     │   32 MB      │
│  ↑       │          │   ↑          │
└──┼───────┴──────────┴───┼──────────┘
   └─────────┬─────────────┘
           映射关系

虚拟地址 0x00000000-0x02000000 → 物理地址 0x80000000-0x82000000
虚拟地址 0x02000000-0x04000000 → 物理地址 0x84000000-0x86000000
```

### 2.2 实现进程隔离

```
程序 A 的视角（虚拟地址空间）：
┌────────────────────────────────────┐
│   我的代码   我的数据    我的堆        │
└────────────────────────────────────┘
0x00000000                  0x3FFFFFFF

程序 B 的视角（虚拟地址空间）：
┌────────────────────────────────────┐
│   我的代码   我的数据    我的堆        │  ← 地址相同，但不冲突！
└────────────────────────────────────┘
0x00000000                  0x3FFFFFFF

物理内存实际布局：
┌──────────┬──────────┐
│   A      │    B     │  ← 映射到不同的物理地址
└──────────┴──────────┘
0x80000000  0x82000000

程序 A 访问虚拟地址 0x00001000：
  → 页表转换 → 物理地址 0x80001000  ← A 的数据

程序 B 访问虚拟地址 0x00001000：
  → 页表转换 → 物理地址 0x82001000  ← B 的数据
```
---
```
通过虚拟内存到物理内存的映射，进程A与进程B实现了内存的隔离，提高了操作系统的安全性，在明白了为什么需要虚拟内存管理之后，我们便开始着手建立虚拟内存到物理内存的映射，但在这之前，我们需要先完成将堆分配器从最简单的线性分配器到物理页帧分配器的升级
```