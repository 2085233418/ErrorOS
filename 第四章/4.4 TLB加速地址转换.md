## 1. TLB：加速地址转换

### 1.1 三级页表的性能问题

虽然三级页表解决了空间浪费的问题，但带来了一个新的问题：**每次地址转换需要访问 3 次内存**！

```
地址转换的开销：

访问一次数据 = 1 次内存访问（理想情况）
              ↓
使用三级页表 = 3 次页表查询 + 1 次数据访问
              = 4 次内存访问！

性能损失：访问速度降低 4 倍！
```

**实际程序的访存模式**：
- 程序通常会**重复访问**相同的内存区域（局部性原理）
- 代码段：循环执行同一段代码
- 数据段：频繁访问同一个数组
- 栈：函数调用时反复访问栈帧

**关键观察**：如果程序反复访问虚拟地址 0x1000，我们每次都要做三级页表查询，但查询结果总是相同的！

### 1.2 什么是 TLB？

**TLB（Translation Lookaside Buffer，快表/旁路转换缓冲）**是 CPU 内置的一个**高速缓存**，专门用于存储**最近使用的虚拟地址到物理地址的转换结果**。

```
没有 TLB 的地址转换：
虚拟地址
   ↓
查 Level 2 ## 1. TLB：加速地址转换

### 1.1 三级页表的性能问题

虽然三级页表解决了空间浪费的问题，但带来了一个新的问题：**每次地址转换需要访问 3 次内存**！

```
地址转换的开销：

访问一次数据 = 1 次内存访问（理想情况）
              ↓
使用三级页表 = 3 次页表查询 + 1 次数据访问
              = 4 次内存访问！

性能损失：访问速度降低 4 倍！
```

**实际程序的访存模式**：
- 程序通常会**重复访问**相同的内存区域（局部性原理）
- 代码段：循环执行同一段代码
- 数据段：频繁访问同一个数组
- 栈：函数调用时反复访问栈帧

**关键观察**：如果程序反复访问虚拟地址 0x1000，我们每次都要做三级页表查询，但查询结果总是相同的！

### 1.2 什么是 TLB？

**TLB（Translation Lookaside Buffer，快表/旁路转换缓冲）**是 CPU 内置的一个**高速缓存**，专门用于存储**最近使用的虚拟地址到物理地址的转换结果**。
(内存访问 1)
   ↓
查 Level 1 (内存访问 2)
   ↓
查 Level 0 (内存访问 3)
   ↓
物理地址
   ↓
访问数据 (内存访问 4)

总计：4 次内存访问

═══════════════════════════════════════

有 TLB 的地址转换：
虚拟地址
   ↓
查 TLB (命中！) ← 在 CPU 内部，极快
   ↓
物理地址
   ↓
访问数据 (内存访问 1)

总计：1 次内存访问
性能提升：4 倍！
```

### 1.3 TLB 的工作原理

TLB 本质上是一个**键值对缓存**：

```
TLB 的结构：

┌──────────────────┬─────────────────────┬──────────┐
│   虚拟页号 (VPN)  │   物理页号 (PPN)     │  标志位   │
├──────────────────┼─────────────────────┼──────────┤
│   0x1000         │   0x80001           │  R W X   │  ← 缓存的转换
├──────────────────┼─────────────────────┼──────────┤
│   0x2000         │   0x80002           │  R W -   │
├──────────────────┼─────────────────────┼──────────┤
│   0x3000         │   0x80005           │  R - X   │
├──────────────────┼─────────────────────┼──────────┤
│   ...            │   ...               │  ...     │
└──────────────────┴─────────────────────┴──────────┘

特点：
- 容量小（通常 32-128 项）
- 速度极快（CPU 内部硬件）
- 采用关联查找（并行搜索）
```

**地址转换流程（带 TLB）**：

```
步骤 1：查询 TLB
┌────────────────────┐
│  虚拟地址 0x1000456 │
└──────────┬─────────┘
           │ 提取虚拟页号 0x1000
           ↓
       ┌───────┐
       │  TLB  │
       └───┬───┘
           │
    ┌──────┴──────┐
    │             │
   命中          未命中
    │             │
    ↓             ↓
┌────────┐   ┌─────────────┐
│从 TLB   │   │  三级页表    │
│读取 PPN │   │  查询（慢）   │
└───┬────┘   └──────┬──────┘
    │               │
    │               │ 查询结果写入 TLB
    └───────┬───────┘
            ↓
      物理页号 0x80001
            ↓
  物理地址 = 0x80001000 + 0x456
           = 0x80001456
```

### 1.4 TLB 何时需要刷新？

TLB 缓存的转换可能会**失效**，需要刷新。在我们的代码中，有以下情况需要刷新 TLB：

#### 情况 1：建立新的页面映射

```rust
// 在 map_page 函数中建立新映射后
pub fn map_page(...) -> Result<(), &'static str> {
    // ... 设置页表项 ...
    pte0.set(paddr.as_usize() >> 12, flags | PageTableFlags::Valid as usize);

    // ⚠️ 必须刷新 TLB！
    // 原因：TLB 可能缓存了"该虚拟地址未映射"的结果
    unsafe {
        core::arch::asm!(
            "sfence.vma {0}, zero",
            in(reg) vaddr.as_usize(),
        );
    }

    Ok(())
}
```

**为什么需要刷新？**
- TLB 可能之前查询过这个虚拟地址，发现未映射
- 现在我们建立了新映射，但 TLB 还保留着旧的"未映射"信息
- 如果不刷新，CPU 会使用 TLB 中的旧信息，导致访问失败

#### 情况 2：切换地址空间（进程切换）

```rust
// 激活新的地址空间时
pub fn activate(&self) {
    use riscv::register::satp;

    let ppn = self.page_table_paddr.as_usize() >> 12;

    unsafe {
        // 切换到新的页表
        satp::set(satp::Mode::Sv39, 0, ppn);

        // ⚠️ 必须刷新整个 TLB！
        // 原因：新进程的虚拟地址映射完全不同
        core::arch::asm!("sfence.vma");  // 不带参数 = 刷新所有项
    }
}
```

**为什么需要刷新？**
- 不同进程使用不同的页表（不同的虚拟地址空间）
- 虚拟地址 0x1000 在进程 A 和进程 B 中映射到**不同的物理地址**
- 如果不刷新，进程 B 可能访问到进程 A 的数据（安全漏洞！）

#### RISC-V 的 sfence.vma 指令

```
sfence.vma 指令格式：

sfence.vma rs1, rs2

参数：
- rs1 = 虚拟地址（可选）：只刷新该地址的 TLB 项
- rs2 = ASID（可选）：地址空间标识符（本章未使用）

示例：
sfence.vma x10, zero  # 刷新 x10 寄存器指向的虚拟地址
sfence.vma zero, zero # 刷新所有 TLB 项
```

### 1.5 TLB 的性能影响

**TLB 命中率的重要性**：

```
假设：
- TLB 访问时间：1 纳秒（CPU 内部）
- 内存访问时间：100 纳秒
- TLB 命中率：95%

平均访问时间计算：
= TLB 命中时间 × 命中率 + (TLB + 三级页表 + 数据) × 未命中率
= 1ns × 95% + (1ns + 300ns + 100ns) × 5%
= 0.95ns + 20.05ns
= 21ns

如果没有 TLB：
= 300ns (三级页表) + 100ns (数据)
= 400ns

性能提升：400 / 21 ≈ 19 倍！
```

---