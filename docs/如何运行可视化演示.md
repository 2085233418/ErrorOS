# 如何运行进程管理可视化演示

## 方法一：在 main.rs 中运行（推荐）

### 1. 打开主函数文件

```bash
# 编辑 main.rs
vim os/src/main.rs
# 或
code os/src/main.rs
```

### 2. 找到可视化演示代码段

在 `kernel_main()` 函数中找到这一段（约在第123-134行）：

```rust
// ========================================
// 进程管理可视化演示
// ========================================
// 取消下面的注释来运行可视化演示：

// os::process::visualization::run_all_demos();           // 运行所有演示
// os::process::visualization::demo_pid_allocation();     // 演示1：PID分配
// os::process::visualization::demo_state_transitions();  // 演示2：状态转换
// os::process::visualization::demo_pcb_creation();       // 演示3：PCB创建
// os::process::visualization::demo_time_slice();         // 演示4：时间片管理
// os::process::visualization::demo_parent_child();       // 演示5：父子进程关系
// os::process::visualization::demo_process_exit();       // 演示6：进程退出
```

### 3. 选择要运行的演示

#### 选项A：运行所有演示

取消第一行的注释：

```rust
os::process::visualization::run_all_demos();           // 运行所有演示
// os::process::visualization::demo_pid_allocation();     // 演示1：PID分配
// ...其他保持注释
```

#### 选项B：只运行某个演示

例如，只想看PID分配演示：

```rust
// os::process::visualization::run_all_demos();           // 运行所有演示
os::process::visualization::demo_pid_allocation();     // 演示1：PID分配
// ...其他保持注释
```

#### 选项C：运行多个演示

想看PID分配和时间片演示：

```rust
// os::process::visualization::run_all_demos();           // 运行所有演示
os::process::visualization::demo_pid_allocation();     // 演示1：PID分配
// os::process::visualization::demo_state_transitions();  // 演示2：状态转换
// os::process::visualization::demo_pcb_creation();       // 演示3：PCB创建
os::process::visualization::demo_time_slice();         // 演示4：时间片管理
// ...其他保持注释
```

### 4. 编译并运行

```bash
cd os
cargo run
```

### 5. 查看输出

QEMU窗口会弹出，但主要输出在终端（串口）中。

---

## 方法二：通过测试框架运行（实验性）

⚠️ 注意：由于 `build-std` 配置问题，测试框架目前有兼容性问题。推荐使用方法一。

---

## 六个演示详解

### 演示1：PID分配器 (`demo_pid_allocation`)

**目的**：理解PID如何分配

**展示内容**：
- 连续分配5个PID
- 验证唯一性
- 验证单调递增

**运行时间**：约3秒

**适用章节**：6.1.2 PID分配器

---

### 演示2：进程状态转换 (`demo_state_transitions`)

**目的**：理解进程生命周期

**展示内容**：
- Ready → Running → Ready → Zombie
- 每个状态的含义

**运行时间**：约2秒

**适用章节**：6.1.3 进程状态枚举

---

### 演示3：PCB创建 (`demo_pcb_creation`)

**目的**：理解进程控制块结构

**展示内容**：
- 创建init进程
- 创建shell进程
- 展示进程树

**运行时间**：约3秒

**适用章节**：6.1.4 进程控制块

---

### 演示4：时间片管理 (`demo_time_slice`)

**目的**：理解时间片调度机制

**展示内容**：
- 时间片从5开始
- 每次tick消耗1个
- 用尽后触发调度

**运行时间**：约3秒（有动画效果）

**适用章节**：6.3 调度器

---

### 演示5：父子进程关系 (`demo_parent_child`)

**目的**：理解进程树结构

**展示内容**：
- 创建父进程
- 逐步添加子进程
- 进程树演变过程

**运行时间**：约3秒

**适用章节**：6.1.4 进程控制块（父子关系）

---

### 演示6：进程退出 (`demo_process_exit`)

**目的**：理解Zombie状态的意义

**展示内容**：
- 进程从创建到退出
- Zombie状态的作用
- 退出码的保存

**运行时间**：约2秒

**适用章节**：6.1.3 进程状态枚举（Zombie状态）

---

## 典型使用场景

### 场景1：课堂演示

**教师操作步骤**：

1. 讲解某个概念（如PID分配）
2. 打开main.rs，取消对应演示的注释
3. 运行 `cargo run`
4. 边看输出边讲解
5. 暂停QEMU（Ctrl+A, C），学生提问
6. 继续运行或重启演示

**推荐设置**：投影仪显示终端输出（而不是QEMU窗口）

---

### 场景2：学生自学

**学生操作步骤**：

1. 阅读指导书某一节（如6.1.2 PID分配器）
2. 打开main.rs，运行对应的可视化演示
3. 观察输出，理解概念
4. 尝试修改代码（如改变PID起始值）
5. 重新运行，观察变化

**学习路径**：
```
阅读理论 → 运行演示 → 理解输出 → 修改代码 → 观察变化 → 深入理解
```

---

### 场景3：实验报告

**学生需要做的**：

1. 运行指定的演示
2. 截图保存输出
3. 分析输出内容
4. 回答问题（指导书中提供）

**示例问题**：
- 演示1：为什么PID从1开始而不是0？
- 演示2：Zombie状态为什么必要？
- 演示4：如果时间片设为10会怎样？

---

## 调整延迟时间

如果觉得演示速度太快或太慢，可以修改延迟时间：

### 1. 打开可视化模块

```bash
vim os/src/process/visualization.rs
```

### 2. 找到延迟函数定义

在文件开头（约第34-40行）：

```rust
/// 短暂延迟（用于步骤之间）
fn short_delay() {
    delay(50_000_000);  // 约 0.5 秒
}

/// 长延迟（用于演示之间）
fn long_delay() {
    delay(100_000_000);  // 约 1 秒
}
```

### 3. 修改循环次数

| 循环次数 | 大约延迟时间 | 适用场景 |
|---------|------------|---------|
| 10_000_000 | 0.1秒 | 快速演示 |
| 50_000_000 | 0.5秒 | **默认（推荐）** |
| 100_000_000 | 1秒 | 课堂讲解 |
| 200_000_000 | 2秒 | 慢速演示 |

**注意**：实际延迟时间取决于CPU频率，在QEMU中约为上述值。

---

## 自定义演示

### 添加新的演示函数

假设你想添加"演示7：进程优先级"：

#### 1. 在 `visualization.rs` 中添加函数

```rust
/// 演示7：进程优先级
pub fn demo_process_priority() {
    serial_println!("\n╔════════════════════════════════════════════════════╗");
    serial_println!("║          演示7：进程优先级                         ║");
    serial_println!("╠════════════════════════════════════════════════════╣");
    serial_println!("║ 说明：展示不同优先级进程的调度                     ║");
    serial_println!("╚════════════════════════════════════════════════════╝\n");
    short_delay();

    // 创建高优先级进程
    serial_println!("→ 创建高优先级进程...");
    let high_prio = create_process_handle("high_prio", None);
    high_prio.lock().set_priority(10);
    serial_println!("✓ 优先级 = 10\n");
    short_delay();

    // 创建低优先级进程
    serial_println!("→ 创建低优先级进程...");
    let low_prio = create_process_handle("low_prio", None);
    low_prio.lock().set_priority(1);
    serial_println!("✓ 优先级 = 1\n");
    short_delay();

    serial_println!("说明：高优先级进程会优先获得CPU时间\n");

    serial_println!("╔════════════════════════════════════════════════════╗");
    serial_println!("║ ✓ 优先级演示完成                                   ║");
    serial_println!("╚════════════════════════════════════════════════════╝\n");
}
```

#### 2. 在 `main.rs` 中添加调用

```rust
// os::process::visualization::demo_process_priority();   // 演示7：进程优先级
```

#### 3. 使用新演示

取消注释即可运行。

---

## 常见问题

### Q1: 运行后看不到输出？

**A**: 输出在终端（串口），不是QEMU窗口。确保查看运行 `cargo run` 的终端。

### Q2: 输出乱码？

**A**: 确保终端支持UTF-8编码：
```bash
export LANG=en_US.UTF-8
```

### Q3: 演示太快看不清？

**A**: 修改 `short_delay()` 和 `long_delay()` 中的循环次数，增大数值。

### Q4: 如何暂停演示查看某一步？

**A**:
- 方法1：在想要暂停的地方添加更长的延迟
- 方法2：使用GDB调试模式，设置断点

### Q5: 想录制演示视频？

**A**: 使用 `asciinema` 录制终端：
```bash
asciinema rec demo.cast
cd os && cargo run
# Ctrl+C 停止录制
asciinema play demo.cast
```

### Q6: 如何在不重启的情况下运行多个演示?

**A**: 在main.rs中取消多个演示的注释，它们会按顺序执行：
```rust
os::process::visualization::demo_pid_allocation();
os::process::visualization::demo_time_slice();
os::process::visualization::demo_process_exit();
```

---

## 最佳实践

### 教师建议

1. **课前准备**：提前测试演示，确保输出符合预期
2. **投影设置**：确保字体足够大，学生能看清
3. **互动时机**：在 `short_delay()` 处暂停，提问学生
4. **代码对照**：一边展示可视化，一边对照源代码讲解

### 学生建议

1. **先读理论**：先阅读对应章节的指导书
2. **再看演示**：理解了概念后再运行可视化
3. **动手修改**：尝试修改代码，观察变化
4. **记录问题**：看不懂的地方记下来，问老师或同学

### 实验建议

1. **按顺序进行**：演示1-6 是按难度递增的
2. **截图存档**：每个演示的输出都截图保存
3. **分析输出**：不要只看热闹，理解每一行输出的含义
4. **对比代码**：输出和源代码对照理解

---

## 技术细节

### 为什么不用 println! 而用 serial_println!？

因为这是裸机OS，还没有标准输出设备。串口是最可靠的输出方式，QEMU会自动将串口输出转发到终端。

### 延迟函数的实现原理？

```rust
fn delay(cycles: u32) {
    for _ in 0..cycles {
        core::hint::spin_loop();  // CPU忙等待
    }
}
```

这是**忙等待**（busy-wait），会占用CPU。但在演示场景下可以接受，因为：
1. 演示时不运行其他任务
2. 延迟时间短暂
3. 没有操作系统提供的sleep功能

### 为什么要用 #[inline(never)]？

```rust
#[inline(never)]
fn delay(cycles: u32) { ... }
```

防止编译器优化掉整个循环。如果没有这个标记，编译器可能发现循环没有副作用，直接删除。

---

## 总结

运行可视化演示只需三步：

1. **打开** `os/src/main.rs`
2. **取消注释**想要运行的演示函数
3. **运行** `cargo run`

简单、灵活、可视化！

祝学习愉快！ 🎉
