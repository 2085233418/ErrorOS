# 第6章架构设计：进程管理

## 一、设计目标

在第0-5章的基础上（启动、输出、中断、内存、系统调用），实现完整的进程管理系统：
- 进程控制块（PCB）
- 上下文切换（Context Switch）
- 进程调度器（Scheduler）
- 进程生命周期管理（fork/exec/exit/wait）

## 二、现有代码分析

### 2.1 已实现的模块

#### 已有基础设施：
1. **内存管理** (`os/src/memory/`)
   - 物理帧分配器（`SimpleFrameAllocator`）
   - 页表管理（Sv39 三级页表）
   - 地址空间管理（`AddressSpace`）
   - 支持恒等映射和虚拟内存

2. **中断系统** (`os/src/interrupts.rs`)
   - 陷阱向量配置（`stvec`）
   - 中断分发器（`trap_handler`）
   - 时钟中断（用于调度）
   - 系统调用入口（`UserEnvCall`）

3. **系统调用** (`os/src/syscall/`)
   - 系统调用上下文（`SyscallContext`）
   - 系统调用分发器（`syscall_dispatcher`）
   - 基础系统调用：
     - `sys_write` (64)
     - `sys_exit` (93)
     - `sys_getpid` (172)

4. **任务系统** (`os/src/task/`)
   - **注意：这是异步任务系统，用于协作式多任务**
   - 不是进程系统！
   - 使用 Future 和 Poll
   - 用于内核异步操作

### 2.2 需要新增的模块

#### 第6章需要新建：
1. **进程模块** (`os/src/process/`)
   - `mod.rs` - 进程管理核心
   - `pcb.rs` - 进程控制块定义
   - `context.rs` - 上下文切换
   - `scheduler.rs` - 进程调度器
   - `pid.rs` - PID 分配器

2. **用户程序** (`user/src/bin/`)
   - `init.rs` - 初始进程
   - `hello.rs` - 测试程序
   - `fork_test.rs` - fork测试
   - 用户库 (`user/src/lib.rs`)

### 2.3 需要修改的现有模块

#### 需要升级的模块：
1. **系统调用模块** (`os/src/syscall/`)
   - 添加进程相关系统调用：
     - `sys_fork` (220) - 创建子进程
     - `sys_exec` (221) - 执行程序
     - `sys_waitpid` (260) - 等待子进程
   - 升级 `sys_exit` - 支持进程资源回收
   - 升级 `sys_getpid` - 返回真实PID

2. **中断模块** (`os/src/interrupts.rs`)
   - 在时钟中断中添加调度器触发
   - 在系统调用返回时检查是否需要调度

3. **内存模块** (`os/src/memory/`)
   - 支持为每个进程创建独立地址空间
   - 支持用户栈分配

4. **主模块** (`os/src/main.rs`)
   - 初始化进程管理器
   - 创建 init 进程
   - 启动调度器

## 三、核心数据结构设计

### 3.1 进程控制块（PCB）

```rust
pub struct ProcessControlBlock {
    // 基础信息
    pid: ProcessId,                     // 进程ID
    parent_pid: Option<ProcessId>,      // 父进程ID
    state: ProcessState,                // 进程状态

    // 上下文信息
    context: ProcessContext,            // 寄存器上下文

    // 内存信息
    address_space: Option<AddressSpace>,// 地址空间（页表）
    heap_bottom: usize,                 // 堆底
    user_stack_top: usize,              // 用户栈顶

    // 调度信息
    time_slice: usize,                  // 时间片
    priority: usize,                    // 优先级

    // 退出信息
    exit_code: Option<i32>,             // 退出码
}
```

### 3.2 进程状态

```rust
pub enum ProcessState {
    Ready,      // 就绪
    Running,    // 运行中
    Blocked,    // 阻塞
    Zombie,     // 僵尸状态（已退出但未被回收）
}
```

### 3.3 进程上下文

```rust
#[repr(C)]
pub struct ProcessContext {
    // 保存的寄存器（RISC-V）
    ra: usize,       // 返回地址
    sp: usize,       // 栈指针
    gp: usize,       // 全局指针
    tp: usize,       // 线程指针
    t0_t6: [usize; 7],  // 临时寄存器
    s0_s11: [usize; 12], // 保存寄存器
    a0_a7: [usize; 8],   // 参数寄存器

    // 特殊寄存器
    sepc: usize,     // 异常PC
    sstatus: usize,  // 状态寄存器
    satp: usize,     // 地址空间寄存器
}
```

### 3.4 调度器

```rust
pub struct Scheduler {
    // Round-Robin 队列
    ready_queue: VecDeque<ProcessId>,

    // 进程表（全局）
    processes: BTreeMap<ProcessId, Arc<Mutex<ProcessControlBlock>>>,

    // 当前运行进程
    current: Option<ProcessId>,
}
```

## 四、实现路径

### 阶段1：进程控制块和上下文切换（6.1, 6.2）
**学生要做的：**
1. 创建 `os/src/process/` 目录
2. 实现 `ProcessControlBlock` 结构
3. 实现 `ProcessContext` 结构
4. 编写上下文切换汇编代码

**对现有代码的改动：**
- 无（纯新增）

### 阶段2：进程调度器（6.3）
**学生要做的：**
1. 实现 `Scheduler` 结构
2. 实现 Round-Robin 调度算法
3. 在时钟中断中触发调度

**对现有代码的改动：**
- 修改 `interrupts.rs`：在 `timer_interrupt_handler` 中调用调度器
- 修改 `main.rs`：初始化调度器

### 阶段3：进程生命周期（6.4）
**学生要做的：**
1. 实现 `sys_fork`
2. 实现 `sys_exec`
3. 升级 `sys_exit`
4. 实现 `sys_waitpid`

**对现有代码的改动：**
- 修改 `syscall/mod.rs`：添加新系统调用号
- 修改 `syscall/syscall_impl.rs`：升级 `sys_getpid` 和 `sys_exit`
- 修改 `main.rs`：创建 init 进程

### 阶段4：用户程序（6.5）
**学生要做的：**
1. 创建 `user/` 目录
2. 编写用户库
3. 编写测试程序

**对现有代码的改动：**
- 修改根目录 `Cargo.toml`：添加 workspace

## 五、与第5章的衔接

### 第5章结尾状态：
- ✅ 基础系统调用已实现（write/exit/getpid）
- ✅ 系统调用分发器已完成
- ✅ 内存管理已就绪
- ✅ 中断系统已就绪

### 第6章升级点：
1. **系统调用**：从"固定返回值"到"真实进程管理"
   - `sys_getpid`: 从返回固定 `1` 到返回当前进程真实PID
   - `sys_exit`: 从 `hlt_loop()` 到进程资源回收 + 调度

2. **中断**：从"简单定时"到"触发调度"
   - 时钟中断：添加调度器调用

3. **内存**：从"单一地址空间"到"每进程独立地址空间"
   - 为每个进程分配独立页表

## 六、教学要点

### 6.1 概念教学
- 什么是进程？
- 进程 vs 线程 vs 异步任务
- 进程的生命周期
- 上下文切换的必要性

### 6.2 RISC-V 特定内容
- RISC-V 寄存器约定（Calling Convention）
- `satp` 寄存器和地址空间切换
- `sstatus` 寄存器的 SPP 位（特权级切换）

### 6.3 调试技巧
- 如何追踪进程切换
- 如何验证上下文保存正确性
- 如何检测死锁和栈溢出

## 七、测试策略

### 7.1 单元测试
- 上下文切换保存/恢复正确性
- PID分配器唯一性
- 调度器队列操作

### 7.2 集成测试
- 创建多个进程
- fork 子进程
- 等待子进程退出
- 僵尸进程回收

### 7.3 可视化测试（保留但对学生不可见）
- 进程状态转换图
- 调度时间线
- 系统调用追踪

## 八、风险点

### 8.1 技术风险
1. **栈溢出**：用户栈和内核栈的大小设置
2. **页表切换**：`satp` 切换后的 TLB 刷新
3. **中断重入**：调度器执行时的中断管理

### 8.2 教学风险
1. **概念混淆**：进程 vs task（异步任务）
2. **汇编代码**：上下文切换的汇编对新手不友好
3. **并发问题**：调度器的互斥保护

### 8.3 缓解措施
1. 提供详细的注释和图示
2. 分阶段实现，每阶段可独立测试
3. 提供参考实现（最后阶段）

## 九、代码改动清单

### 新增文件：
```
os/src/process/mod.rs          - 进程管理核心
os/src/process/pcb.rs          - 进程控制块
os/src/process/context.rs      - 上下文切换
os/src/process/scheduler.rs    - 调度器
os/src/process/pid.rs          - PID分配器
os/src/process/switch.S        - 上下文切换汇编
user/src/lib.rs                - 用户库
user/src/bin/init.rs           - init进程
```

### 修改文件：
```
os/src/lib.rs                  - 添加 process 模块声明
os/src/main.rs                 - 初始化进程系统，创建init进程
os/src/interrupts.rs           - 时钟中断触发调度
os/src/syscall/mod.rs          - 添加进程相关系统调用号
os/src/syscall/syscall_impl.rs - 实现进程系统调用
Cargo.toml                     - 添加 workspace
```

## 十、时间估算（学生完成）

- 6.1 进程控制块：2-3小时
- 6.2 上下文切换：3-4小时（汇编较难）
- 6.3 进程调度：2-3小时
- 6.4 进程生命周期：4-5小时（最复杂）
- 总计：11-15小时

---

**设计完成日期：** 2025-11-27
**下一步：** 开始实现 6.1 - 进程控制块
