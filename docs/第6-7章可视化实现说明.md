# 第6-7章可视化实现说明

## 概述

本文档说明第6章（进程管理）和第7章（文件系统）的可视化实现方案。

**核心原则**：使用真实系统状态，而非假数据演示。

## 架构设计

### 设计思路

传统的教学演示通常使用临时数据进行可视化，学生看到的内容与真实系统状态脱节。本方案采用**检查器（Inspector）模式**，直接从系统内核数据结构中查询真实状态，确保可视化内容与实际运行状态完全一致。

### 模块结构

```
os/src/
├── process/
│   ├── mod.rs              # 进程管理核心
│   ├── scheduler.rs        # 调度器（真实数据源）
│   └── inspector.rs        # 进程检查器（可视化）✨
├── fs/
│   ├── mod.rs              # 文件系统核心
│   ├── ramfs.rs            # RamFS（真实数据源）
│   └── inspector.rs        # 文件系统检查器（可视化）✨
└── system_init.rs          # 系统初始化（带步骤展示）✨
```

## 第6章：进程管理可视化

### 数据源

所有进程数据来自 `SCHEDULER` 全局调度器：

```rust
// os/src/process/scheduler.rs
pub static SCHEDULER: Mutex<Scheduler> = Mutex::new(Scheduler::new());

impl Scheduler {
    pub fn processes(&self) -> &HashMap<ProcessId, ProcessHandle> {
        &self.processes  // 真实的进程表
    }

    pub fn current_pid(&self) -> Option<ProcessId> {
        self.current  // 真实的当前运行进程
    }
}
```

### 检查器实现

**文件位置**：`os/src/process/inspector.rs`

**核心功能**：

1. **查询所有进程**
```rust
pub fn get_all_processes() -> Vec<ProcessSnapshot> {
    let scheduler = SCHEDULER.lock();
    let mut snapshots = Vec::new();

    for (pid, process_handle) in scheduler.processes() {
        let pcb = process_handle.lock();
        snapshots.push(ProcessSnapshot {
            pid: (*pid).as_usize(),
            name: pcb.name().into(),
            state: pcb.state(),           // Ready/Running/Blocked/Zombie
            parent_pid: pcb.parent_pid().map(|p| p.as_usize()),
        });
    }
    snapshots
}
```

2. **查询系统统计**
```rust
pub fn get_system_stats() -> SystemStats {
    let processes = get_all_processes();

    SystemStats {
        total_processes: processes.len(),
        running_processes: processes.iter().filter(|p| p.state == ProcessState::Running).count(),
        ready_processes: processes.iter().filter(|p| p.state == ProcessState::Ready).count(),
        blocked_processes: processes.iter().filter(|p| p.state == ProcessState::Blocked).count(),
        zombie_processes: processes.iter().filter(|p| p.state == ProcessState::Zombie).count(),
    }
}
```

3. **可视化输出函数**
```rust
pub fn show_process_list()        // 显示进程列表表格
pub fn show_system_stats()         // 显示系统统计信息
pub fn show_current_process()      // 显示当前运行进程
pub fn show_system_dashboard()     // 完整仪表盘（组合以上三者）
```

### 使用示例

```rust
// 在系统初始化中调用
os::process::inspector::show_process_list();
```

**输出示例**：
```
================================================================
===                  System Process List                     ===
================================================================
===  PID  |  Name              |  State      |  Parent PID  ===
================================================================
===    1  |  init             |  Ready       |    -            ===
===    2  |  shell            |  Ready       |       1         ===
===    3  |  user_task1       |  Ready       |       1         ===
===    4  |  user_task2       |  Ready       |       1         ===
===    5  |  user_task3       |  Ready       |       1         ===
================================================================
```

## 第7章：文件系统可视化

### 数据源

所有文件系统数据来自 `RAMFS` 和 `FD_TABLE`：

```rust
// os/src/fs/manager.rs
lazy_static! {
    pub static ref RAMFS: RamFS = RamFS::new();
    pub static ref FD_TABLE: Mutex<FileDescriptorTable> =
        Mutex::new(FileDescriptorTable::new());
}
```

### 检查器实现

**文件位置**：`os/src/fs/inspector.rs`

**核心功能**：

1. **查询文件和目录**
```rust
pub fn get_root_entries() -> Vec<EntrySnapshot> {
    let mut entries = Vec::new();
    let root = RAMFS.root();

    if let Ok(entry_names) = root.lock().list_entries() {
        for name in entry_names {
            if let Ok(inode) = root.lock().lookup(&name) {
                let inode_guard = inode.lock();
                entries.push(EntrySnapshot {
                    name: name.clone(),
                    ino: inode_guard.ino(),        // 真实inode号
                    file_type: inode_guard.file_type(),  // File/Directory
                    size: inode_guard.size(),      // 文件大小
                });
            }
        }
    }
    entries
}
```

2. **查询FD表状态**
```rust
pub fn get_allocated_fds() -> Vec<FdSnapshot> {
    let mut fds = Vec::new();
    let fd_table = FD_TABLE.lock();

    // 检查标准流 (0-2)
    if fd_table.get(0).is_some() {
        fds.push(FdSnapshot { fd: 0, name: "Stdin".into() });
    }
    // ... stdout, stderr

    // 检查用户文件 (>= 3)
    for fd in 3..32 {
        if fd_table.get(fd).is_some() {
            fds.push(FdSnapshot { fd, name: format!("File-{}", fd) });
        }
    }
    fds
}
```

3. **可视化输出函数**
```rust
pub fn show_file_list()              // 显示文件列表
pub fn show_fd_table()               // 显示FD表
pub fn show_fd_stats()               // 显示FD统计
pub fn show_filesystem_tree()        // 显示文件系统树
pub fn show_filesystem_dashboard()   // 完整仪表盘
```

### 使用示例

```rust
// 在系统初始化中调用
os::fs::inspector::show_filesystem_tree();
```

**输出示例**：
```
================================================================
===              Filesystem Tree Structure                   ===
================================================================
===                                                          ===
===  / (root, ino=1)                                         ===
===  |--  etc (ino=2, 0B)/                                   ===
===  |   |--  passwd                                         ===
===  |   +--  hostname                                       ===
===  |--  home (ino=3, 0B)/                                  ===
===  |   +--  user (ino=4, 0B)/                              ===
===  +--  tmp (ino=5, 0B)/                                   ===
===                                                          ===
================================================================
```

## 系统初始化流程

### 文件位置

`os/src/system_init.rs`

### 设计理念

系统初始化不仅要创建必要的进程和文件，还要**逐步展示创建过程**，让学生清楚看到每一步的状态变化。

### 实现方式

```rust
pub fn init_system_processes() {
    println!("\n[Chapter 6 Demo: Process Management]");

    // 步骤1：创建init进程
    println!("\n[Step 1] Create init process (PID 1)");
    println!("  Configuration:");
    println!("    - Process name: init");
    println!("    - Entry address: 0x80000000");

    let init_proc = create_process("init", 0x8000_0000, 0x8001_0000, None);
    SCHEDULER.lock().add_process(init_proc.clone());

    println!("  [OK] init process created successfully!");
    println!("    - PID: {}", init_proc.lock().pid().as_usize());

    // 关键：展示当前真实状态
    println!("\n  Current system process list:");
    crate::process::inspector::show_process_list();

    // 步骤2：创建shell进程
    println!("\n[Step 2] Create shell process");
    // ... 类似步骤

    // 步骤3：创建用户进程
    println!("\n[Step 3] Create user task processes");
    for i in 1..=3 {
        let proc = create_process(/* ... */);
        SCHEDULER.lock().add_process(proc);
        println!("  [OK] {} created (PID={})", name, pid);
    }

    // 最终状态展示
    println!("\n[Process creation complete] Final system state:");
    crate::process::inspector::show_system_dashboard();
}
```

**关键点**：
- ✅ 每步创建后立即调用 inspector 显示真实状态
- ✅ 学生可以看到进程数量从 1 → 2 → 5 的变化过程
- ✅ 所有数据来自真实的 SCHEDULER，不是临时变量

## 技术要点

### 1. 数据隔离

- **系统核心**：`scheduler.rs`, `ramfs.rs` - 不包含任何可视化代码
- **可视化层**：`inspector.rs` - 只读查询，不修改系统状态

### 2. 类型转换

ProcessId 是 newtype，需要转换为 usize：
```rust
// ❌ 错误
pid: *pid,  // ProcessId 不能直接赋值给 usize

// ✅ 正确
pid: (*pid).as_usize(),
```

### 3. Trait 导入

访问 Inode 方法需要导入 trait：
```rust
use super::{RAMFS, FD_TABLE, Inode};  // 必须导入 Inode trait

let inode_guard = inode.lock();
let size = inode_guard.size();  // 需要 Inode trait
```

### 4. ASCII 字符输出

为避免终端乱码，所有可视化输出使用纯 ASCII 字符：

```rust
// ❌ 会产生乱码（UTF-8 通过管道传输时编码问题）
println!("╔════════════════════════════════════╗");
println!("║  进程管理                          ║");

// ✅ 纯 ASCII，兼容性好
println!("================================================================");
println!("===          Process Management                              ===");
```

## 调试输出控制

### 问题

系统运行时大量 `[PROCESS]` 和 `[SCHEDULER]` 调试信息刷屏，影响可视化展示。

### 解决方案

1. **进程创建**（`os/src/process/mod.rs`）
```rust
pub fn create_process(...) -> ProcessHandle {
    // 注释掉调试输出
    // serial_println!("[PROCESS] Creating process: {}", name);

    let process = create_process_handle(name, parent_pid);
    // ...

    // serial_println!("[PROCESS] Process created: PID={}", pid);
    process
}
```

2. **调度器**（`os/src/process/scheduler.rs`）
```rust
// 使用空宏禁用调试输出
macro_rules! scheduler_debug {
    ($($arg:tt)*) => {
        // 调试输出已禁用
        // 如需启用，取消注释：serial_println!($($arg)*);
    };
}

pub fn add_process(&mut self, process: ProcessHandle) {
    scheduler_debug!("[SCHEDULER] Add process: PID={}", pid);  // 不输出
    // ...
}
```

## 使用方法

### 学生完成实验后的可视化调用

1. **创建进程后查看**
```rust
let my_proc = create_process("my_app", 0x80000000, 0x80100000, None);
SCHEDULER.lock().add_process(my_proc);

// 立即查看系统状态
os::process::inspector::show_process_list();
```

2. **创建文件后查看**
```rust
let file = RAMFS.create_file(root, String::from("test.txt"))?;
let mut f = RAMFS.open_file(file)?;
f.write(b"Hello")?;

// 立即查看文件系统
os::fs::inspector::show_filesystem_tree();
```

3. **打开文件后查看FD表**
```rust
let fd = FD_TABLE.lock().alloc(file_arc);

// 查看FD分配情况
os::fs::inspector::show_fd_table();
```

## 运行效果

### 完整启动流程

```bash
cd os
cargo run
```

### 输出示例

```
Welcome to Error OS!
[INIT] Initializing RISC-V OS
...

=== System Initialization ===

[Chapter 6 Demo: Process Management]
================================================================
Demo Content: Creating Real System Processes
================================================================

[Step 1] Create init process (PID 1, first system process)
  [OK] init process created successfully!
    - PID: 1
    - State: Ready

  Current system process list:
================================================================
===                  System Process List                     ===
================================================================
===  PID  |  Name              |  State      |  Parent PID  ===
================================================================
===    1  |  init             |  Ready       |    -            ===
================================================================

[Step 2] Create shell process (user interaction interface)
  [OK] shell process created successfully!
    - PID: 2
    - Parent PID: 1

  Current system process list:
================================================================
===    1  |  init             |  Ready       |    -            ===
===    2  |  shell            |  Ready       |       1         ===
================================================================

... (继续创建其他进程和文件系统)

=== System Initialization Complete ===

系统已就绪，按Ctrl+A然后X退出QEMU
```

## 优势

1. **真实性**：所有数据来自真实系统状态，不是假数据
2. **实时性**：可以在任何时刻调用 inspector 查看当前状态
3. **教学性**：清晰展示每一步的状态变化
4. **可扩展性**：新增数据查询只需在 inspector 中添加函数
5. **模块化**：可视化与核心逻辑分离，互不影响

## 未来改进方向

1. **更多查询功能**
   - 进程的内存使用情况
   - 页表映射关系可视化
   - 调度历史记录

2. **交互式查询**
   - 按PID查询特定进程
   - 按路径查询特定文件
   - 按条件过滤进程列表

3. **性能监控**
   - 进程创建/销毁事件记录
   - 文件系统操作统计
   - 系统调用频率分析

## 总结

本可视化方案通过 **Inspector 模式** 实现了真实系统状态的展示，确保学生看到的内容与内核实际运行状态完全一致。这种设计不仅适用于教学演示，也为系统调试和监控提供了基础。
