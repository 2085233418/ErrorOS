# ERROR OS 代码阅读指南

**版本**: v1.0
**日期**: 2025-11-27
**适用代码**: 当前系统状态（0-5章完成）

---

## 📖 阅读顺序说明

本指南按照**功能层次**和**执行流程**组织，精确到**文件和函数级别**。

**阅读原则**：
- ✅ 从底层到高层（硬件 → 驱动 → 内核 → 应用）
- ✅ 从简单到复杂（基础功能 → 高级特性）
- ✅ 从启动到运行（启动 → 初始化 → 正常运行）

**符号说明**：
- 🔴 **必读**：核心功能，必须理解
- 🟡 **重要**：重要功能，建议理解
- 🟢 **可选**：辅助功能，可以跳过
- 🔵 **测试**：测试代码，用于验证

---

## 第一阶段：启动与基础输出（第0-1章）

### 1. 🔴 项目配置与链接

**目的**：理解项目如何从裸机启动

#### 1.1 链接脚本
📁 **文件**: `os/src/linker.ld`

**阅读内容**：
- `.text.entry` 段（入口点）
- `.text` 段（代码段）
- `.rodata` 段（只读数据）
- `.data` 段（已初始化数据）
- `.bss` 段（未初始化数据）
- `stack_start` / `stack_end`（栈空间）
- `kernel_end`（内核结束地址）

**关键点**：
- 入口地址：`0x80200000`（QEMU RISC-V 默认）
- 栈大小：64KB
- 内核结束地址用于内存管理初始化

---

#### 1.2 启动汇编
📁 **文件**: `os/src/main.rs`

**函数**: `_start`（汇编，第19-40行）

**阅读顺序**：
```rust
1. `la sp, stack_end`       // 设置栈指针
2. BSS 段清零循环（25-32行）
3. `call kernel_main`       // 跳转到 Rust 主函数
4. 死循环（wfi）             // 如果返回则无限等待
```

**关键点**：
- 为什么要清零 BSS？（未初始化全局变量默认为0）
- 为什么要设置栈？（Rust 函数调用需要栈）

---

### 2. 🔴 串口输出（UART 驱动）

**目的**：实现最基础的输出功能

#### 2.1 UART 16550 驱动
📁 **文件**: `os/src/serial.rs`

**阅读顺序**：

##### Step 1: 理解硬件地址和寄存器
```rust
const UART_BASE_ADDRESS: usize = 0x1000_0000;  // QEMU virt 机器的 UART 地址
const UART_THR: usize = 0;                     // 发送寄存器
const UART_LSR: usize = 5;                     // 状态寄存器
const UART_LSR_THRE: u8 = 1 << 5;             // 发送缓冲区空标志
```

##### Step 2: 核心函数阅读顺序
```
1. SerialPort::new()              // 创建串口实例
   ↓
2. SerialPort::init()             // 初始化串口（QEMU 已初始化，此处为空）
   ↓
3. SerialPort::is_transmit_empty() // 检查发送缓冲区是否为空
   ↓
4. SerialPort::send()             // 发送一个字节（核心函数）
   ↓
5. fmt::Write trait 实现          // 使 SerialPort 支持格式化输出
```

##### Step 3: 全局实例
```rust
lazy_static! {
    pub static ref SERIAL1: Mutex<SerialPort> = { ... };
}
```

**关键点**：
- 为什么需要 `Mutex`？（多线程安全，即使现在是单线程）
- 为什么使用 `lazy_static!`？（运行时初始化，因为需要 unsafe）
- 为什么要等待 `UART_LSR_THRE`？（硬件限制，缓冲区满时不能写入）

---

#### 2.2 serial_print! 宏
📁 **文件**: `os/src/serial.rs`（底部）

**阅读顺序**：
```rust
1. _print() 函数              // 实际输出函数
   ↓
2. serial_print! 宏           // 无换行输出
   ↓
3. serial_println! 宏         // 带换行输出
```

**关键点**：
- 为什么 `_print()` 前面有下划线？（私有辅助函数）
- 宏如何工作？（编译时展开 `format_args!`）

---

### 3. 🔴 控制台输出层

**目的**：提供高级输出接口（println!）

#### 3.1 控制台 Writer
📁 **文件**: `os/src/console.rs`

**阅读顺序**：
```
1. Writer::new()                 // 创建 Writer
   ↓
2. Writer::write_byte()          // 写入单个字节
   ↓
3. Writer::write_string()        // 写入字符串
   ↓
4. Writer::new_line()            // 换行处理
   ↓
5. Writer::write_to_serial()     // 底层调用 serial 输出
   ↓
6. fmt::Write trait 实现         // 支持格式化输出
```

##### 全局实例
```rust
lazy_static! {
    pub static ref WRITER: Mutex<Writer> = Mutex::new(Writer::new());
}
```

---

#### 3.2 println! 宏
📁 **文件**: `os/src/console.rs`（底部）

**阅读顺序**：
```rust
1. _print() 函数              // 实际输出函数
   ↓
2. print! 宏                  // 无换行输出
   ↓
3. println! 宏                // 带换行输出
```

**关键点**：
- `println!` vs `serial_println!` 区别？
  - `println!` → 控制台 → 串口（高层抽象）
  - `serial_println!` → 直接串口（底层调试）

---

### 4. 🔴 库入口与初始化

#### 4.1 模块声明
📁 **文件**: `os/src/lib.rs`

**阅读顺序**：
```rust
第18-37行：模块声明
   ↓
第126-136行：init() 函数      // ⭐ 核心初始化流程
   ↓
第143-147行：hlt_loop() 函数  // 低功耗循环
```

**init() 函数详细流程**：
```rust
pub fn init() {
    1. interrupts::init_idt();        // 初始化中断向量
       ↓
    2. interrupts::enable_interrupts(); // 启用中断
}
```

---

### 5. 🔴 主函数执行流程

#### 5.1 kernel_main() 主函数
📁 **文件**: `os/src/main.rs`

**阅读顺序**：
```rust
函数：kernel_main()（第65-132行）

执行流程：
1. println!("Welcome to Error OS!")    // 第69行：欢迎信息
   ↓
2. os::init()                           // 第70行：初始化中断系统
   ↓
3. 获取 kernel_end_addr                // 第73-76行：内核结束地址
   ↓
4. memory::init()                       // 第79行：初始化内存管理
   ↓
5. allocator::init_heap()               // 第81-82行：初始化堆分配器
   ↓
6. 测试堆分配（Box/Vec/Rc）            // 第84-97行：验证堆工作正常
   ↓
7. test_page_table_features()           // 第105行：页表测试
   ↓
8. test_syscall_features()              // 第121行：系统调用测试
   ↓
9. os::hlt_loop()                       // 第131行：进入低功耗循环
```

**关键点**：
- 为什么 `kernel_main()` 返回 `!`？（永不返回）
- 为什么需要 `#[no_mangle]`？（保持函数名不被编译器改写）
- 为什么是 `extern "C"`？（使用 C 调用约定，汇编可以调用）

---

## 第二阶段：中断与异常处理（第2章）

### 6. 🔴 中断系统初始化

#### 6.1 中断向量表设置
📁 **文件**: `os/src/interrupts.rs`

**阅读顺序**：

##### Step 1: init_idt() 函数（第37-56行）
```rust
pub fn init_idt() {
    1. 设置 stvec 寄存器                // 第41行
       stvec::write(trap_handler as usize, stvec::TrapMode::Direct);
       ↓
    2. 启用定时器中断                   // 第49行
       riscv::register::sie::set_stimer();
       ↓
    3. 设置第一个定时器中断             // 第53行
       set_next_timer();
}
```

**关键点**：
- `stvec` 寄存器是什么？（S-mode 陷阱向量基址寄存器）
- `Direct` 模式 vs `Vectored` 模式？
  - Direct：所有异常跳转到同一地址
  - Vectored：中断跳转到 BASE + 4*cause

---

##### Step 2: trap_handler() 陷阱处理入口（第67-155行）
```rust
#[no_mangle]
pub extern "C" fn trap_handler() {
    1. 读取 CSR 寄存器                  // 第68-70行
       scause, stval, sepc
       ↓
    2. 判断中断或异常                   // 第72行
       match scause.cause()
       ↓
    3. 分发到具体处理函数
       ├─ Interrupt::SupervisorTimer    // 第78行 → timer_interrupt_handler()
       ├─ Interrupt::SupervisorExternal // 第81行 → external_interrupt_handler()
       ├─ Interrupt::SupervisorSoft     // 第84行 → software_interrupt_handler()
       ├─ Exception::UserEnvCall        // 第105行 → handle_syscall()
       ├─ Exception::Breakpoint         // 第108行 → breakpoint_handler()
       └─ 其他                          // 第120行 → panic!
}
```

**关键点**：
- 为什么需要 `#[no_mangle]` 和 `extern "C"`？（汇编直接跳转）
- `scause` 寄存器如何编码中断/异常类型？
  - 最高位：1=中断，0=异常
  - 低位：具体类型编号

---

##### Step 3: 具体中断处理函数
```
timer_interrupt_handler()         // 第164-172行：定时器中断
   ↓
set_next_timer()                  // 第175-184行：设置下一次定时器中断
   ↓
external_interrupt_handler()      // 第187-189行：外部中断（暂未实现）
   ↓
software_interrupt_handler()      // 第192-194行：软件中断（暂未实现）
```

---

#### 6.2 中断使能
📁 **文件**: `os/src/interrupts.rs`

```rust
pub fn enable_interrupts()        // 第197-202行
pub fn disable_interrupts()       // 第205-210行
pub fn are_interrupts_enabled()   // 第213-215行
```

**关键点**：
- `sstatus::set_sie()` 做了什么？（设置 S-mode 中断使能位）

---

### 7. 🔴 系统调用处理（第5章）

**目的**：理解用户态如何请求内核服务

#### 7.1 系统调用上下文
📁 **文件**: `os/src/syscall/mod.rs`

**阅读顺序**：

##### Step 1: 数据结构（第30-71行）
```rust
1. SyscallContext 结构体         // 第30-42行：保存系统调用参数
   ├─ syscall_id: usize           // a7 寄存器（系统调用号）
   ├─ arg0-arg5: usize            // a0-a5 寄存器（参数）
   └─ sepc: usize                 // 异常返回地址
   ↓
2. SyscallId 枚举                 // 第46-58行：系统调用号定义
   ├─ Write = 64                  // sys_write（Linux 兼容）
   ├─ Exit = 93                   // sys_exit
   ├─ GetPid = 172                // sys_getpid
   └─ Unknown = 9999              // 未知调用
   ↓
3. From<usize> trait 实现         // 第60-71行：usize → SyscallId 转换
```

---

##### Step 2: 系统调用分发器（第75-99行）
```rust
pub fn syscall_dispatcher(context: &SyscallContext) -> isize {
    1. 解析系统调用号               // 第76行
       let syscall_id = SyscallId::from(context.syscall_id);
       ↓
    2. 可视化输出（可选）           // 第79-81行
       if cfg!(feature = "verbose_syscall") {
           print_syscall_entry(context, syscall_id);
       }
       ↓
    3. 调用具体实现                 // 第83-92行
       match syscall_id {
           Write => syscall_impl::sys_write(...)
           Exit => syscall_impl::sys_exit(...)
           GetPid => syscall_impl::sys_getpid()
           Unknown => -1
       }
       ↓
    4. 可视化输出返回值（可选）     // 第94-96行
       ↓
    5. 返回结果                     // 第98行
}
```

**关键点**：
- 为什么返回 `isize` 而不是 `usize`？（需要表示负数错误码）
- `cfg!(feature = "verbose_syscall")` 如何工作？（编译期条件判断）

---

##### Step 3: 可视化函数（第103-195行）
```rust
print_syscall_entry()             // 第103-139行：打印系统调用入口信息
   ↓
format_syscall_name()             // 第142-154行：格式化系统调用名称
   ↓
print_syscall_exit()              // 第157-174行：打印返回值
   ↓
format_arg_hint()                 // 第177-195行：参数提示（如 "stdout"）
```

---

#### 7.2 系统调用实现
📁 **文件**: `os/src/syscall/syscall_impl.rs`

**阅读顺序**：
```rust
1. sys_getpid()                   // 第18-29行：获取进程ID（简化：返回1）
   ↓
2. sys_write()                    // 第33-80行：写入文件描述符
   ├─ 检查 fd 是否为 stdout（1）  // 第49行
   ├─ 验证缓冲区地址              // 第55-59行
   ├─ 写入数据                    // 第63-75行
   └─ 返回写入字节数
   ↓
3. sys_exit()                     // 第84-99行：退出进程（简化：panic）
```

**关键点**：
- 为什么 `sys_write()` 需要检查缓冲区地址？（安全性，防止访问非法内存）
- 为什么 `sys_exit()` 使用 `panic!`？（简化实现，实际应释放资源）

---

#### 7.3 系统调用入口（在中断处理中）
📁 **文件**: `os/src/interrupts.rs`

**函数**: `handle_syscall()`（第218-247行）

**阅读顺序**：
```rust
pub fn handle_syscall() {
    1. 读取系统调用上下文           // 第224-234行
       ├─ a7 → syscall_id
       ├─ a0-a5 → arg0-arg5
       └─ sepc → 异常返回地址
       ↓
    2. 创建 SyscallContext          // 第236行
       ↓
    3. 调用 syscall_dispatcher()    // 第239行
       ↓
    4. 写回返回值到 a0 寄存器      // 第242-244行
       ↓
    5. 更新 sepc（跳过 ecall 指令）// 第245行
       sepc::write(sepc + 4);
}
```

**关键点**：
- 为什么要 `sepc + 4`？（跳过 ecall 指令，否则无限循环）
- 为什么返回值写到 a0？（RISC-V 调用约定）

---

#### 7.4 测试系统调用
📁 **文件**: `os/src/syscall/mod.rs`

**函数**: `test_syscall()`（第250-274行）

**阅读顺序**：
```rust
pub fn test_syscall(syscall_id, arg0, arg1, arg2) -> isize {
    1. 使用内联汇编发起 ecall      // 第258-269行
       ├─ a7 = syscall_id
       ├─ a0-a2 = arg0-arg2
       ├─ ecall 指令
       └─ 读取 a0（返回值）
       ↓
    2. 返回结果                     // 第271行
}
```

**关键点**：
- `ecall` 指令做了什么？（触发异常，跳转到 trap_handler）
- 为什么使用内联汇编？（Rust 没有直接支持 ecall 的语法）

---

## 第三阶段：内存管理（第3-4章）

### 8. 🔴 物理内存管理（第3章）

#### 8.1 帧分配器
📁 **文件**: `os/src/memory/mod.rs`

**阅读顺序**：

##### Step 1: 基础类型（第40-97行）
```rust
1. PhysAddr / VirtAddr 结构体     // 第40-72行：地址类型封装
   ├─ new()
   ├─ as_usize()
   └─ is_aligned()
   ↓
2. PhysFrame 结构体                // 第76-97行：物理页帧
   ├─ containing_address()
   ├─ start_address()
   └─ range_inclusive()
```

---

##### Step 2: 帧分配器（第101-202行）
```rust
1. FrameAllocator trait            // 第101-104行：分配器接口
   ├─ allocate() → Option<PhysFrame>
   └─ deallocate(frame: PhysFrame)
   ↓
2. BumpFrameAllocator 结构体       // 第108-142行：简单线性分配器
   ├─ new()                        // 第112-121行
   ├─ usable_frames()              // 第124-133行：计算可用帧
   ├─ allocate()                   // 第137-141行：分配一帧
   └─ （无 deallocate 实现）       // 简化版本，不支持释放
   ↓
3. MemoryManager 结构体            // 第146-202行：内存管理器
   ├─ frame_allocator: BumpFrameAllocator
   └─ new()                        // 第154-172行
```

**关键点**：
- 什么是 Bump Allocator？（线性分配，只增不减，简单但不能释放）
- 为什么需要 `FrameAllocator` trait？（未来可以替换为更复杂的分配器）

---

##### Step 3: 内存初始化
```rust
pub fn init(kernel_end: usize) -> MemoryManager  // 第178-202行
    1. 计算可用内存区域             // 第183-192行
       ├─ 起始地址：kernel_end 对齐到页边界
       └─ 结束地址：0x8800_0000（QEMU virt 机器默认内存大小）
       ↓
    2. 创建 MemoryManager           // 第194行
```

---

### 9. 🟡 堆分配器（第3章）

#### 9.1 全局分配器
📁 **文件**: `os/src/allocator.rs`

**阅读顺序**：
```rust
1. LockedHeap 结构体               // 第24-32行：全局分配器包装
   ├─ #[global_allocator] 属性
   └─ Mutex<LinkedListAllocator>
   ↓
2. init_heap() 函数                // 第36-71行：初始化堆
   ├─ 分配堆页面                   // 第42-52行
   ├─ 计算堆区域                   // 第54-58行
   ├─ 初始化分配器                 // 第63-67行
   └─ 验证堆工作正常               // 第69行
```

**关键点**：
- `#[global_allocator]` 作用？（告诉 Rust 使用此分配器）
- `#[alloc_error_handler]` 作用？（处理分配失败）

---

#### 9.2 分配器实现
📁 **文件**: `os/src/allocator/linked_list.rs`

**阅读顺序**：
```rust
1. ListNode 结构体                 // 第9-30行：空闲块节点
   ├─ size: usize
   ├─ next: Option<&'static mut ListNode>
   ├─ start_addr()
   └─ end_addr()
   ↓
2. LinkedListAllocator 结构体      // 第34-130行：链表分配器
   ├─ new()                        // 第38-40行
   ├─ init()                       // 第56-62行：初始化堆
   ├─ alloc()                      // 第65-94行：分配内存
   │   ├─ 遍历空闲链表
   │   ├─ 找到合适的块
   │   └─ 分割块（如果过大）
   └─ dealloc()                    // 第97-127行：释放内存
       ├─ 找到插入位置
       ├─ 合并相邻空闲块（前向）
       └─ 合并相邻空闲块（后向）
```

**关键点**：
- 为什么需要链表？（跟踪空闲内存块）
- 为什么要合并？（防止内存碎片化）

---

### 10. 🔴 虚拟内存管理（第4章）

#### 10.1 页表结构
📁 **文件**: `os/src/memory/paging.rs`

**阅读顺序**：

##### Step 1: 页表项（第24-133行）
```rust
1. PageTableFlags 枚举             // 第24-34行：页表标志位
   ├─ Valid = 1 << 0
   ├─ Read = 1 << 1
   ├─ Write = 1 << 2
   ├─ Execute = 1 << 3
   └─ User = 1 << 4
   ↓
2. PageTableEntry 结构体           // 第38-133行：页表项
   ├─ entry: usize                 // 64位页表项
   ├─ new()                        // 第44-46行
   ├─ is_valid()                   // 第50-52行
   ├─ physical_address()           // 第55-69行：提取物理地址
   ├─ flags()                      // 第72-74行：提取标志位
   ├─ set()                        // 第77-90行：设置页表项
   └─ clear()                      // 第93-95行：清除页表项
```

**关键点**：
- 页表项格式（Sv39）：
  - [63:54] 保留
  - [53:28] PPN[2] (物理页号高位)
  - [27:19] PPN[1] (物理页号中位)
  - [18:10] PPN[0] (物理页号低位)
  - [9:0] 标志位

---

##### Step 2: 页表（第137-237行）
```rust
1. PageTable 结构体                // 第137-196行
   ├─ entries: [PageTableEntry; 512]
   ├─ zero()                       // 第144-150行：清零所有项
   ├─ get_entry()                  // 第153-155行：获取页表项
   └─ get_entry_mut()              // 第158-160行：获取可修改页表项
   ↓
2. 辅助函数
   ├─ vpn()                        // 第206-215行：提取虚拟页号
   └─ page_offset()                // 第218-220行：提取页内偏移
```

**关键点**：
- 为什么是 512 项？（RISC-V Sv39 每个页表 4KB / 8字节 = 512）
- 三级页表如何索引？
  - VPN[2] → 第一级页表（512项）
  - VPN[1] → 第二级页表（512项）
  - VPN[0] → 第三级页表（512项）

---

##### Step 3: 页面映射（第241-347行）
```rust
pub fn map_page_verbose(                // 第241-305行：映射单个页面
    page_table: &mut PageTable,
    virt_addr: VirtAddr,
    phys_addr: PhysAddr,
    flags: usize,
    frame_allocator: &mut impl FrameAllocator
) -> Result<(), &'static str> {
    1. 提取三级虚拟页号             // 第250-252行
       vpn2, vpn1, vpn0
       ↓
    2. 遍历第一级页表               // 第258-269行
       ├─ 如果页表项无效 → 分配新页表
       └─ 获取下一级页表地址
       ↓
    3. 遍历第二级页表               // 第271-282行
       ├─ 如果页表项无效 → 分配新页表
       └─ 获取下一级页表地址
       ↓
    4. 设置第三级页表项             // 第284-291行
       ├─ 设置物理地址
       ├─ 设置标志位
       └─ 标记为有效
       ↓
    5. 可视化输出（教学用）         // 第293-303行
}
```

**关键点**：
- 为什么需要三级页表？（节省内存，按需分配）
- 如果中间页表不存在怎么办？（动态分配新页表）

---

##### Step 4: 页表遍历（第351-445行）
```rust
pub fn walk_page_table_verbose(         // 第351-445行：遍历页表
    root_paddr: PhysAddr,
    virt_addr: VirtAddr
) -> Option<PhysAddr> {
    1. 提取三级虚拟页号             // 第358-360行
       ↓
    2. 读取第一级页表项             // 第368-378行
       ├─ 如果无效 → 返回 None
       └─ 获取下一级页表地址
       ↓
    3. 读取第二级页表项             // 第380-390行
       ├─ 如果无效 → 返回 None
       └─ 获取下一级页表地址
       ↓
    4. 读取第三级页表项             // 第392-402行
       ├─ 如果无效 → 返回 None
       └─ 提取物理页号
       ↓
    5. 计算最终物理地址             // 第404-405行
       物理页号 << 12 | 页内偏移
       ↓
    6. 可视化输出（教学用）         // 第407-443行
}
```

**关键点**：
- 三级页表遍历的对称性（map 和 walk 是对称操作）
- 如果任何一级页表项无效，整个映射无效

---

#### 10.2 地址空间
📁 **文件**: `os/src/memory/address_space.rs`

**阅读顺序**：

##### Step 1: 地址空间结构体（第15-72行）
```rust
1. AddressSpace 结构体             // 第15-54行
   ├─ root_page_table: PhysFrame   // 根页表物理地址
   ├─ name: &'static str           // 地址空间名称（调试用）
   ├─ new()                        // 第23-33行
   ├─ activate()                   // 第36-40行：激活地址空间（设置 satp）
   └─ print_layout()               // 第43-52行：打印地址空间布局
```

**关键点**：
- `satp` 寄存器？（S-mode 地址转换和保护寄存器）
- `satp` 格式（Sv39）：
  - [63:60] MODE = 8（Sv39 模式）
  - [59:44] ASID（地址空间 ID，暂未使用）
  - [43:0] PPN（根页表物理页号）

---

##### Step 2: 内核地址空间创建（第76-252行）
```rust
pub fn create_kernel_address_space(     // 第76-252行
    frame_allocator: &mut impl FrameAllocator
) -> Result<AddressSpace, &'static str> {
    1. 分配根页表                   // 第81-84行
       ↓
    2. 映射 UART 设备               // 第89-99行
       0x1000_0000 → 0x1000_0000（恒等映射）
       ↓
    3. 映射内核代码段               // 第103-159行
       0x8020_0000 → 0x8020_0000（恒等映射）
       ├─ .text 段（RX）
       ├─ .rodata 段（R）
       └─ .data/.bss 段（RW）
       ↓
    4. 映射栈空间                   // 第163-173行
       ↓
    5. 可视化输出（教学用）         // 第176-248行
       ↓
    6. 返回 AddressSpace            // 第250行
}
```

**关键点**：
- 为什么用恒等映射？（简化启动过程，虚拟地址 = 物理地址）
- 为什么映射 UART？（启用虚拟内存后仍需输出）

---

## 第四阶段：异步任务系统（可选）

### 11. 🟢 异步任务（第8章+，当前未使用）

📁 **文件**: `os/src/task/`

**说明**：当前版本中，异步任务系统已编写但**未在主流程中使用**。主要用于未来的进程调度实现。

#### 简要结构：
```
task/mod.rs                       // 任务基础结构
task/executor.rs                  // 异步执行器
task/simple_executor.rs           // 简单执行器
task/keyboard.rs                  // 键盘输入任务（示例）
```

**建议**：暂时跳过，等到第8章（进程管理）再详细学习。

---

## 📊 核心执行流程图

### 启动流程
```
_start (汇编)
   ↓
清零 BSS 段
   ↓
设置栈指针
   ↓
kernel_main()
   ↓
os::init()
   ├─ interrupts::init_idt()        // 设置 stvec
   └─ interrupts::enable_interrupts() // 启用中断
   ↓
memory::init()
   ↓
allocator::init_heap()
   ↓
测试堆分配（Box/Vec/Rc）
   ↓
test_page_table_features()
   ├─ map_page_verbose()            // 映射页面
   └─ walk_page_table_verbose()     // 遍历验证
   ↓
test_syscall_features()
   ├─ test_syscall(172, ...)        // sys_getpid
   └─ test_syscall(64, ...)         // sys_write
   ↓
os::hlt_loop()                      // 无限循环（wfi）
```

---

### 中断处理流程
```
中断/异常发生
   ↓
硬件自动跳转到 trap_handler
   ↓
读取 scause 寄存器
   ↓
判断类型：
   ├─ Timer 中断 → timer_interrupt_handler()
   │                ├─ 打印 "."
   │                └─ set_next_timer()
   │
   ├─ UserEnvCall 异常 → handle_syscall()
   │                      ├─ 读取 a7-a5 寄存器
   │                      ├─ syscall_dispatcher()
   │                      │   └─ sys_write() / sys_getpid() / ...
   │                      ├─ 写回返回值到 a0
   │                      └─ sepc += 4
   │
   └─ 其他 → panic!
      ↓
sret 指令返回
```

---

### 系统调用流程
```
用户代码
   ↓
test_syscall(syscall_id, arg0, arg1, arg2)
   ↓
内联汇编：
   ├─ a7 = syscall_id
   ├─ a0-a2 = arg0-arg2
   └─ ecall
      ↓
触发 UserEnvCall 异常
   ↓
trap_handler()
   ↓
handle_syscall()
   ├─ 读取寄存器 → SyscallContext
   ├─ syscall_dispatcher(context)
   │   ├─ print_syscall_entry()      // 可视化
   │   ├─ match syscall_id
   │   │   ├─ Write → sys_write()
   │   │   ├─ GetPid → sys_getpid()
   │   │   └─ Exit → sys_exit()
   │   └─ print_syscall_exit()       // 可视化
   ├─ 写回 a0 = result
   └─ sepc += 4
      ↓
sret 返回
   ↓
用户代码继续执行（a0 = 返回值）
```

---

### 页表映射流程
```
map_page_verbose(virt_addr, phys_addr)
   ↓
提取 VPN[2], VPN[1], VPN[0]
   ↓
第一级页表遍历：
   ├─ level1[VPN[2]] 有效？
   │   ├─ 是 → 获取下一级页表地址
   │   └─ 否 → 分配新页表，设置 level1[VPN[2]]
   ↓
第二级页表遍历：
   ├─ level2[VPN[1]] 有效？
   │   ├─ 是 → 获取下一级页表地址
   │   └─ 否 → 分配新页表，设置 level2[VPN[1]]
   ↓
第三级页表设置：
   └─ level3[VPN[0]].set(phys_addr, flags)
      ↓
可视化输出（教学）
   ↓
映射完成
```

---

## 🎯 学习建议

### 第一遍：快速通读（建议顺序）
1. **启动流程**：`main.rs` → `lib.rs` → `serial.rs` → `console.rs`
2. **中断系统**：`interrupts.rs` → `init_idt()` → `trap_handler()`
3. **内存管理**：`memory/mod.rs` → `allocator.rs`
4. **系统调用**：`syscall/mod.rs` → `syscall/syscall_impl.rs`

### 第二遍：深入理解（按功能模块）
1. **硬件抽象层**：串口驱动实现细节
2. **中断机制**：RISC-V CSR 寄存器、中断分发
3. **内存管理**：帧分配器、堆分配器、页表遍历
4. **系统调用**：参数传递、返回值处理、可视化

### 第三遍：整体架构（跟踪执行流程）
1. 用 GDB 跟踪 `kernel_main()` 执行
2. 设置断点观察中断处理
3. 单步执行系统调用流程
4. 观察页表映射过程

---

## 📝 关键问题检查清单

### 启动阶段
- [ ] 为什么需要清零 BSS 段？
- [ ] 栈是如何设置的？栈大小是多少？
- [ ] 为什么 `kernel_main()` 是 `extern "C"`？

### 输出系统
- [ ] UART 16550 的寄存器地址是什么？
- [ ] `lazy_static!` 和 `Mutex` 的作用？
- [ ] `println!` 和 `serial_println!` 有什么区别？

### 中断系统
- [ ] `stvec` 寄存器存储什么？
- [ ] `scause` 如何编码中断类型？
- [ ] 为什么定时器中断每隔一段时间触发？

### 系统调用
- [ ] `ecall` 指令做了什么？
- [ ] 系统调用参数如何传递（哪些寄存器）？
- [ ] 为什么 `sepc` 要加 4？
- [ ] 返回值通过哪个寄存器返回？

### 内存管理
- [ ] Bump Allocator 和 LinkedList Allocator 的区别？
- [ ] 为什么需要三级页表？
- [ ] 页表项的物理地址如何编码？
- [ ] 恒等映射是什么？为什么使用？

---

## 🔍 调试技巧

### 1. 添加调试输出
```rust
serial_println!("[DEBUG] variable = {:#x}", variable);
```

### 2. 使用 feature flag 控制可视化
```bash
cargo run --release --features verbose_syscall
```

### 3. 查看汇编代码
```bash
cargo objdump --release -- -d | less
```

### 4. 查看链接器布局
```bash
cargo rustc --release -- --emit=obj
riscv64-unknown-elf-objdump -h target/riscv64gc-unknown-none-elf/release/os
```

---

## 📚 参考资源

- **RISC-V 特权级架构手册**: https://riscv.org/technical/specifications/
- **Sv39 页表机制**: 特权级手册 Chapter 4.4
- **系统调用约定**: Linux RISC-V syscall ABI
- **UART 16550 规范**: http://byterunner.com/16550.html

---

**版本**: v1.0
**最后更新**: 2025-11-27
**作者**: ERROR OS 开发团队
