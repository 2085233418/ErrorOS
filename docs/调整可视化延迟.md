# 调整可视化演示的延迟时间

## 问题现象

如果你发现：
- 可视化演示运行时系统"卡住"了
- 等待时间太长
- 或者反过来，演示速度太快看不清

这是因为延迟时间需要根据你的硬件环境调整。

## 快速解决方案

### 1. 找到延迟函数定义

打开文件：`os/src/process/visualization.rs`

找到第 33-41 行左右的延迟函数：

```rust
/// 短暂延迟（用于步骤之间）
fn short_delay() {
    delay(5_000_000);  // 约 0.05 秒
}

/// 长延迟（用于演示之间）
fn long_delay() {
    delay(10_000_000);  // 约 0.1 秒
}
```

### 2. 根据你的需求调整

#### 如果演示太慢/卡住：减少循环次数

```rust
fn short_delay() {
    delay(1_000_000);   // 更快：约 0.01 秒
}

fn long_delay() {
    delay(2_000_000);   // 更快：约 0.02 秒
}
```

#### 如果演示太快看不清：增加循环次数

```rust
fn short_delay() {
    delay(20_000_000);  // 更慢：约 0.2 秒
}

fn long_delay() {
    delay(50_000_000);  // 更慢：约 0.5 秒
}
```

#### 如果不需要延迟（快速测试）：

```rust
fn short_delay() {
    delay(100_000);     // 几乎无延迟
}

fn long_delay() {
    delay(200_000);     // 几乎无延迟
}
```

### 3. 重新编译

```bash
cd os
cargo build
```

### 4. 重新运行

```bash
cargo run
```

---

## 延迟时间参考表

| 循环次数 | QEMU (虚拟机) | 真实RISC-V硬件 | 推荐场景 |
|---------|-------------|--------------|---------|
| 100,000 | ~0.001秒 | ~0.01秒 | 快速测试 |
| 1,000,000 | ~0.01秒 | ~0.1秒 | 自动化测试 |
| 5,000,000 | ~0.05秒 | ~0.5秒 | **默认（推荐）** |
| 10,000,000 | ~0.1秒 | ~1秒 | 演示之间的间隔 |
| 20,000,000 | ~0.2秒 | ~2秒 | 课堂演示 |
| 50,000,000 | ~0.5秒 | ~5秒 | 慢速讲解 |

**注意**：实际延迟时间取决于：
- CPU频率（QEMU vs 真实硬件）
- QEMU的CPU模拟速度配置
- 主机的性能

---

## 针对不同环境的推荐配置

### 环境1：QEMU虚拟机（默认配置）

```rust
fn short_delay() {
    delay(5_000_000);   // 0.05秒
}

fn long_delay() {
    delay(10_000_000);  // 0.1秒
}
```

### 环境2：真实RISC-V开发板

```rust
fn short_delay() {
    delay(500_000);     // 0.05秒
}

fn long_delay() {
    delay(1_000_000);   // 0.1秒
}
```

### 环境3：高性能主机的QEMU

```rust
fn short_delay() {
    delay(20_000_000);  // 0.2秒
}

fn long_delay() {
    delay(50_000_000);  // 0.5秒
}
```

### 环境4：课堂投影演示

```rust
fn short_delay() {
    delay(50_000_000);  // 0.5秒 - 学生能看清
}

fn long_delay() {
    delay(100_000_000); // 1秒 - 明确的分隔
}
```

---

## 完全禁用延迟（仅测试功能）

如果你只想验证功能是否正常，不关心可视化效果：

### 方法1：最小延迟

```rust
fn short_delay() {
    delay(1);  // 几乎无延迟
}

fn long_delay() {
    delay(1);  // 几乎无延迟
}
```

### 方法2：注释掉延迟（推荐）

```rust
fn short_delay() {
    // delay(5_000_000);  // 完全禁用
}

fn long_delay() {
    // delay(10_000_000);  // 完全禁用
}
```

这样所有演示会立即完成，适合：
- 自动化测试
- CI/CD流水线
- 快速验证功能

---

## 为什么会"卡住"？

### 原因1：延迟时间设置过大

如果 `delay()` 的循环次数过大（如 100,000,000），在某些环境下可能需要几秒甚至几十秒才能完成。

### 原因2：QEMU配置问题

QEMU的CPU模拟速度受主机性能影响。检查QEMU配置：

```bash
# 查看当前QEMU配置
cat os/.cargo/config.toml
```

如果看到 `-smp 1`（单核），可以尝试增加核心数：

```toml
runner = """qemu-system-riscv64 \
    -machine virt \
    -cpu rv64 \
    -smp 2 \       # 改为2核
    -m 128M \
    ...
```

### 原因3：无限循环或死锁

如果调整延迟后仍然卡住，可能是代码逻辑问题。使用GDB调试：

```bash
# 终端1：启动QEMU等待GDB连接
cargo run -- -s -S

# 终端2：连接GDB
riscv64-unknown-elf-gdb target/riscv64imac-unknown-none-elf/debug/os \
    -ex "target remote :1234" \
    -ex "continue"
```

按 Ctrl+C 暂停，然后查看当前位置：
```gdb
(gdb) backtrace
(gdb) info registers
```

---

## 动态调整延迟（高级）

如果希望根据环境自动调整延迟，可以添加一个校准函数：

```rust
/// 校准延迟，使1单位 ≈ 0.01秒
fn calibrate_delay() -> u32 {
    // 读取CPU频率（需要实现）
    // 或使用预定义的值

    #[cfg(feature = "fast-delay")]
    return 1_000_000;  // 快速模式

    #[cfg(not(feature = "fast-delay"))]
    return 5_000_000;  // 正常模式
}

static mut DELAY_MULTIPLIER: u32 = 0;

fn short_delay() {
    unsafe {
        if DELAY_MULTIPLIER == 0 {
            DELAY_MULTIPLIER = calibrate_delay();
        }
        delay(DELAY_MULTIPLIER);
    }
}
```

然后在编译时选择：

```bash
# 快速模式
cargo run --features fast-delay

# 正常模式
cargo run
```

---

## 总结

**最简单的解决方案**：

1. 打开 `os/src/process/visualization.rs`
2. 修改第34行和第39行的数字
3. 数字越小 = 延迟越短 = 演示越快
4. 数字越大 = 延迟越长 = 演示越慢
5. 重新编译运行

**推荐起点**：
- 如果"卡住"：先改为 `1_000_000`（减少5倍）
- 如果还是慢：再改为 `100_000`（减少50倍）
- 如果太快：逐步增大到合适的值

找到适合你环境的延迟时间后，记录下来供以后使用。
