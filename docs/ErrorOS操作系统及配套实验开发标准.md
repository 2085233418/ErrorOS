# ErrorOS 操作系统及配套实验开发标准

**版本**: v1.0
**日期**: 2025年11月26日
**适用范围**: 全国大学生计算机系统能力大赛操作系统设计赛道

---

## 前言：我们要解决什么问题？

在开始工作前，团队所有成员**必须**阅读 [lab_guide_introduction.md](lab_guide_introduction.md)，深刻理解：

### ERROR OS 的核心理念

**ERROR = Enhanced RISC-V Real-time Operating System with Observability and Reflection**

我们的系统解决了传统操作系统教学的**三大痛点**：

1. **过程不可见** → 我们提供**实时可视化**追踪
2. **调试困难** → 我们尽量提供**详细的错误反馈**和状态展示
3. **理论与实践脱节** → 我们让学生**"看见"代码运行过程**

### 教学特色（必须贯彻到所有工作中）

- ✅ **过程可见**：每个关键操作都有可视化输出
- ✅ **渐进式学习**：从简单到复杂，步步为营
- ✅ **错误即教材**：错误信息本身就是学习机会
- ✅ **理论与实践结合**：代码输出直接对应理论课知识点

---

## 总体任务划分

本项目包含**三大核心任务**，必须按照以下标准完成：

### 任务一：操作系统开发
- **负责人**：魏思阳
- **任务**：完成 ERROR OS 内核的核心功能开发
- **其他成员**：无需参与，但需理解系统架构

### 任务二：实验指导书编写（含系统阶段测试）
- **负责人**：周晨（0-3章）、王鹤（4-5章）、魏思阳（6-7章）
- **任务**：编写详细的实验指导书，让学生能够从零复刻 ERROR OS
- **核心要求**：确保学生按照指导书能写出与"阶段最终形态"**完全一致**的代码

### 任务三：章节配套练习
- **负责人**：全体成员
- **任务**：为每个章节设计练习题，检验学生掌握情况
- **要求**：练习题必须有自动化测试和可视化反馈

---

## 一、操作系统开发标准

### 1.1 开发流程

开发由魏思阳完成，其他成员**无需参与代码开发**，但需注意以下事项：

#### ⚠️ 重要提醒

魏思扬推送的代码中包含：
- ✅ 核心功能代码
- 🧪 各种测试代码
- 🔍 可视化尝试代码
- 🚧 调试用的临时代码

**这些代码混杂在一起，不能直接用于教学！**

### 1.2 代码清理标准

在开始编写实验指导书前，**必须**完成以下清理工作：

#### Step 1: 清除无用代码

**必须清除的内容**：
```rust
// ❌ 删除所有测试代码
#[test]
fn test_something() { ... }

// ❌ 删除调试输出
println!("DEBUG: xxx");
serial_println!("[DEBUG] xxx");

// ❌ 删除临时的可视化尝试
```

**必须保留的内容**：
```rust
// ✅ 保留核心功能代码
pub fn syscall_dispatcher(...) { ... }

// ✅ 保留必要的注释
/// 系统调用分发器
///
/// # 参数
/// - `context`: 系统调用上下文

```

#### Step 2: 整理代码注释

**注释分类原则**：

1. **功能注释**（必须保留）
   ```rust
   /// 初始化中断描述符表
   ///
   /// # 功能
   /// - 设置 stvec 寄存器
   /// - 初始化异常处理函数
   pub fn init_idt() { ... }
   ```

2. **实现细节注释**（后期移至附录）
   
   ```rust
   // 详细解释：RISC-V 的 stvec 寄存器有两种模式：
   // - Direct 模式 (MODE=0): 所有异常跳转到 BASE 地址
   // - Vectored 模式 (MODE=1): 中断跳转到 BASE+4*cause
   //
   // 我们使用 Direct 模式，因为...
   //
   // 📝 注：此部分详细解释已移至附录 A.2.3
   ```
   
3. **架构相关注释**（逐适量大则移至附录）
   
   ```rust
   // RISC-V Sv39 页表结构：
   // 虚拟地址 [38:30] → VPN[2] (9位)
   // 虚拟地址 [29:21] → VPN[1] (9位)
   // 虚拟地址 [20:12] → VPN[0] (9位)
   // 虚拟地址 [11:0]  → 页内偏移 (12位)
   //
   // 📝 注：完整的 RISC-V 页表机制请参考附录 A.4
   ```

**注释编写原则**：
- ✅ **主代码中的注释**：简洁明了，点到为止，告诉学生"做什么"和"为什么"
- ✅ **附录中的注释**：详细深入，解释"怎么做"和底层原理
- ❌ **避免**：在主代码中堆砌过多细节，干扰学生理解主线逻辑

### 1.3 代码分阶段整理

#### 阶段划分示例

**周晨负责的阶段（第0-3章）**：

| 阶段名称 | 初始状态 | 最终形态 | 代码行数 | 时间估计 |
|---------|---------|---------|---------|---------|
| 第0章 | `cargo init` 后的项目结构 | 环境配置完成，能够编译运行 | ~200 | 1天 |
| 第1章 | 第0章最终形态 | 实现串口输出和 `println!` 宏 | ~400 | 2天 |
| 第2章 | 第1章最终形态 | 实现中断系统 | ~600 | 3天 |
| 第3章 | 第2章最终形态 | 实现物理内存管理和堆分配 | ~800 | 3天 |
| **总计** | `cargo init` | 系统调用实现前的状态 | ~2000 | 9天 |

**王鹤负责的阶段（第4-5章）**：

| 阶段名称 | 初始状态 | 最终形态 | 代码行数 | 时间估计 |
|---------|---------|---------|---------|---------|
| 第4章 | 周晨的最终形态（第3章末） | 实现虚拟内存管理（Sv39） | ~1000 | 5天 |
| 第5章 | 第4章最终形态 | 实现系统调用机制 | ~600 | 3天 |
| **总计** | 第3章末 | 当前系统完成度 | ~1600 | 8天 |

#### 阶段验收标准

每个阶段完成后，必须满足以下条件：

✅ **功能完整性**：
- 该阶段的所有功能点都已实现
- 所有代码都能编译通过
- 在 QEMU 中运行正常

✅ **代码质量**：
- 无测试代码、调试输出
- 注释清晰完整
- 代码格式统一（使用 `cargo fmt`）

✅ **可视化准备**：
- 关键函数的可视化输出函数已编写（放在同级目录）
- 可视化函数使用 `#[cfg(test)]` 或 feature flag 控制
- 提供测试示例，确保可视化输出正确

✅ **文档齐全**：
- 该阶段的实现文档已完成
- 包含设计思路、实现细节、测试结果
- 列出可能的考查点

#### 阶段交接流程

**提交清单**（每个阶段完成后）：

```
周晨的第0-3章交接包/
├── code/
│   ├── chapter0_initial/     # 第0章初始状态
│   ├── chapter0_final/        # 第0章最终形态
│   ├── chapter1_final/        # 第1章最终形态
│   ├── chapter2_final/        # 第2章最终形态
│   └── chapter3_final/        # 第3章最终形态（= 周晨的最终交付）
├── docs/
│   ├── chapter0_implementation.md
│   ├── chapter1_implementation.md
│   ├── chapter2_implementation.md
│   └── chapter3_implementation.md
├── visualization/
│   ├── chapter1_uart_visual.rs
│   ├── chapter2_interrupt_visual.rs
│   └── chapter3_memory_visual.rs
└── README.md              # 交接说明
```

**王鹤接收时的验证**：

```bash
# 1. 验证代码能够编译运行
cd chapter3_final
cargo build --release
cargo run --release

# 2. 验证可视化功能
cargo run --release --features verbose_syscall

# 3. 验证测试通过
cargo test

# 4. 验证文档完整性
ls docs/*.md  # 应该有4个文档
```

**以此类推，确保工作可以无缝拼接！**

### 1.4 Git 分支管理

#### 分支命名规范

```
main                    # 魏思扬的开发主分支（仅魏思扬使用）
  ├── zhouchen/ch0-3   # 周晨的工作分支（第0-3章）
  │   ├── zhouchen/ch0      # 第0章子分支
  │   ├── zhouchen/ch1      # 第1章子分支
  │   ├── zhouchen/ch2      # 第2章子分支
  │   └── zhouchen/ch3      # 第3章子分支
  └── wanghe/ch4-5     # 王鹤的工作分支（第4-5章）
      ├── wanghe/ch4        # 第4章子分支
      └── wanghe/ch5        # 第5章子分支
```

#### 提交规范

**Commit 消息格式**：

```
[章节] 类型: 简短描述

详细说明（可选）

示例：
[Ch1] feat: 实现 UART 串口驱动
[Ch2] docs: 完成中断系统实验指导书
[Ch3] fix: 修复堆分配器的边界检查错误
[Ch4] test: 添加页表遍历可视化测试
```

**类型标签**：
- `feat`: 新功能
- `docs`: 文档更新
- `fix`: Bug 修复
- `test`: 测试代码
- `refactor`: 代码重构
- `style`: 代码格式调整

#### 提交频率

- ⏰ **小节完成时**：完成一个小节（如 1.2、1.3）后立即提交
- ⏰ **阶段完成时**：完成整个章节后，提交到 GitHub 仓库
- ⏰ **里程碑完成时**：完成多个章节的阶段性总结后，提交到比赛仓库

---

## 二、实验指导书编写标准

### 2.1 核心要求

#### 🎯 最高原则

**学生按照指导书编写的代码，必须与"阶段最终形态"的代码完全一致！**

这意味着：
- ✅ 函数签名完全相同
- ✅ 变量命名完全相同
- ✅ 代码逻辑完全相同

**为什么要这样？**

因为只有这样，学生才能：
1. 调用我们提供的可视化函数（参数类型必须匹配）
2. 通过我们提供的自动化测试（代码行为必须一致）
3. 无缝衔接到下一章节的学习

### 2.2 写作风格

#### 语言要求

**专业但不枯燥**：

```markdown
❌ 错误示例（过于学术化）：
在 RISC-V 架构中，系统调用通过 ecall 指令触发特权级切换，
从用户态（U-mode）陷入到监管态（S-mode），
同时硬件会自动保存 PC 到 sepc 寄存器，
并根据 stvec 寄存器的值跳转到异常处理入口...

✅ 正确示例（专业且易懂）：
当用户程序需要请求内核服务时（比如写文件），它会执行 ecall 指令。
这个指令会触发一个"系统调用异常"，让 CPU 从用户态切换到内核态。

就像你去银行办业务，ecall 就是你按下的"叫号键"：
- 你的位置被记录下来（PC 保存到 sepc）
- 你被引导到柜台（跳转到 stvec 指定的地址）
- 柜员开始为你服务（内核处理你的请求）

下面我们来实现这个过程...
```

#### 讲解深度

**清晰详细但适度**：

| 内容类型 | 讲解深度 | 示例 |
|---------|---------|------|
| 核心概念 | 深入讲解 | 什么是系统调用？为什么需要系统调用？ |
| 实现步骤 | 详细说明 | 如何实现 `syscall_dispatcher` 函数？ |
| 架构细节 | 点到为止 | RISC-V 有 a0-a7 寄存器，用于传递参数 |
| 底层原理 | 简要提及 | 具体的寄存器编码请参考附录 |

**深挖与简述的界限**：

```markdown
✅ 主文中（适度讲解）：
我们使用 a0-a2 三个寄存器来传递系统调用的参数。
比如 sys_write(fd, buffer, length)：
- a0 = 文件描述符 (fd)
- a1 = 缓冲区指针 (buffer)
- a2 = 写入长度 (length)

📝 详细的 RISC-V 调用约定请参考附录 A.3

❌ 主文中不要出现（过于深入）：
RISC-V 调用约定规定：
- a0-a7 (x10-x17) 用于传递参数和返回值
- a0-a1 用于返回值
- a2-a7 仅用于参数传递
- ra (x1) 保存返回地址
- sp (x2) 保存栈指针
- gp (x3) 保存全局指针
- tp (x4) 保存线程指针
- t0-t6 (x5-x7, x28-x31) 为临时寄存器
... （这些放到附录）
```

### 2.3 内容组织结构

#### 章节页面结构

**每个章节的标准结构**：

```markdown
# 第X章：章节标题

## 章节说明页

### 本章学习目标
- [ ] 学习目标1
- [ ] 学习目标2
- [ ] 学习目标3

### 理论课对应知识点
- 理论课第X讲：知识点1
- 理论课第Y讲：知识点2

### 本章代码量
- 预计新增代码：约XXX行
- 预计学习时间：X-X小时

### 技术路线图
（一张图展示本章的技术架构）

---

## X.1 第一小节标题

### 为什么需要这个功能？
（动机介绍）

### 设计思路
（先讲"做什么"）

### 实现步骤

#### Step 1: 准备工作
（环境准备、依赖检查）

#### Step 2: 核心实现
（手把手教写代码）

```rust
// 完整的代码示例
pub fn example_function() {
    // 详细注释
}
```

#### Step 3: 测试验证
（如何运行测试）

```bash
cargo run --release
```

#### Step 4: 可视化观察
（调用可视化函数查看输出）

```rust
#[test]
fn test_example_visual() {
    // 可视化测试代码
}
```

### 预期输出
（展示正确的输出结果）

```
╔════════════════════════════════════════╗
║     示例可视化输出                     ║
╠════════════════════════════════════════╣
║ 参数: xxx
║ 结果: xxx
╚════════════════════════════════════════╝
```

### 常见错误与解决
（列出学生可能遇到的问题）

---

## X.2 第二小节标题
（结构同上）

---

## 本章总结

### 知识点回顾
- 知识点1：说明
- 知识点2：说明

### 下一章预告
下一章我们将学习...

---

## 本章习题

### 习题 X.1：基础题
（题目描述）

**提示**：
- 提示1
- 提示2

**测试命令**：
```bash
cargo test test_exercise_x1 -- --nocapture
```

**预期输出**：
```
（展示正确的测试输出）
```

### 习题 X.2：进阶题
（题目描述）

---
```

#### 页面划分原则

**一个小节一个页面**，除非：
- ❌ 小节内容过长（超过500行）→ 拆分成多个页面
- ✅ 小节内容过短（少于100行）→ 合并到前一个页面

### 2.4 可视化代码组织

#### 可视化函数的位置

**开发阶段**（当前）：
```
os/src/
├── syscall/
│   ├── mod.rs              # 核心代码
│   ├── syscall_impl.rs     # 系统调用实现
│   └── visualization.rs    # 可视化函数（新建）
```

**最终阶段**（统一移植后）：
```
os/
├── src/              # 核心内核代码
└── visual/           # 可视化代码（统一管理）
    ├── syscall_visual.rs
    ├── memory_visual.rs
    └── interrupt_visual.rs
```

#### 可视化函数示例

**文件**：`os/src/syscall/visualization.rs`

```rust
/*
 * ============================================
 * 系统调用可视化模块
 * ============================================
 * 功能：提供系统调用过程的可视化输出
 *
 * 使用方式：
 * 1. 学生完成 syscall_dispatcher 实现后
 * 2. 调用 test_syscall_visual() 查看可视化输出
 * 3. 通过观察输出理解系统调用的参数传递过程
 * ============================================
 */

use super::{SyscallContext, SyscallId, syscall_dispatcher};
use crate::serial_println;

/// 测试并可视化系统调用过程
///
/// # 功能
/// - 测试 sys_getpid, sys_write, sys_exit
/// - 显示每个系统调用的参数和返回值
/// - 帮助学生理解系统调用机制
#[cfg(test)]
pub fn test_syscall_visual() {
    serial_println!("\n╔════════════════════════════════════════╗");
    serial_println!("║   系统调用可视化测试                   ║");
    serial_println!("╠════════════════════════════════════════╣");

    // 测试1: sys_getpid
    test_sys_getpid_visual();

    // 测试2: sys_write
    test_sys_write_visual();

    // 测试3: 无效系统调用
    test_invalid_syscall_visual();

    serial_println!("╚════════════════════════════════════════╝\n");
}

#[cfg(test)]
fn test_sys_getpid_visual() {
    serial_println!("║ [测试1] sys_getpid");
    serial_println!("╠────────────────────────────────────────╣");

    let context = SyscallContext {
        syscall_id: 172,  // GetPid
        arg0: 0,
        arg1: 0,
        arg2: 0,
        arg3: 0,
        arg4: 0,
        arg5: 0,
        sepc: 0,
    };

    let result = syscall_dispatcher(&context);

    serial_println!("║ ✓ 返回 PID: {}", result);
}

// 更多可视化测试函数...
```

#### 可视化函数的使用方式

**在实验指导书中的说明**：

```markdown
### Step 4: 测试你的实现

现在你已经完成了 `syscall_dispatcher` 函数的编写，
让我们通过可视化输出来验证它是否正确工作！

运行以下命令：

```bash
cargo test test_syscall_visual -- --nocapture
```

你应该看到类似下面的输出：

```
╔════════════════════════════════════════╗
║   系统调用可视化测试                   ║
╠════════════════════════════════════════╣
║ [测试1] sys_getpid
╠────────────────────────────────────────╣
║ 调用号: GetPid (172)
║ 参数: a0=0, a1=0, a2=0
║ ✓ 返回 PID: 1
╠────────────────────────────────────────╣
║ [测试2] sys_write
╠────────────────────────────────────────╣
║ 调用号: Write (64)
║ 参数: a0=1 (stdout), a1=0x..., a2=20
Hello from syscall!
║ ✓ 成功写入 20 字节
╚════════════════════════════════════════╝
```

**观察要点**：

1. **系统调用号识别**：你看到 `GetPid (172)` 了吗？这说明你的 `syscall_id` 解析正确
2. **参数传递**：注意观察 a0, a1, a2 的值，它们是如何传递给系统调用的
3. **返回值**：`sys_getpid` 返回 1，表示当前进程 ID 是 1

如果输出与上面不符，请检查：
- [ ] `syscall_dispatcher` 中的 match 分支是否正确
- [ ] 参数是否正确从 context 中读取
- [ ] 返回值是否正确返回
```

### 2.5 习题设计标准

#### 习题布置位置

每个小节后**立即**布置相关习题，而不是放在章节末尾。

#### 习题难度分级

每个小节应包含 **2-3 道习题**，覆盖不同难度：
以下仅为示例，具体请结合自身开发情况设置

| 难度 | 题目类型 | 占比 | 示例 |
|------|---------|------|------|
| ⭐ 基础 | 理解概念 | 50% | 说明 sys_getpid 的功能和返回值 |
| ⭐⭐ 应用 | 修改代码 | 30% | 实现 sys_getppid (获取父进程ID) |
| ⭐⭐⭐ 拓展 | 设计功能 | 20% | 设计一个支持更多参数的系统调用 |

#### 习题示例（完整格式）

```markdown
### 习题 5.1.1：理解系统调用号 ⭐

**题目**：

请回答以下问题：

1. 在 RISC-V 中，系统调用号存储在哪个寄存器？
2. ERROR OS 中，`sys_write` 的系统调用号是多少？
3. 为什么需要系统调用号？直接调用内核函数不行吗？

**提示**：
- 回顾 `SyscallContext` 结构体的定义
- 思考用户态和内核态的隔离性

**参考答案**：

<details>
<summary>点击查看答案</summary>

1. 系统调用号存储在 **a7 寄存器**
2. `sys_write` 的系统调用号是 **64**（Linux 兼容）
3. 需要系统调用号的原因：
   - 用户态不能直接调用内核函数（权限隔离）
   - 系统调用号是用户态与内核态通信的"协议"
   - 通过系统调用号，内核可以识别用户想要什么服务

</details>

---

### 习题 5.1.2：实现 sys_getppid ⭐⭐

**题目**：

参考 `sys_getpid` 的实现，完成 `sys_getppid` 系统调用，用于获取**父进程 ID**。

**要求**：
- 系统调用号：173（Linux 兼容）
- 返回值：父进程 PID（简化实现，返回固定值 0）
- 支持可视化输出

**代码框架**：

```rust
// 文件：os/src/syscall/syscall_impl.rs

/// 获取父进程 ID
///
/// # 返回
/// 父进程 PID
pub fn sys_getppid() -> isize {
    // TODO: 实现这个函数
    // 提示：参考 sys_getpid 的实现
}
```

**测试命令**：

```bash
cargo test test_sys_getppid -- --nocapture
```

**预期输出**：

```
╔════════════════════════════════════════╗
║     系统调用追踪                       ║
╠════════════════════════════════════════╣
║ 调用号: GetPPid (173)
║ PC: 0x0
╠════════════════════════════════════════╣
║ 参数:                                  ║
║   a0 (arg0) = 0x0
║   a1 (arg1) = 0x0
║   a2 (arg2) = 0x0
╠════════════════════════════════════════╣
║ 返回值: 0 (0x0)
╚════════════════════════════════════════╝

✓ 测试通过
```

**完整答案**：

<details>
<summary>点击查看答案</summary>

```rust
// 文件：os/src/syscall/syscall_impl.rs

/// 获取父进程 ID
///
/// # 返回
/// 父进程 PID（简化实现，返回 0）
pub fn sys_getppid() -> isize {
    serial_println!("[SYSCALL] sys_getppid called");

    // 简化实现：返回固定值 0
    // 实际操作系统需要从进程控制块中读取父进程 PID
    let ppid = 0;

    serial_println!("[SYSCALL] → parent PID: {}", ppid);
    ppid
}
```

**修改 `SyscallId` 枚举**：

```rust
// 文件：os/src/syscall/mod.rs

#[repr(usize)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum SyscallId {
    Write = 64,
    Exit = 93,
    GetPid = 172,
    GetPPid = 173,  // 新增
    Unknown = 9999,
}

impl From<usize> for SyscallId {
    fn from(id: usize) -> Self {
        match id {
            64 => SyscallId::Write,
            93 => SyscallId::Exit,
            172 => SyscallId::GetPid,
            173 => SyscallId::GetPPid,  // 新增
            _ => SyscallId::Unknown,
        }
    }
}
```

**修改 `syscall_dispatcher`**：

```rust
// 文件：os/src/syscall/mod.rs

pub fn syscall_dispatcher(context: &SyscallContext) -> isize {
    let syscall_id = SyscallId::from(context.syscall_id);

    // ... 可视化输出 ...

    let result = match syscall_id {
        SyscallId::Write => { /* ... */ },
        SyscallId::Exit => { /* ... */ },
        SyscallId::GetPid => { /* ... */ },
        SyscallId::GetPPid => {  // 新增
            syscall_impl::sys_getppid()
        },
        SyscallId::Unknown => { /* ... */ },
    };

    // ... 可视化输出 ...

    result
}
```

</details>

---

### 习题 5.1.3：思考题 ⭐⭐⭐

**题目**：

思考以下问题（开放性问题，无标准答案）：

1. 如果系统调用参数超过 6 个（a0-a5 不够用），应该如何传递？
2. 为什么 ERROR OS 选择 Linux 兼容的系统调用号，而不是自定义？
3. 如果系统调用号冲突（两个系统调用使用了相同的号码），会发生什么？

**讨论提示**：
- 查阅 Linux 和 xv6 的实现方式
- 思考兼容性和可移植性
- 考虑错误处理机制

**参考思路**：

<details>
<summary>点击查看参考思路</summary>

1. **参数超过 6 个的解决方案**：
   - 方案1：使用**栈传递**（用户态压栈，内核态读栈）
   - 方案2：使用**结构体指针**（a0 指向包含所有参数的结构体）
   - Linux 采用方案2，因为更安全且易于验证

2. **选择 Linux 兼容系统调用号的原因**：
   - ✅ **可移植性**：用户程序可以在 ERROR OS 和 Linux 之间移植
   - ✅ **工具链支持**：现有的工具（如 strace）可以直接使用
   - ✅ **学习成本低**：学生学到的知识可以直接应用到 Linux
   - ❌ 缺点：必须遵循 Linux 的接口设计，灵活性受限

3. **系统调用号冲突的后果**：
   - 在 `syscall_dispatcher` 中，只有第一个匹配的分支会执行
   - 后续的冲突系统调用永远不会被调用
   - 这是一个**严重的设计错误**，必须通过测试发现并修复

</details>

---
```

#### 自动化测试框架

**测试函数模板**：

```rust
// 文件：os/tests/exercise_5_1_2.rs

#![no_std]
#![no_main]
#![feature(custom_test_frameworks)]
#![test_runner(os::test_runner)]
#![reexport_test_harness_main = "test_main"]

use os::{serial_print, serial_println};
use os::syscall::{test_syscall, SyscallId};

#[no_mangle]
pub extern "C" fn _start() -> ! {
    os::init();
    test_main();
    os::hlt_loop();
}

#[panic_handler]
fn panic(info: &core::panic::PanicInfo) -> ! {
    os::test_panic_handler(info)
}

#[test_case]
fn test_sys_getppid() {
    serial_print!("testing sys_getppid... ");

    // 调用系统调用
    let result = test_syscall(173, 0, 0, 0);

    // 验证返回值
    assert_eq!(result, 0, "sys_getppid should return 0");

    serial_println!("[ok]");
}

#[test_case]
fn test_sys_getppid_visual() {
    serial_println!("\n╔════════════════════════════════════════╗");
    serial_println!("║   sys_getppid 可视化测试               ║");
    serial_println!("╠════════════════════════════════════════╣");

    let result = test_syscall(173, 0, 0, 0);

    serial_println!("║ ✓ 返回父进程 PID: {}", result);
    serial_println!("╚════════════════════════════════════════╝\n");
}
```

**答案验证标准**：

✅ **功能正确**：
- 测试通过（`cargo test` 无错误）
- 返回值符合预期

✅ **可视化输出**：
- 输出格式美观
- 信息完整清晰

✅ **代码质量**：
- 代码风格一致（通过 `cargo fmt`）
- 注释清晰完整

### 2.6 章节说明页

每个章节开始前，必须有一个**章节说明页**，告诉学生：
- 本章要学什么
- 为什么要学
- 如何学
- 对应的理论课知识点

#### 章节说明页模板

```markdown
# 第5章：系统调用

---

## 📖 章节说明

### 本章学习目标

完成本章后，你将能够：

- [ ] 理解系统调用的机制和作用
- [ ] 实现 RISC-V 的系统调用处理流程
- [ ] 掌握 ecall 指令的使用
- [ ] 实现 3 个基础系统调用（write, exit, getpid）
- [ ] 理解用户态与内核态的切换过程

### 理论课对应知识点

本章内容对应以下理论课知识点：

| 理论课 | 知识点 | 说明 |
|--------|--------|------|
| 第4讲 | 系统调用机制 | 用户态如何请求内核服务 |
| 第4讲 | 特权级切换 | U-mode ↔ S-mode 切换 |
| 第5讲 | 异常处理 | ecall 指令触发的异常 |
| 第6讲 | 寄存器约定 | RISC-V 调用约定 (a0-a7) |

**建议**：学习本章前，请先复习理论课第4-6讲内容。

### 本章技术路线

```
用户程序                     内核态
   │                          │
   │  1. ecall 指令           │
   ├─────────────────────────>│
   │                          │
   │                   2. 保存上下文
   │                    (sepc, 寄存器)
   │                          │
   │                   3. syscall_dispatcher
   │                    识别系统调用号 (a7)
   │                          │
   │                   4. 调用具体实现
   │                    sys_write / sys_exit / sys_getpid
   │                          │
   │                   5. 设置返回值 (a0)
   │                          │
   │                   6. sret 返回
   │<─────────────────────────┤
   │                          │
   │  7. 继续执行             │
   └─                         └─
```

### 本章代码量

- **预计新增代码**：约 600 行
- **核心文件**：
  - `os/src/syscall/mod.rs` (约 200 行)
  - `os/src/syscall/syscall_impl.rs` (约 200 行)
  - `os/src/interrupts/trap.rs` (新增 ecall 处理，约 100 行)
  - 可视化和测试代码 (约 100 行)
- **预计学习时间**：6-8 小时

### 本章亮点 ✨

**ERROR OS 特色：看得见的系统调用**

传统操作系统教学中，学生很难"看到"系统调用的过程。
在 ERROR OS 中，我们提供了**实时可视化追踪**：

```
╔════════════════════════════════════════╗
║     系统调用追踪                       ║
╠════════════════════════════════════════╣
║ 调用号: Write (64)
║ PC: 0x80200abc
╠════════════════════════════════════════╣
║ 参数:                                  ║
║   a0 (arg0) = 0x1       ← stdout
║   a1 (arg1) = 0x...     ← 缓冲区
║   a2 (arg2) = 0x5       ← 长度5
╠════════════════════════════════════════╣
Hello                     ← 实际输出
║ 返回值: 5 (0x5)
╚════════════════════════════════════════╝
```

你将**亲眼看到**：
- 系统调用号如何传递（a7 寄存器）
- 参数如何传递（a0-a5 寄存器）
- 返回值如何返回（a0 寄存器）
- 内核如何处理用户请求

### 学习建议

1. **按顺序学习**：系统调用的实现环环相扣，请按小节顺序学习
2. **动手实践**：每个小节都有代码示例，请务必动手输入（而不是复制粘贴）
3. **观察输出**：充分利用可视化功能，观察系统调用的执行过程
4. **完成习题**：每个小节后都有习题，确保掌握知识点
5. **理论联系实践**：对照理论课内容，理解代码背后的原理

### 常见困难与解决

| 可能遇到的困难 | 解决方法 |
|---------------|---------|
| 不理解 ecall 指令 | 复习理论课第5讲，参考附录 A.4.1 |
| 寄存器太多记不住 | 使用附录 A.5 的速查表 |
| 系统调用号混淆 | 参考 `SyscallId` 枚举定义 |
| 测试不通过 | 对比"阶段最终形态"的代码 |
| 可视化输出不正确 | 检查 feature flag 是否启用 |

### 下一章预告

完成系统调用机制后，第6章我们将学习**进程管理**：
- 进程控制块 (PCB)
- 上下文切换
- 进程调度（Round-Robin）
- fork / exec / exit / wait

进程管理是操作系统的核心，也是最有挑战性的部分。
掌握了系统调用，你将为进程管理打下坚实的基础！

---

**准备好了吗？让我们开始第5章的学习吧！** 🚀
```

---

## 三、其他注意事项

### 3.1 质量标准

#### 代码质量

- ✅ 使用 `cargo fmt` 格式化所有代码
- ✅ 使用 `cargo clippy` 检查代码质量
- ✅ 所有 `unsafe` 代码必须有详细注释说明为什么安全
- ✅ 所有 `pub` 函数必须有文档注释（`///`）

#### 文档质量

- ✅ 无错别字（使用拼写检查工具）
- ✅ 代码示例必须能够编译运行
- ✅ 所有命令必须经过实际测试
- ✅ 所有输出必须是真实的运行结果（不要编造）

#### 测试覆盖

- ✅ 每个章节至少有 3 个测试用例
- ✅ 每个习题都有对应的自动化测试
- ✅ 可视化输出必须经过验证

### 3.2 时间节点

#### 整体时间规划

| 阶段 | 负责人 | 时间 | 交付物 |
|------|--------|------|--------|
| 第0-3章 | 周晨 | 第1-15天 | 代码 + 文档 + 测试 |
| 第4-5章 | 王鹤 | 第16-25天 | 代码 + 文档 + 测试 |
| 集成测试 | 全体 | 第26-30天 | 完整系统测试 |
| 答辩准备 | 全体 | 第31-40天 | PPT + 演示视频 |

#### 每周检查点

**每周周末**：进度汇报会议

**汇报内容**：
1. 本周完成的工作（具体到小节）
2. 遇到的问题和解决方案
3. 下周计划
4. 需要其他成员协助的事项

### 3.3 沟通协作

#### 工作群规则

- 📢 **重要通知**：使用 `@全体成员`
- 💬 **日常讨论**：随时交流，及时回复
- 📁 **文件共享**：使用 GitHub，不要用微信传文件
- ⏰ **响应时间**：尽快

#### 遇到问题怎么办？

**问题处理流程**：

1. **自己先尝试解决**（查文档、搜索、调试）
2. **记录问题**（截图、错误信息、尝试过的方法）
3. **在群里提问**（清晰描述问题，提供上下文）
4. **解决后总结**（记录到 FAQ 文档）

**提问模板**：

```
【问题】：简短描述问题（一句话）

【背景】：
- 正在做什么（哪个章节、哪个小节）
- 想要实现什么功能

【现象】：
- 具体的错误信息（粘贴完整错误）
- 截图（如果需要）

【已尝试】：
- 尝试了哪些方法
- 查阅了哪些资料
- 为什么没有解决

【环境】：
- Rust 版本
- QEMU 版本
- 操作系统版本
```

### 3.4 质量检查清单

#### 提交前自检

**代码检查**：
- [ ] 运行 `cargo fmt`
- [ ] 运行 `cargo clippy`
- [ ] 运行 `cargo build --release`
- [ ] 运行 `cargo test`
- [ ] 在 QEMU 中实际运行测试

**文档检查**：
- [ ] 所有代码示例能够编译
- [ ] 所有命令能够正常执行
- [ ] 所有输出是真实的运行结果
- [ ] 无错别字和语法错误
- [ ] 格式统一（标题、代码块、表格）

**测试检查**：
- [ ] 所有测试用例通过
- [ ] 可视化输出正确
- [ ] 习题答案验证通过

#### Peer Review

**每个阶段完成后**，由另一位成员进行代码审查：

**审查清单**：
- [ ] 代码逻辑正确
- [ ] 注释清晰完整
- [ ] 命名规范统一
- [ ] 无安全隐患（unsafe 使用合理）
- [ ] 可视化输出清晰
- [ ] 文档与代码一致

```markdown

```

---

## 四、附录

### 附录 A：代码规范

#### A.1 命名规范

| 类型 | 规范 | 示例 |
|------|------|------|
| 模块 | snake_case | `syscall`, `memory` |
| 结构体 | PascalCase | `SyscallContext`, `PageTable` |
| 枚举 | PascalCase | `SyscallId`, `ProcessState` |
| 函数 | snake_case | `syscall_dispatcher`, `map_page` |
| 常量 | SCREAMING_SNAKE_CASE | `MAX_PROCESSES`, `PAGE_SIZE` |
| 变量 | snake_case | `syscall_id`, `page_table` |

#### A.2 注释规范

```rust
/// 系统调用分发器
///
/// # 功能
/// - 根据系统调用号分发到具体的系统调用实现
/// - 支持可选的可视化输出
///
/// # 参数
/// - `context`: 系统调用上下文，包含系统调用号和参数
///
/// # 返回
/// 系统调用的返回值（通过 a0 寄存器返回给用户态）
///
/// # 示例
/// ```
/// let context = SyscallContext { ... };
/// let result = syscall_dispatcher(&context);
/// ```
///
/// # 安全性
/// 此函数假设 `context` 中的参数已经过验证
pub fn syscall_dispatcher(context: &SyscallContext) -> isize {
    // 实现...
}
```

#### A.3 错误处理规范

```rust
// ✅ 正确：明确的错误处理
pub fn map_page(virt_addr: VirtAddr, phys_addr: PhysAddr) -> Result<(), MapError> {
    if !virt_addr.is_aligned(PAGE_SIZE) {
        return Err(MapError::UnalignedAddress);
    }
    // ...
    Ok(())
}

// ❌ 错误：使用 panic
pub fn map_page(virt_addr: VirtAddr, phys_addr: PhysAddr) {
    assert!(virt_addr.is_aligned(PAGE_SIZE), "Address not aligned");
    // ...
}
```

### 附录 B：常用命令

```bash
# 编译
cargo build --release

# 运行
cargo run --release

# 运行（带可视化）
cargo run --release --features verbose_syscall

# 测试
cargo test

# 测试（带输出）
cargo test -- --nocapture

# 格式化代码
cargo fmt

# 代码检查
cargo clippy

# 清理
cargo clean
```

### 附录 C：参考资源

- [lab_guide_introduction.md](lab_guide_introduction.md) - ERROR OS 设计理念
- [Chapter_structure.md](Chapter_structure.md) - 完整章节结构
- [02_syscall_implementation.md](02_syscall_implementation.md) - 系统调用实现文档
- [RISC-V 特权级架构手册](https://riscv.org/technical/specifications/)

---

## 结语

**记住我们的目标**：

> 让学生能够**"看见"操作系统的运行过程**，
> 而不是在黑盒中猜测和调试。

**ERROR OS 的价值**：

 是一个**教学导向**的操作系统

 是一个**可视化驱动**的学习工具

 是一个**渐进式学习**的完整系统

**让我们一起努力，打造一个真正优秀的操作系统教学项目！** 🎉

---

**文档版本**：v1.0
**最后更新**：2025-11-26
**维护者**：魏思阳、周晨、王鹤
