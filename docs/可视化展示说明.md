# 进程管理可视化展示说明

## 设计理念

可视化展示遵循"**代码执行到哪里，就展示到哪里**"的原则：

- ❌ **不要**：一次性展示所有信息（信息过载）
- ✅ **要**：随着代码执行逐步展示相关信息
- ✅ **要**：每一步都有适当延迟，方便观察
- ✅ **要**：输出简洁清晰，突出关键信息

## 可视化模块位置

```
os/src/process/visualization.rs
```

该模块是**预提供给学生的**，不需要学生编写。学生只需运行即可看到进程管理各个组件的工作过程。

## 运行方式

### 方式1：通过main.rs运行（推荐）

```bash
cd os
cargo run
```

系统启动后会自动运行所有演示。

### 方式2：单独调用某个演示

在代码中调用：

```rust
use os::process::visualization;

// 运行所有演示
visualization::run_all_demos();

// 或者运行单个演示
visualization::demo_pid_allocation();
visualization::demo_state_transitions();
visualization::demo_pcb_creation();
visualization::demo_time_slice();
visualization::demo_parent_child();
visualization::demo_process_exit();
```

## 六个演示功能

### 演示1：PID分配器

**演示内容**：
- 连续分配5个PID
- 验证唯一性和单调递增特性

**输出示例**：
```
╔════════════════════════════════════════════════════╗
║          演示1：PID分配器                          ║
╠════════════════════════════════════════════════════╣
║ 说明：验证PID分配的唯一性和单调性                 ║
╚════════════════════════════════════════════════════╝

→ 开始分配PID...

  [1] PID = 1
  [2] PID = 2
  [3] PID = 3
  [4] PID = 4
  [5] PID = 5

→ 验证PID属性...

  ✓ PID唯一性：通过
  ✓ PID单调递增：通过

╔════════════════════════════════════════════════════╗
║ ✓ PID分配演示完成                                 ║
╚════════════════════════════════════════════════════╝
```

**关键点**：
- 每分配一个PID后暂停，让学生看清楚
- 最后汇总验证结果

---

### 演示2：进程状态转换

**演示内容**：
- 模拟进程完整生命周期
- 展示4种状态转换：Ready → Running → Ready → Zombie

**输出示例**：
```
╔════════════════════════════════════════════════════╗
║          演示2：进程状态转换                       ║
╠════════════════════════════════════════════════════╣
║ 说明：模拟进程从创建到退出的完整生命周期          ║
╚════════════════════════════════════════════════════╝

[1] 进程创建
    状态: Ready
    说明: 进程在就绪队列中等待

[2] 调度器选中进程
    状态: Ready → Running
    说明: 进程获得CPU，开始执行

[3] 时间片用完
    状态: Running → Ready
    说明: 被抢占，回到就绪队列

[4] 进程退出
    状态: Running → Zombie
    说明: 保留PCB，等待父进程回收

╔════════════════════════════════════════════════════╗
║ ✓ 所有状态转换演示完成                            ║
╚════════════════════════════════════════════════════╝
```

**关键点**：
- 每次状态转换后暂停
- 说明为什么会发生该转换

---

### 演示3：PCB创建

**演示内容**：
- 创建init和shell进程
- 展示PCB的关键字段
- 展示进程树结构

**输出示例**：
```
╔════════════════════════════════════════════════════╗
║          演示3：进程控制块(PCB)创建                ║
╠════════════════════════════════════════════════════╣
║ 说明：创建多个进程并验证PCB信息                   ║
╚════════════════════════════════════════════════════╝

→ 正在创建 init 进程...
✓ init 进程创建成功
  PID:    1
  名称:   init
  状态:   Ready
  父进程: None (根进程)

→ 正在创建 shell 进程...
✓ shell 进程创建成功
  PID:    2
  名称:   shell
  状态:   Ready
  父进程: 1 (init)

进程树结构：
  init (1)
   └─ shell (2)

╔════════════════════════════════════════════════════╗
║ ✓ PCB创建演示完成                                 ║
╚════════════════════════════════════════════════════╝
```

**关键点**：
- 先显示"正在创建"，再显示创建结果
- 最后展示进程树，帮助理解层级关系

---

### 演示4：时间片管理

**演示内容**：
- 从时间片=5开始
- 每次tick()消耗1个时间片
- 用视觉符号展示剩余时间片

**输出示例**：
```
╔════════════════════════════════════════════════════╗
║          演示4：时间片管理                         ║
╠════════════════════════════════════════════════════╣
║ 说明：验证时间片的消耗和重置机制                   ║
╚════════════════════════════════════════════════════╝

初始状态: 时间片 = 5
  [●][●][●][●][●]

→ 时钟中断 #1
  [●][●][●][●][✕]
  ✓ 继续执行

→ 时钟中断 #2
  [●][●][●][✕][✕]
  ✓ 继续执行

→ 时钟中断 #3
  [●][●][✕][✕][✕]
  ✓ 继续执行

→ 时钟中断 #4
  [●][✕][✕][✕][✕]
  ✓ 继续执行

→ 时钟中断 #5
  [✕][✕][✕][✕][✕]
  ⚠ 时间片用完！需要调度

╔════════════════════════════════════════════════════╗
║ ✓ 时间片管理演示完成                              ║
╚════════════════════════════════════════════════════╝
```

**关键点**：
- 用 `[●]` 表示剩余时间片
- 用 `[✕]` 表示已消耗的时间片
- 每次tick后暂停，形成动画效果

---

### 演示5：父子进程关系

**演示内容**：
- 创建父进程
- 逐步添加3个子进程
- 展示进程树的演变

**输出示例**：
```
╔════════════════════════════════════════════════════╗
║          演示5：父子进程关系管理                   ║
╠════════════════════════════════════════════════════╣
║ 说明：验证父进程管理子进程列表的功能               ║
╚════════════════════════════════════════════════════╝

→ 创建父进程...
✓ 父进程创建完成 (PID: 1)

→ 添加子进程1...
  parent (1)
   └─ child (2)

→ 添加子进程2...
  parent (1)
   ├─ child (2)
   └─ child (3)

→ 添加子进程3...
  parent (1)
   ├─ child (2)
   ├─ child (3)
   └─ child (4)

╔════════════════════════════════════════════════════╗
║ ✓ 父子进程关系演示完成                            ║
╚════════════════════════════════════════════════════╝
```

**关键点**：
- 每次添加子进程后刷新整个进程树
- 使用树形符号（├─, └─）表示层级关系

---

### 演示6：进程退出

**演示内容**：
- 进程从创建到退出的完整流程
- 展示Zombie状态的作用

**输出示例**：
```
╔════════════════════════════════════════════════════╗
║          演示6：进程退出和僵尸状态                 ║
╠════════════════════════════════════════════════════╣
║ 说明：验证进程退出后变为Zombie状态并保留退出码    ║
╚════════════════════════════════════════════════════╝

→ 创建进程 test_exit...
✓ 进程创建成功 (PID: 1)
  状态: Ready

→ 进程被调度执行...
✓ 状态变更: Ready → Running
  进程正在执行...

→ 进程调用 exit(42)...
✓ 状态变更: Running → Zombie
  退出码: 42
  PCB 仍然保留，等待父进程回收

╔════════════════════════════════════════════════════╗
║ ✓ 进程退出演示完成                                ║
╚════════════════════════════════════════════════════╝
```

**关键点**：
- 强调Zombie状态的意义：保留退出码
- 说明为什么需要父进程回收

---

## 延迟函数设计

### 实现方式

使用忙等待（busy-wait）实现：

```rust
#[inline(never)]
fn delay(cycles: u32) {
    for _ in 0..cycles {
        core::hint::spin_loop();
    }
}

fn short_delay() {
    delay(50_000_000);  // 约 0.5 秒
}

fn long_delay() {
    delay(100_000_000);  // 约 1 秒
}
```

### 使用场景

| 场景 | 使用的延迟 | 说明 |
|------|-----------|------|
| 演示步骤之间 | `short_delay()` | 让学生看清每一步操作 |
| 演示之间 | `long_delay()` | 区分不同演示的边界 |
| 动画效果 | `short_delay()` | 如时间片消耗动画 |

### 为什么不用sleep？

因为这是裸机OS环境（`no_std`），没有操作系统提供的sleep功能。忙等待虽然占用CPU，但在演示场景下可以接受。

---

## 输出格式规范

### 标题框

使用Unicode框线字符：

```
╔════════════════════════════════════════════════════╗
║          标题                                      ║
╠════════════════════════════════════════════════════╣
║ 说明：...                                          ║
╚════════════════════════════════════════════════════╝
```

### 状态指示符

- `→` - 表示正在执行的操作
- `✓` - 表示成功完成
- `⚠` - 表示警告或需要注意的情况
- `[●]` - 表示可用/剩余资源
- `[✕]` - 表示已使用/消耗的资源

### 缩进规则

- 主标题：不缩进
- 操作说明：2空格缩进
- 详细信息：4空格缩进
- 进程树：2空格基础缩进，子进程额外缩进

---

## 教学建议

### 给教师

1. **演示顺序**：建议按1-6的顺序讲解，从简单到复杂
2. **暂停讲解**：在每个`short_delay()`处暂停，向学生解释当前状态
3. **提问互动**：
   - 演示1：为什么需要PID唯一性？
   - 演示2：为什么需要Zombie状态？
   - 演示4：时间片用完后会发生什么？

### 给学生

1. **观察重点**：
   - PID是如何分配的
   - 进程状态如何转换
   - 时间片如何消耗
   - 父子关系如何建立

2. **思考问题**：
   - 如果没有时间片会怎样？
   - 为什么需要进程树结构？
   - Zombie进程会永远存在吗？

3. **动手实验**：
   - 修改时间片大小，观察变化
   - 创建更复杂的进程树
   - 尝试理解每个函数的实现

---

## 技术细节

### 依赖

```rust
extern crate alloc;
use alloc::vec::Vec;
use alloc::string::String;
use crate::serial_println;
use super::{ProcessId, ProcessState, create_process_handle};
```

### 关键数据结构

- `ProcessId` - PID包装类型
- `ProcessState` - 进程状态枚举（Ready/Running/Blocked/Zombie）
- `ProcessHandle` - 进程控制块的Arc<Mutex<>>包装

### 输出方式

使用 `serial_println!` 宏输出到串口，方便在QEMU中查看。

---

## 常见问题

### Q1: 为什么不用println!而用serial_println!？

**A**: 因为我们的OS还在早期阶段，标准输出可能不可用，串口输出更可靠。

### Q2: 延迟时间可以调整吗？

**A**: 可以！修改 `short_delay()` 和 `long_delay()` 中的循环次数即可。数字越大，延迟越久。

### Q3: 如何跳过某个演示？

**A**: 在 `run_all_demos()` 中注释掉相应的调用即可：

```rust
pub fn run_all_demos() {
    demo_pid_allocation();
    // demo_state_transitions();  // 跳过状态转换演示
    demo_pcb_creation();
    // ...
}
```

### Q4: 可以添加自己的演示吗？

**A**: 可以！按照相同的格式添加新函数，并在 `run_all_demos()` 中调用即可。

---

## 总结

这个可视化模块的核心理念是：

> **让复杂的进程管理概念变得可见、可理解、可体验**

通过逐步展示、适当延迟和清晰的视觉反馈，学生可以更好地理解进程管理的工作原理。
