# 7.1 虚拟文件系统接口

## 本节目标

- 理解VFS（虚拟文件系统）的设计哲学
- 定义File trait统一文件操作接口
- 实现Inode抽象和权限管理
- 设计文件描述符表
- 实现标准输入输出

---

## 本节新增文件

```
os/src/fs/
├── mod.rs          # 文件系统模块入口
├── file.rs         # File trait定义
├── inode.rs        # Inode抽象
├── fd_table.rs     # 文件描述符表
└── stdio.rs        # 标准输入输出
```

---

## 什么是VFS？

**虚拟文件系统（Virtual File System）** 是一个抽象层，它统一了不同文件系统的操作接口。

### Unix哲学："一切皆文件"

| 资源类型 | Unix中的抽象 | 操作接口 |
|---------|-------------|---------|
| 普通文件 | 文件 | read/write |
| 目录 | 特殊文件 | readdir |
| 设备 | 设备文件 | read/write/ioctl |
| 管道 | 管道文件 | read/write |
| 网络 | Socket文件 | send/recv |

**核心思想**：通过统一的接口操作不同类型的资源。

### VFS的三层架构

```
用户态
    ↓
系统调用层 (sys_read/sys_write/sys_open)
    ↓
VFS抽象层 (File trait/Inode trait)
    ↓
具体文件系统 (RamFS/FAT32/ext2)
    ↓
存储介质 (内存/磁盘/网络)
```

---

## File Trait设计

### 核心接口定义

创建 `os/src/fs/file.rs`：

```rust
//! 文件抽象

use alloc::vec::Vec;
use core::fmt;

/// 文件trait - 统一的文件操作接口
pub trait File: Send + Sync {
    /// 读取数据到缓冲区
    fn read(&mut self, buf: &mut [u8]) -> Result<usize, FileError>;

    /// 写入数据到文件
    fn write(&mut self, buf: &[u8]) -> Result<usize, FileError>;

    /// 移动文件读写位置
    fn seek(&mut self, pos: SeekFrom) -> Result<usize, FileError> {
        Err(FileError::InvalidOperation)
    }
}
```

**设计要点**：

1. **trait object**：使用 `dyn File` 实现运行时多态
2. **Send + Sync**：确保线程安全
3. **默认实现**：seek提供默认实现，返回错误

### Seek位置枚举

```rust
/// Seek的起始位置
#[derive(Debug, Clone, Copy)]
pub enum SeekFrom {
    Start(usize),       // 从文件开头
    Current(isize),     // 从当前位置
    End(isize),         // 从文件末尾
}
```

**类比**：就像在书中翻页

- `Start(10)` - 翻到第10页
- `Current(5)` - 从当前页往后翻5页
- `End(-2)` - 从最后一页往前翻2页

### 文件错误类型

```rust
/// 文件操作错误
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum FileError {
    NotFound,           // 文件未找到
    PermissionDenied,   // 权限不足
    EndOfFile,          // 已到达文件末尾
    InvalidOperation,   // 无效的操作
    IoError,            // I/O错误
    AlreadyExists,      // 文件已存在
    NotDirectory,       // 不是目录
    IsDirectory,        // 是目录
}
```

### 辅助方法

<details>
<summary>展开查看完整的File trait实现</summary>

```rust
pub trait File: Send + Sync {
    fn read(&mut self, buf: &mut [u8]) -> Result<usize, FileError>;
    fn write(&mut self, buf: &[u8]) -> Result<usize, FileError>;
    fn seek(&mut self, pos: SeekFrom) -> Result<usize, FileError> {
        Err(FileError::InvalidOperation)
    }

    /// 读取全部内容到Vec
    fn read_all(&mut self) -> Result<Vec<u8>, FileError> {
        let mut buffer = Vec::new();
        let mut chunk = [0u8; 512];

        loop {
            match self.read(&mut chunk) {
                Ok(0) => break,
                Ok(n) => buffer.extend_from_slice(&chunk[..n]),
                Err(FileError::EndOfFile) => break,
                Err(e) => return Err(e),
            }
        }

        Ok(buffer)
    }

    /// 写入字符串
    fn write_str(&mut self, s: &str) -> Result<usize, FileError> {
        self.write(s.as_bytes())
    }

    /// 获取文件大小
    fn size(&self) -> Result<usize, FileError> {
        Err(FileError::InvalidOperation)
    }

    /// 获取文件元数据
    fn stat(&self) -> Result<FileMetadata, FileError> {
        Err(FileError::InvalidOperation)
    }
}
```

</details>

---

## Inode抽象

### 什么是Inode？

**Inode（索引节点）** 存储文件的元数据，不包含文件名和数据。

**类比**：Inode就像图书馆的图书卡片

- 卡片上有：书号、作者、出版日期、页数（元数据）
- 卡片上没有：书名在哪个架子（文件名在目录中）
- 卡片上没有：书的内容（数据在数据块中）

### Inode Trait定义

创建 `os/src/fs/inode.rs`：

```rust
//! Inode抽象

use super::file::{FileType, FileMetadata};
use alloc::sync::Arc;
use spin::Mutex;

/// Inode trait - 文件元数据抽象
pub trait Inode: Send + Sync {
    fn ino(&self) -> usize;              // Inode编号
    fn file_type(&self) -> FileType;     // 文件类型
    fn size(&self) -> usize;             // 文件大小
    fn mode(&self) -> u32;               // 权限位
}
```

### 文件类型枚举

```rust
/// 文件类型
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum FileType {
    RegularFile,     // 普通文件
    Directory,       // 目录
    CharDevice,      // 字符设备
    BlockDevice,     // 块设备
    Pipe,            // 管道
    SymbolicLink,    // 符号链接
}
```

### 文件权限位（Unix风格）

```rust
/// 文件权限位（Unix风格）
pub mod permissions {
    pub const S_IRUSR: u32 = 0o400;  // 用户可读
    pub const S_IWUSR: u32 = 0o200;  // 用户可写
    pub const S_IXUSR: u32 = 0o100;  // 用户可执行

    pub const S_IRGRP: u32 = 0o040;  // 组可读
    pub const S_IWGRP: u32 = 0o020;  // 组可写
    pub const S_IXGRP: u32 = 0o010;  // 组可执行

    pub const S_IROTH: u32 = 0o004;  // 其他可读
    pub const S_IWOTH: u32 = 0o002;  // 其他可写
    pub const S_IXOTH: u32 = 0o001;  // 其他可执行

    pub const S_DEFAULT_FILE: u32 = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;
    pub const S_DEFAULT_DIR: u32 = 0o755;
}
```

**权限位说明**：

```
0o755 = 0b111_101_101
         ↑   ↑   ↑
        用户 组  其他
        rwx  rx  rx
```

### MemInode实现

```rust
/// 内存中的Inode结构
#[derive(Clone)]
pub struct MemInode {
    ino: usize,           // Inode编号
    file_type: FileType,  // 文件类型
    mode: u32,            // 权限位
    size: usize,          // 文件大小
    created: u64,         // 创建时间
    modified: u64,        // 修改时间
    nlinks: usize,        // 硬链接计数
}
```

**硬链接计数**：记录有多少个目录项指向这个Inode

- `nlinks = 0`：可以删除
- `nlinks > 0`：还有引用，不能删除

<details>
<summary>展开查看MemInode完整实现</summary>

```rust
impl MemInode {
    pub fn new(ino: usize, file_type: FileType, mode: u32) -> Self {
        MemInode {
            ino,
            file_type,
            mode,
            size: 0,
            created: 0,
            modified: 0,
            nlinks: 1,
        }
    }

    pub fn new_file(ino: usize) -> Self {
        MemInode::new(ino, FileType::RegularFile, permissions::S_DEFAULT_FILE)
    }

    pub fn new_directory(ino: usize) -> Self {
        MemInode::new(ino, FileType::Directory, permissions::S_DEFAULT_DIR)
    }

    pub fn set_size(&mut self, size: usize) {
        self.size = size;
        self.touch();
    }

    fn touch(&mut self) {
        self.modified += 1;
    }

    pub fn inc_nlinks(&mut self) {
        self.nlinks += 1;
    }

    pub fn dec_nlinks(&mut self) {
        if self.nlinks > 0 {
            self.nlinks -= 1;
        }
    }

    pub fn nlinks(&self) -> usize {
        self.nlinks
    }

    pub fn can_delete(&self) -> bool {
        self.nlinks == 0
    }

    pub fn to_metadata(&self) -> FileMetadata {
        FileMetadata {
            file_type: self.file_type,
            size: self.size,
            mode: self.mode,
            created: self.created,
            modified: self.modified,
        }
    }

    pub fn is_readable(&self) -> bool {
        (self.mode & permissions::S_IRUSR) != 0
    }

    pub fn is_writable(&self) -> bool {
        (self.mode & permissions::S_IWUSR) != 0
    }

    pub fn is_executable(&self) -> bool {
        (self.mode & permissions::S_IXUSR) != 0
    }
}

impl Inode for MemInode {
    fn ino(&self) -> usize {
        self.ino
    }

    fn file_type(&self) -> FileType {
        self.file_type
    }

    fn size(&self) -> usize {
        self.size
    }

    fn mode(&self) -> u32 {
        self.mode
    }
}
```

</details>

---

## 文件描述符表

### 什么是文件描述符？

**文件描述符（File Descriptor, FD）** 是一个非负整数，用于标识打开的文件。

**类比**：文件描述符就像图书馆的借书卡号

- 你用卡号（FD）借书
- 卡号对应一本具体的书（File对象）
- 还书后，卡号可以重复使用

### Unix标准流

```rust
pub const STDIN: FileDescriptor = 0;   // 标准输入
pub const STDOUT: FileDescriptor = 1;  // 标准输出
pub const STDERR: FileDescriptor = 2;  // 标准错误
```

**约定**：FD 0-2 保留给标准流，用户文件从3开始分配。

### 文件描述符表结构

创建 `os/src/fs/fd_table.rs`：

```rust
//! 文件描述符表

use super::file::File;
use alloc::sync::Arc;
use alloc::vec::Vec;
use spin::Mutex;

pub type FileDescriptor = usize;

pub const STDIN: FileDescriptor = 0;
pub const STDOUT: FileDescriptor = 1;
pub const STDERR: FileDescriptor = 2;

pub struct FdEntry {
    file: Arc<Mutex<dyn File>>,
    flags: u32,
}

pub struct FileDescriptorTable {
    entries: Vec<Option<FdEntry>>,
    next_fd: FileDescriptor,
}
```

**设计要点**：

1. **Vec<Option<FdEntry>>**：索引即为FD号
2. **next_fd**：优化分配，记录下一个可用FD
3. **Arc<Mutex<dyn File>>**：支持多线程共享

### FD表初始化

```rust
impl FileDescriptorTable {
    pub fn new() -> Self {
        FileDescriptorTable {
            entries: Vec::new(),
            next_fd: 3,  // 0-2留给标准流
        }
    }

    pub fn with_stdio(
        stdin: Arc<Mutex<dyn File>>,
        stdout: Arc<Mutex<dyn File>>,
        stderr: Arc<Mutex<dyn File>>,
    ) -> Self {
        let mut table = FileDescriptorTable {
            entries: Vec::with_capacity(16),
            next_fd: 3,
        };

        table.entries.push(Some(FdEntry::new(stdin)));
        table.entries.push(Some(FdEntry::new(stdout)));
        table.entries.push(Some(FdEntry::new(stderr)));

        table
    }
}
```

### FD分配算法

```rust
pub fn alloc(&mut self, file: Arc<Mutex<dyn File>>) -> Option<FileDescriptor> {
    let entry = FdEntry::new(file);

    // 先尝试复用空闲槽位
    for (i, slot) in self.entries.iter_mut().enumerate() {
        if slot.is_none() && i >= 3 {
            *slot = Some(entry);
            self.next_fd = i + 1;
            return Some(i);
        }
    }

    // 没有空闲槽位，扩展Vec
    let fd = self.entries.len();
    self.entries.push(Some(entry));
    self.next_fd = fd + 1;

    Some(fd)
}
```

**算法说明**：

1. 优先复用已释放的FD（避免FD号无限增长）
2. 保护0-2标准流（`i >= 3`）
3. 无空闲时扩展Vec

### FD释放

```rust
pub fn dealloc(&mut self, fd: FileDescriptor) -> bool {
    if fd >= 3 && fd < self.entries.len() {
        if self.entries[fd].is_some() {
            self.entries[fd] = None;
            if fd < self.next_fd {
                self.next_fd = fd;  // 优化下次分配
            }
            return true;
        }
    }
    false
}
```

<details>
<summary>展开查看FD表完整实现</summary>

```rust
impl FdEntry {
    pub fn new(file: Arc<Mutex<dyn File>>) -> Self {
        FdEntry { file, flags: 0 }
    }

    pub fn file(&self) -> Arc<Mutex<dyn File>> {
        self.file.clone()
    }
}

impl FileDescriptorTable {
    pub fn new() -> Self {
        FileDescriptorTable {
            entries: Vec::new(),
            next_fd: 3,
        }
    }

    pub fn with_stdio(
        stdin: Arc<Mutex<dyn File>>,
        stdout: Arc<Mutex<dyn File>>,
        stderr: Arc<Mutex<dyn File>>,
    ) -> Self {
        let mut table = FileDescriptorTable {
            entries: Vec::with_capacity(16),
            next_fd: 3,
        };

        table.entries.push(Some(FdEntry::new(stdin)));
        table.entries.push(Some(FdEntry::new(stdout)));
        table.entries.push(Some(FdEntry::new(stderr)));

        table
    }

    pub fn alloc(&mut self, file: Arc<Mutex<dyn File>>) -> Option<FileDescriptor> {
        let entry = FdEntry::new(file);

        for (i, slot) in self.entries.iter_mut().enumerate() {
            if slot.is_none() && i >= 3 {
                *slot = Some(entry);
                self.next_fd = i + 1;
                return Some(i);
            }
        }

        let fd = self.entries.len();
        self.entries.push(Some(entry));
        self.next_fd = fd + 1;

        Some(fd)
    }

    pub fn dealloc(&mut self, fd: FileDescriptor) -> bool {
        if fd >= 3 && fd < self.entries.len() {
            if self.entries[fd].is_some() {
                self.entries[fd] = None;
                if fd < self.next_fd {
                    self.next_fd = fd;
                }
                return true;
            }
        }
        false
    }

    pub fn get(&self, fd: FileDescriptor) -> Option<Arc<Mutex<dyn File>>> {
        self.entries.get(fd)?.as_ref().map(|entry| entry.file())
    }

    pub fn is_valid(&self, fd: FileDescriptor) -> bool {
        self.get(fd).is_some()
    }

    pub fn count(&self) -> usize {
        self.entries.iter().filter(|e| e.is_some()).count()
    }

    pub fn capacity(&self) -> usize {
        self.entries.len()
    }
}
```

</details>

---

## 标准输入输出实现

### Stdout实现

创建 `os/src/fs/stdio.rs`：

```rust
//! 标准输入输出文件

use super::file::{File, FileError};
use crate::println;

/// 标准输出
pub struct Stdout;

impl Stdout {
    pub fn new() -> Self {
        Stdout
    }
}

impl File for Stdout {
    fn read(&mut self, _buf: &mut [u8]) -> Result<usize, FileError> {
        Err(FileError::InvalidOperation)
    }

    fn write(&mut self, buf: &[u8]) -> Result<usize, FileError> {
        if let Ok(s) = core::str::from_utf8(buf) {
            println!("{}", s);
            Ok(buf.len())
        } else {
            Err(FileError::IoError)
        }
    }
}
```

**设计要点**：

- `read` 返回错误（不能从stdout读取）
- `write` 调用 `println!` 输出到串口

### Stdin和Stderr实现

```rust
/// 标准输入
pub struct Stdin;

impl Stdin {
    pub fn new() -> Self {
        Stdin
    }
}

impl File for Stdin {
    fn read(&mut self, _buf: &mut [u8]) -> Result<usize, FileError> {
        // 暂不支持键盘输入
        Err(FileError::InvalidOperation)
    }

    fn write(&mut self, _buf: &[u8]) -> Result<usize, FileError> {
        Err(FileError::InvalidOperation)
    }
}

/// 标准错误
pub struct Stderr;

impl Stderr {
    pub fn new() -> Self {
        Stderr
    }
}

impl File for Stderr {
    fn read(&mut self, _buf: &mut [u8]) -> Result<usize, FileError> {
        Err(FileError::InvalidOperation)
    }

    fn write(&mut self, buf: &[u8]) -> Result<usize, FileError> {
        if let Ok(s) = core::str::from_utf8(buf) {
            println!("{}", s);
            Ok(buf.len())
        } else {
            Err(FileError::IoError)
        }
    }
}
```

---

## 模块导出

创建 `os/src/fs/mod.rs`：

```rust
//! 文件系统模块

pub mod file;
pub mod inode;
pub mod fd_table;
pub mod stdio;

pub use file::{File, FileError, FileType, FileMetadata, SeekFrom};
pub use inode::{Inode, MemInode, InodeHandle, permissions};
pub use fd_table::{FileDescriptor, FileDescriptorTable, STDIN, STDOUT, STDERR};
pub use stdio::{Stdin, Stdout, Stderr};
```

**注意**：现在还不能编译，因为依赖的 `ramfs` 和 `manager` 模块在下一节实现。

---

## 知识点总结

### VFS三要素

| 概念 | 作用 | 类比 |
|------|------|------|
| File | 统一操作接口 | 遥控器（不同电视用同一个遥控器） |
| Inode | 文件元数据 | 图书卡片（记录书的信息） |
| FD | 文件句柄 | 借书卡号（用号码借书） |

### 为什么要分File和Inode？

```
Inode (文件本身)
  ↓
  ├─ File1 (第一次打开，offset=0)
  ├─ File2 (第二次打开，offset=100)
  └─ File3 (第三次打开，offset=50)
```

一个文件可以被多次打开，每次打开有独立的读写位置。

---

## 下一步

- 7.1 虚拟文件系统接口（本节）
- 7.2 简单文件系统实现
- 7.3 文件系统系统调用
- 7.4 文件系统测试
