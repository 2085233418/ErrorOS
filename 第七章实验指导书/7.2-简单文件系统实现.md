# 7.2 简单文件系统实现

## 本节目标

- 理解RamFS的设计思路
- 实现RamInode数据结构
- 实现文件读写操作
- 实现目录管理
- 创建全局文件系统管理器

---

## 本节新增文件

```
os/src/fs/
├── ramfs.rs        # RamFS文件系统实现
└── manager.rs      # 全局管理器
```

---

## 为什么选择RamFS？

**RamFS（内存文件系统）** 将所有数据存储在内存中，是学习文件系统的最佳起点。

### RamFS vs 真实文件系统

| 特性 | RamFS | 磁盘文件系统（ext2/FAT32） |
|------|-------|---------------------------|
| 存储介质 | 内存（Vec<u8>） | 磁盘（块设备） |
| 持久化 | 断电丢失 | 断电保留 |
| 性能 | 极快（内存速度） | 较慢（磁盘I/O） |
| 实现复杂度 | 简单 | 复杂 |
| 适用场景 | 临时文件、学习 | 生产环境 |

**类比**：RamFS就像在白板上写字，断电就擦掉了；磁盘文件系统像在笔记本上写字，永久保存。

---

## RamInode设计

### 核心数据结构

创建 `os/src/fs/ramfs.rs`：

```rust
//! 内存文件系统（RamFS）

use super::file::{File, FileError, FileType};
use super::inode::{Inode, MemInode, permissions};
use alloc::collections::BTreeMap;
use alloc::string::String;
use alloc::sync::Arc;
use alloc::vec::Vec;
use spin::Mutex;

/// RamFS的Inode
pub struct RamInode {
    ino: usize,
    file_type: FileType,
    mode: u32,
    size: usize,
    created: u64,
    modified: u64,
    nlinks: usize,

    // 文件数据（对于普通文件）
    data: Vec<u8>,

    // 目录项（对于目录）
    entries: BTreeMap<String, Arc<Mutex<RamInode>>>,
}
```

**设计要点**：

1. **data: Vec<u8>** - 普通文件用这个字段存储内容
2. **entries: BTreeMap** - 目录用这个字段存储子文件/子目录
3. **BTreeMap而非HashMap** - 保证目录项有序（ls时按字母排序）

### 文件与目录的区别

```rust
普通文件:
  data = [72, 101, 108, 108, 111]  // "Hello"
  entries = 空

目录:
  data = 空
  entries = {
    "file1.txt" -> Arc<Mutex<RamInode>>,
    "file2.txt" -> Arc<Mutex<RamInode>>,
    "subdir"    -> Arc<Mutex<RamInode>>,
  }
```

### RamInode构造函数

```rust
impl RamInode {
    pub fn new_file(ino: usize) -> Self {
        RamInode {
            ino,
            file_type: FileType::RegularFile,
            mode: permissions::S_DEFAULT_FILE,
            size: 0,
            created: 0,
            modified: 0,
            nlinks: 1,
            data: Vec::new(),
            entries: BTreeMap::new(),
        }
    }

    pub fn new_directory(ino: usize) -> Self {
        RamInode {
            ino,
            file_type: FileType::Directory,
            mode: permissions::S_DEFAULT_DIR,
            size: 0,
            created: 0,
            modified: 0,
            nlinks: 1,
            data: Vec::new(),
            entries: BTreeMap::new(),
        }
    }
}
```

---

## 文件读写实现

### read_at - 指定位置读取

```rust
pub fn read_at(&self, offset: usize, buf: &mut [u8]) -> Result<usize, FileError> {
    // 检查文件类型
    if self.file_type != FileType::RegularFile {
        return Err(FileError::IsDirectory);
    }

    // 检查偏移是否超出文件大小
    if offset >= self.data.len() {
        return Ok(0);  // EOF
    }

    // 计算实际读取的字节数
    let end = core::cmp::min(offset + buf.len(), self.data.len());
    let n = end - offset;

    // 拷贝数据
    buf[..n].copy_from_slice(&self.data[offset..end]);
    Ok(n)
}
```

**算法说明**：

```
文件: [H][e][l][l][o]
       0  1  2  3  4  5 (len)

read_at(2, buf[3]):
  offset = 2
  buf.len() = 3
  end = min(2+3, 5) = 5
  n = 5 - 2 = 3
  读取: data[2..5] -> [l][l][o]
```

### write_at - 指定位置写入

```rust
pub fn write_at(&mut self, offset: usize, buf: &[u8]) -> Result<usize, FileError> {
    if self.file_type != FileType::RegularFile {
        return Err(FileError::IsDirectory);
    }

    let end = offset + buf.len();

    // 如果写入超出当前大小，扩展Vec
    if end > self.data.len() {
        self.data.resize(end, 0);
    }

    // 拷贝数据
    self.data[offset..end].copy_from_slice(buf);
    self.size = self.data.len();
    self.modified += 1;

    Ok(buf.len())
}
```

**扩展机制**：

```
初始: data = [H][e][l]  (len=3)

write_at(5, [o]):
  offset = 5, buf.len() = 1
  end = 6
  resize(6, 0) -> [H][e][l][0][0][0]
  写入 -> [H][e][l][0][0][o]
```

### truncate - 截断文件

```rust
pub fn truncate(&mut self, size: usize) -> Result<(), FileError> {
    if self.file_type != FileType::RegularFile {
        return Err(FileError::IsDirectory);
    }

    self.data.resize(size, 0);
    self.size = size;
    self.modified += 1;
    Ok(())
}
```

**用途**：

- `truncate(0)` - 清空文件
- `truncate(100)` - 设置固定大小

---

## 目录操作实现

### add_entry - 添加目录项

```rust
pub fn add_entry(
    &mut self,
    name: String,
    inode: Arc<Mutex<RamInode>>,
) -> Result<(), FileError> {
    if self.file_type != FileType::Directory {
        return Err(FileError::NotDirectory);
    }

    if self.entries.contains_key(&name) {
        return Err(FileError::AlreadyExists);
    }

    self.entries.insert(name, inode);
    Ok(())
}
```

**检查点**：

1. 必须是目录（否则返回NotDirectory）
2. 文件名不能重复（否则返回AlreadyExists）

### lookup - 查找目录项

```rust
pub fn lookup(&self, name: &str) -> Result<Arc<Mutex<RamInode>>, FileError> {
    if self.file_type != FileType::Directory {
        return Err(FileError::NotDirectory);
    }

    self.entries.get(name).cloned().ok_or(FileError::NotFound)
}
```

**示例**：

```rust
// 在根目录查找 "test.txt"
let root = ramfs.root();
let inode = root.lock().lookup("test.txt")?;
```

### remove_entry - 删除目录项

```rust
pub fn remove_entry(&mut self, name: &str) -> Result<(), FileError> {
    if self.file_type != FileType::Directory {
        return Err(FileError::NotDirectory);
    }

    self.entries.remove(name).ok_or(FileError::NotFound)?;
    Ok(())
}
```

### list_entries - 列出所有目录项

```rust
pub fn list_entries(&self) -> Result<Vec<String>, FileError> {
    if self.file_type != FileType::Directory {
        return Err(FileError::NotDirectory);
    }

    Ok(self.entries.keys().cloned().collect())
}
```

**用途**：实现 `ls` 命令

<details>
<summary>展开查看RamInode完整实现</summary>

```rust
impl RamInode {
    pub fn new_file(ino: usize) -> Self {
        RamInode {
            ino,
            file_type: FileType::RegularFile,
            mode: permissions::S_DEFAULT_FILE,
            size: 0,
            created: 0,
            modified: 0,
            nlinks: 1,
            data: Vec::new(),
            entries: BTreeMap::new(),
        }
    }

    pub fn new_directory(ino: usize) -> Self {
        RamInode {
            ino,
            file_type: FileType::Directory,
            mode: permissions::S_DEFAULT_DIR,
            size: 0,
            created: 0,
            modified: 0,
            nlinks: 1,
            data: Vec::new(),
            entries: BTreeMap::new(),
        }
    }

    pub fn read_at(&self, offset: usize, buf: &mut [u8]) -> Result<usize, FileError> {
        if self.file_type != FileType::RegularFile {
            return Err(FileError::IsDirectory);
        }

        if offset >= self.data.len() {
            return Ok(0);
        }

        let end = core::cmp::min(offset + buf.len(), self.data.len());
        let n = end - offset;
        buf[..n].copy_from_slice(&self.data[offset..end]);
        Ok(n)
    }

    pub fn write_at(&mut self, offset: usize, buf: &[u8]) -> Result<usize, FileError> {
        if self.file_type != FileType::RegularFile {
            return Err(FileError::IsDirectory);
        }

        let end = offset + buf.len();
        if end > self.data.len() {
            self.data.resize(end, 0);
        }

        self.data[offset..end].copy_from_slice(buf);
        self.size = self.data.len();
        self.modified += 1;
        Ok(buf.len())
    }

    pub fn truncate(&mut self, size: usize) -> Result<(), FileError> {
        if self.file_type != FileType::RegularFile {
            return Err(FileError::IsDirectory);
        }

        self.data.resize(size, 0);
        self.size = size;
        self.modified += 1;
        Ok(())
    }

    pub fn add_entry(&mut self, name: String, inode: Arc<Mutex<RamInode>>) -> Result<(), FileError> {
        if self.file_type != FileType::Directory {
            return Err(FileError::NotDirectory);
        }

        if self.entries.contains_key(&name) {
            return Err(FileError::AlreadyExists);
        }

        self.entries.insert(name, inode);
        Ok(())
    }

    pub fn remove_entry(&mut self, name: &str) -> Result<(), FileError> {
        if self.file_type != FileType::Directory {
            return Err(FileError::NotDirectory);
        }

        self.entries.remove(name).ok_or(FileError::NotFound)?;
        Ok(())
    }

    pub fn lookup(&self, name: &str) -> Result<Arc<Mutex<RamInode>>, FileError> {
        if self.file_type != FileType::Directory {
            return Err(FileError::NotDirectory);
        }

        self.entries.get(name).cloned().ok_or(FileError::NotFound)
    }

    pub fn list_entries(&self) -> Result<Vec<String>, FileError> {
        if self.file_type != FileType::Directory {
            return Err(FileError::NotDirectory);
        }

        Ok(self.entries.keys().cloned().collect())
    }
}

impl Inode for RamInode {
    fn ino(&self) -> usize {
        self.ino
    }

    fn file_type(&self) -> FileType {
        self.file_type
    }

    fn size(&self) -> usize {
        self.size
    }

    fn mode(&self) -> u32 {
        self.mode
    }
}
```

</details>

---

## RamFile - 文件句柄

### 为什么需要RamFile？

**RamInode** 是文件本身（元数据 + 数据）
**RamFile** 是打开的文件句柄（包含读写位置）

```
一个文件（RamInode）可以被多次打开：
  RamFile1: offset = 0
  RamFile2: offset = 100
  RamFile3: offset = 50
```

### RamFile结构

```rust
/// RamFS文件句柄
pub struct RamFile {
    inode: Arc<Mutex<RamInode>>,
    offset: usize,  // 当前读写位置
}

impl RamFile {
    pub fn new(inode: Arc<Mutex<RamInode>>) -> Self {
        RamFile { inode, offset: 0 }
    }
}
```

### 实现File trait

```rust
impl File for RamFile {
    fn read(&mut self, buf: &mut [u8]) -> Result<usize, FileError> {
        let n = self.inode.lock().read_at(self.offset, buf)?;
        self.offset += n;  // 更新读写位置
        Ok(n)
    }

    fn write(&mut self, buf: &[u8]) -> Result<usize, FileError> {
        let n = self.inode.lock().write_at(self.offset, buf)?;
        self.offset += n;  // 更新读写位置
        Ok(n)
    }

    fn seek(&mut self, pos: super::file::SeekFrom) -> Result<usize, FileError> {
        use super::file::SeekFrom;

        let size = self.inode.lock().size();

        let new_offset = match pos {
            SeekFrom::Start(offset) => offset,
            SeekFrom::Current(delta) => {
                if delta >= 0 {
                    self.offset + delta as usize
                } else {
                    self.offset.saturating_sub((-delta) as usize)
                }
            }
            SeekFrom::End(delta) => {
                if delta >= 0 {
                    size + delta as usize
                } else {
                    size.saturating_sub((-delta) as usize)
                }
            }
        };

        self.offset = new_offset;
        Ok(self.offset)
    }

    fn size(&self) -> Result<usize, FileError> {
        Ok(self.inode.lock().size())
    }
}
```

**seek算法示例**：

```
文件大小: 100字节
当前offset: 50

SeekFrom::Start(10)  -> offset = 10
SeekFrom::Current(5) -> offset = 50 + 5 = 55
SeekFrom::Current(-20) -> offset = 50 - 20 = 30
SeekFrom::End(0)     -> offset = 100
SeekFrom::End(-10)   -> offset = 100 - 10 = 90
```

---

## RamFS文件系统

### RamFS结构

```rust
/// RamFS文件系统
pub struct RamFS {
    root: Arc<Mutex<RamInode>>,  // 根目录
    next_ino: Mutex<usize>,      // 下一个可用的Inode号
}
```

### 初始化

```rust
impl RamFS {
    pub fn new() -> Self {
        let root = Arc::new(Mutex::new(RamInode::new_directory(1)));
        RamFS {
            root,
            next_ino: Mutex::new(2),  // 1已分配给root
        }
    }

    fn alloc_ino(&self) -> usize {
        let mut next = self.next_ino.lock();
        let ino = *next;
        *next += 1;
        ino
    }

    pub fn root(&self) -> Arc<Mutex<RamInode>> {
        self.root.clone()
    }
}
```

**Inode分配**：

- Inode 1：保留给根目录
- Inode 2, 3, 4, ...：分配给后续创建的文件/目录

### 创建文件

```rust
pub fn create_file(
    &self,
    parent: Arc<Mutex<RamInode>>,
    name: String,
) -> Result<Arc<Mutex<RamInode>>, FileError> {
    let ino = self.alloc_ino();
    let inode = Arc::new(Mutex::new(RamInode::new_file(ino)));
    parent.lock().add_entry(name, inode.clone())?;
    Ok(inode)
}
```

**流程**：

1. 分配新的Inode号
2. 创建RamInode（文件类型）
3. 添加到父目录的entries
4. 返回Arc引用

### 创建目录

```rust
pub fn create_directory(
    &self,
    parent: Arc<Mutex<RamInode>>,
    name: String,
) -> Result<Arc<Mutex<RamInode>>, FileError> {
    let ino = self.alloc_ino();
    let inode = Arc::new(Mutex::new(RamInode::new_directory(ino)));
    parent.lock().add_entry(name, inode.clone())?;
    Ok(inode)
}
```

### 删除文件/目录

```rust
pub fn remove(
    &self,
    parent: Arc<Mutex<RamInode>>,
    name: &str,
) -> Result<(), FileError> {
    parent.lock().remove_entry(name)
}
```

### 查找文件

```rust
pub fn lookup(
    &self,
    parent: Arc<Mutex<RamInode>>,
    name: &str,
) -> Result<Arc<Mutex<RamInode>>, FileError> {
    parent.lock().lookup(name)
}
```

### 打开文件

```rust
pub fn open_file(
    &self,
    inode: Arc<Mutex<RamInode>>,
) -> Result<RamFile, FileError> {
    let file_type = inode.lock().file_type();
    if file_type != FileType::RegularFile {
        return Err(FileError::IsDirectory);
    }
    Ok(RamFile::new(inode))
}
```

<details>
<summary>展开查看RamFS完整实现</summary>

```rust
pub struct RamFS {
    root: Arc<Mutex<RamInode>>,
    next_ino: Mutex<usize>,
}

impl RamFS {
    pub fn new() -> Self {
        let root = Arc::new(Mutex::new(RamInode::new_directory(1)));
        RamFS {
            root,
            next_ino: Mutex::new(2),
        }
    }

    fn alloc_ino(&self) -> usize {
        let mut next = self.next_ino.lock();
        let ino = *next;
        *next += 1;
        ino
    }

    pub fn root(&self) -> Arc<Mutex<RamInode>> {
        self.root.clone()
    }

    pub fn create_file(&self, parent: Arc<Mutex<RamInode>>, name: String) -> Result<Arc<Mutex<RamInode>>, FileError> {
        let ino = self.alloc_ino();
        let inode = Arc::new(Mutex::new(RamInode::new_file(ino)));
        parent.lock().add_entry(name, inode.clone())?;
        Ok(inode)
    }

    pub fn create_directory(&self, parent: Arc<Mutex<RamInode>>, name: String) -> Result<Arc<Mutex<RamInode>>, FileError> {
        let ino = self.alloc_ino();
        let inode = Arc::new(Mutex::new(RamInode::new_directory(ino)));
        parent.lock().add_entry(name, inode.clone())?;
        Ok(inode)
    }

    pub fn remove(&self, parent: Arc<Mutex<RamInode>>, name: &str) -> Result<(), FileError> {
        parent.lock().remove_entry(name)
    }

    pub fn lookup(&self, parent: Arc<Mutex<RamInode>>, name: &str) -> Result<Arc<Mutex<RamInode>>, FileError> {
        parent.lock().lookup(name)
    }

    pub fn open_file(&self, inode: Arc<Mutex<RamInode>>) -> Result<RamFile, FileError> {
        let file_type = inode.lock().file_type();
        if file_type != FileType::RegularFile {
            return Err(FileError::IsDirectory);
        }
        Ok(RamFile::new(inode))
    }
}
```

</details>

---

## 全局管理器

### 为什么需要全局管理器？

系统调用需要访问：
1. 全局RamFS实例（查找/创建文件）
2. 全局FD表（分配/释放文件描述符）

### 使用lazy_static

创建 `os/src/fs/manager.rs`：

```rust
//! 文件系统管理器

use super::fd_table::{FileDescriptorTable, STDIN, STDOUT, STDERR};
use super::ramfs::RamFS;
use super::stdio::{Stdin, Stdout, Stderr};
use alloc::sync::Arc;
use spin::Mutex;
use lazy_static::lazy_static;

lazy_static! {
    /// 全局RamFS实例
    pub static ref RAMFS: Arc<RamFS> = Arc::new(RamFS::new());

    /// 全局文件描述符表
    pub static ref FD_TABLE: Mutex<FileDescriptorTable> = {
        let stdin = Arc::new(Mutex::new(Stdin::new()));
        let stdout = Arc::new(Mutex::new(Stdout::new()));
        let stderr = Arc::new(Mutex::new(Stderr::new()));

        Mutex::new(FileDescriptorTable::with_stdio(stdin, stdout, stderr))
    };
}

/// 初始化文件系统
pub fn init() {
    // 懒加载会在第一次访问时初始化
    let _ = &*RAMFS;
    let _ = &*FD_TABLE;
    crate::println!("[FS] File system initialized");
}
```

**lazy_static原理**：

```rust
第一次访问RAMFS时:
  1. 调用RamFS::new()创建实例
  2. 缓存结果
  3. 返回引用

后续访问:
  直接返回缓存的引用
```

### 初始化状态

```
FD表初始化后:
  FD 0 -> Stdin
  FD 1 -> Stdout
  FD 2 -> Stderr

RamFS初始化后:
  / (root, ino=1)
```

---

## 更新模块导出

修改 `os/src/fs/mod.rs`：

```rust
//! 文件系统模块

pub mod file;
pub mod inode;
pub mod fd_table;
pub mod stdio;
pub mod ramfs;      // 新增
pub mod manager;    // 新增

pub use file::{File, FileError, FileType, FileMetadata, SeekFrom};
pub use inode::{Inode, MemInode, InodeHandle, permissions};
pub use fd_table::{FileDescriptor, FileDescriptorTable, STDIN, STDOUT, STDERR};
pub use stdio::{Stdin, Stdout, Stderr};
pub use ramfs::{RamFS, RamInode, RamFile, DirEntry};  // 新增
pub use manager::{RAMFS, FD_TABLE, init};              // 新增
```

---

## 使用示例

### 创建并写入文件

```rust
use os::fs::{RAMFS, FD_TABLE};
use alloc::string::String;

// 获取根目录
let root = RAMFS.root();

// 创建文件
let inode = RAMFS.create_file(root, String::from("test.txt")).unwrap();

// 打开文件
let mut file = RAMFS.open_file(inode).unwrap();

// 写入数据
file.write(b"Hello, RamFS!").unwrap();

// 重置到文件开头
file.seek(SeekFrom::Start(0)).unwrap();

// 读取数据
let mut buf = [0u8; 20];
let n = file.read(&mut buf).unwrap();
assert_eq!(&buf[..n], b"Hello, RamFS!");
```

### 使用FD表

```rust
// 将文件添加到FD表
let file_arc: Arc<Mutex<dyn File>> = Arc::new(Mutex::new(file));
let fd = FD_TABLE.lock().alloc(file_arc).unwrap();

// 通过FD访问文件
let file = FD_TABLE.lock().get(fd).unwrap();
file.lock().write(b"data").unwrap();

// 关闭FD
FD_TABLE.lock().dealloc(fd);
```

---

## 知识点总结

### RamFS核心组件

| 组件 | 作用 | 存储位置 |
|------|------|---------|
| RamInode | 文件元数据+数据 | Vec（文件）/BTreeMap（目录） |
| RamFile | 文件句柄 | offset读写位置 |
| RamFS | 文件系统 | 管理Inode分配和根目录 |
| RAMFS | 全局实例 | lazy_static |
| FD_TABLE | 全局FD表 | lazy_static |

### 数据流向

```
用户程序
  ↓
FD (文件描述符号)
  ↓
FD_TABLE (查找)
  ↓
Arc<Mutex<dyn File>> (RamFile)
  ↓
Arc<Mutex<RamInode>> (文件数据)
  ↓
Vec<u8> (实际存储)
```

---

## 下一步

- 7.1 虚拟文件系统接口
- 7.2 简单文件系统实现（本节）
- 7.3 文件系统系统调用
- 7.4 文件系统测试
