# 7.4 文件系统测试

## 本节目标

- 理解文件系统测试的组织结构
- 测试文件创建功能
- 测试文件读写操作
- 测试文件描述符表管理
- 测试目录创建功能

---

## 本节新增文件

```
os/tests/
└── test_filesystem.rs  # 文件系统集成测试
```

---

## 测试框架概述

### 为什么需要测试？

**测试** 是验证代码正确性的重要手段，尤其对于操作系统这种复杂系统。

**类比**：测试就像体检
- 确保各项功能正常工作
- 发现潜在问题
- 避免线上故障

### 测试文件结构

```rust
//! 文件系统测试

#![no_std]
#![no_main]
#![feature(custom_test_frameworks)]
#![test_runner(os::test_runner)]
#![reexport_test_harness_main = "test_main"]

use core::panic::PanicInfo;
use os::fs::{RAMFS, FD_TABLE, RamFile};
use os::{serial_println, serial_print};
use alloc::sync::Arc;
use spin::Mutex;
use alloc::string::String;

extern crate alloc;

#[no_mangle]
pub extern "C" fn _start() -> ! {
    test_main();
    loop {}
}

#[panic_handler]
fn panic(info: &PanicInfo) -> ! {
    os::test_panic_handler(info)
}
```

**关键特性**：

1. **#![no_std]** - 裸机环境
2. **custom_test_frameworks** - 自定义测试框架
3. **test_runner** - 使用os模块的测试运行器
4. **extern crate alloc** - 启用堆分配

---

## 测试1：文件创建

### 测试目标

验证RamFS能够正确创建文件并分配Inode号。

### 测试代码

```rust
#[test_case]
fn test_create_file() {
    serial_print!("test_create_file... ");

    let root = RAMFS.root();
    let file = RAMFS.create_file(root.clone(), String::from("test.txt")).unwrap();

    assert_eq!(file.lock().ino(), 2); // root是1，这个文件是2

    serial_println!("[ok]");
}
```

### 测试步骤

```
1. 获取根目录
   ↓
2. 创建文件"test.txt"
   ↓
3. 验证Inode号为2（root占用1）
   ↓
4. 输出[ok]
```

### 预期结果

```
test_create_file... [ok]
```

### 为什么Inode号是2？

```
初始状态:
  next_ino = 2  (1已分配给root)

创建第一个文件:
  alloc_ino() -> 返回2
  next_ino -> 更新为3
```

---

## 测试2：文件读写

### 测试目标

验证文件的写入和读取功能，包括seek操作。

### 测试代码

```rust
#[test_case]
fn test_write_read() {
    serial_print!("test_write_read... ");

    let root = RAMFS.root();
    let inode = RAMFS.create_file(root, String::from("data.txt")).unwrap();
    let mut file = RAMFS.open_file(inode).unwrap();

    // 写入数据
    let data = b"Hello, RamFS!";
    let n = file.write(data).unwrap();
    assert_eq!(n, data.len());

    // 重置偏移
    file.seek(os::fs::SeekFrom::Start(0)).unwrap();

    // 读取数据
    let mut buf = [0u8; 20];
    let n = file.read(&mut buf).unwrap();
    assert_eq!(n, data.len());
    assert_eq!(&buf[..n], data);

    serial_println!("[ok]");
}
```

### 测试流程

```
创建文件
  ↓
打开文件 (offset=0)
  ↓
写入"Hello, RamFS!" (offset变为13)
  ↓
验证返回值n=13
  ↓
seek到文件开头 (offset=0)
  ↓
读取数据到buf
  ↓
验证读取13字节
  ↓
验证内容匹配
```

### 为什么需要seek？

```
写入后:
  offset = 13（文件末尾）

不seek直接读:
  从offset=13读取 -> EOF，返回0字节

seek后读:
  offset = 0（文件开头）
  读取完整内容
```

### 数据流向

```
用户数据: b"Hello, RamFS!"
  ↓
file.write()
  ↓
RamFile::write()
  ↓
RamInode::write_at(offset=0, data)
  ↓
Vec<u8>扩展并拷贝
  ↓
存储: [72, 101, 108, 108, 111, 44, 32, 82, 97, 109, 70, 83, 33]
```

---

## 测试3：文件描述符表

### 测试目标

验证FD表的分配、查找和释放功能。

### 测试代码

```rust
#[test_case]
fn test_fd_table() {
    serial_print!("test_fd_table... ");

    let root = RAMFS.root();
    let inode = RAMFS.create_file(root, String::from("fd_test.txt")).unwrap();
    let file = RAMFS.open_file(inode).unwrap();

    let file_arc: Arc<Mutex<dyn os::fs::File>> = Arc::new(Mutex::new(file));
    let fd = FD_TABLE.lock().alloc(file_arc).unwrap();

    assert!(fd >= 3); // 0-2是标准流

    // 验证可以获取文件
    assert!(FD_TABLE.lock().get(fd).is_some());

    // 关闭文件描述符
    assert!(FD_TABLE.lock().dealloc(fd));

    // 验证已释放
    assert!(FD_TABLE.lock().get(fd).is_none());

    serial_println!("[ok]");
}
```

### 测试要点

**1. FD分配**

```rust
let fd = FD_TABLE.lock().alloc(file_arc).unwrap();
assert!(fd >= 3);
```

验证：
- FD成功分配
- FD号 >= 3（0-2保留给stdin/stdout/stderr）

**2. FD查找**

```rust
assert!(FD_TABLE.lock().get(fd).is_some());
```

验证：
- 可以通过FD号找到文件
- 返回Some(Arc<Mutex<dyn File>>)

**3. FD释放**

```rust
assert!(FD_TABLE.lock().dealloc(fd));
assert!(FD_TABLE.lock().get(fd).is_none());
```

验证：
- dealloc返回true（成功）
- 释放后get返回None

### FD生命周期

```
初始状态:
  entries = [Some(Stdin), Some(Stdout), Some(Stderr)]
  next_fd = 3

分配FD:
  fd = 3
  entries.push(Some(file))
  next_fd = 4

释放FD:
  entries[3] = None
  next_fd = 3（复用）
```

---

## 测试4：目录创建

### 测试目标

验证目录创建功能和文件类型识别。

### 测试代码

```rust
#[test_case]
fn test_create_directory() {
    serial_print!("test_create_directory... ");

    let root = RAMFS.root();
    let dir = RAMFS.create_directory(root, String::from("testdir")).unwrap();

    assert_eq!(dir.lock().file_type(), os::fs::FileType::Directory);

    serial_println!("[ok]");
}
```

### 测试步骤

```
1. 获取根目录
   ↓
2. 创建目录"testdir"
   ↓
3. 验证文件类型为Directory
   ↓
4. 输出[ok]
```

### 文件与目录的区别

| 特性 | 普通文件 | 目录 |
|------|---------|------|
| file_type | RegularFile | Directory |
| data字段 | 存储文件内容 | 空Vec |
| entries字段 | 空BTreeMap | 存储子文件/子目录 |
| 权限 | 0o644 | 0o755 |

### 目录结构示例

```
创建后的文件系统树:

/ (root, ino=1, Directory)
├── test.txt (ino=2, RegularFile)
├── data.txt (ino=3, RegularFile)
├── fd_test.txt (ino=4, RegularFile)
└── testdir (ino=5, Directory)
```

---

## 运行测试

### 编译测试

```bash
cargo test --test test_filesystem
```

### 预期输出

```
Running test: test_create_file
test_create_file... [ok]

Running test: test_write_read
test_write_read... [ok]

Running test: test_fd_table
test_fd_table... [ok]

Running test: test_create_directory
test_create_directory... [ok]

All tests passed!
```

### 测试失败示例

如果Inode分配有问题：

```
Running test: test_create_file
test_create_file... [failed]
assertion failed: file.lock().ino() == 2
  left: 1
  right: 2
```

---

## 扩展测试建议

### 测试5：多文件操作

```rust
#[test_case]
fn test_multiple_files() {
    serial_print!("test_multiple_files... ");

    let root = RAMFS.root();

    // 创建3个文件
    for i in 0..3 {
        let name = alloc::format!("file{}.txt", i);
        RAMFS.create_file(root.clone(), name).unwrap();
    }

    // 验证所有文件都存在
    for i in 0..3 {
        let name = alloc::format!("file{}.txt", i);
        assert!(root.lock().lookup(&name).is_ok());
    }

    serial_println!("[ok]");
}
```

### 测试6：边界条件

```rust
#[test_case]
fn test_edge_cases() {
    serial_print!("test_edge_cases... ");

    let root = RAMFS.root();
    let inode = RAMFS.create_file(root, String::from("edge.txt")).unwrap();
    let mut file = RAMFS.open_file(inode).unwrap();

    // 读空文件
    let mut buf = [0u8; 10];
    let n = file.read(&mut buf).unwrap();
    assert_eq!(n, 0);

    // 写入后seek到末尾
    file.write(b"test").unwrap();
    file.seek(os::fs::SeekFrom::End(0)).unwrap();

    // 从末尾读取（应返回0）
    let n = file.read(&mut buf).unwrap();
    assert_eq!(n, 0);

    serial_println!("[ok]");
}
```

### 测试7：错误处理

```rust
#[test_case]
fn test_error_handling() {
    serial_print!("test_error_handling... ");

    let root = RAMFS.root();

    // 创建重复文件应失败
    RAMFS.create_file(root.clone(), String::from("dup.txt")).unwrap();
    let result = RAMFS.create_file(root.clone(), String::from("dup.txt"));
    assert!(result.is_err());

    // 查找不存在的文件应失败
    let result = root.lock().lookup("nonexistent.txt");
    assert!(result.is_err());

    serial_println!("[ok]");
}
```

---

## 测试覆盖率分析

### 当前测试覆盖

| 功能模块 | 测试用例 | 覆盖率 |
|---------|---------|--------|
| 文件创建 | test_create_file | ✅ 100% |
| 文件读写 | test_write_read | ✅ 100% |
| FD管理 | test_fd_table | ✅ 100% |
| 目录创建 | test_create_directory | ✅ 100% |
| 目录查找 | test_write_read | ✅ 部分 |
| 错误处理 | - | ❌ 未覆盖 |
| 并发访问 | - | ❌ 未覆盖 |

### 未覆盖的功能

1. **目录删除** - remove_entry未测试
2. **目录列表** - list_entries未测试
3. **文件截断** - truncate未测试
4. **Seek边界** - 负数offset等
5. **并发写入** - 多线程测试

---

## 调试技巧

### 添加详细日志

```rust
#[test_case]
fn test_debug() {
    serial_println!("=== Starting test_debug ===");

    let root = RAMFS.root();
    serial_println!("Root inode: {}", root.lock().ino());

    let file = RAMFS.create_file(root.clone(), String::from("debug.txt")).unwrap();
    serial_println!("Created file with ino: {}", file.lock().ino());

    let mut handle = RAMFS.open_file(file).unwrap();
    serial_println!("Opened file, offset: 0");

    let n = handle.write(b"test").unwrap();
    serial_println!("Wrote {} bytes", n);

    serial_println!("=== Test completed ===");
}
```

### 使用assert_eq!而非assert!

```rust
// 不好：失败时无详细信息
assert!(n == 4);

// 好：失败时显示实际值
assert_eq!(n, 4);
```

### 打印错误信息

```rust
let result = RAMFS.create_file(root, name);
match result {
    Ok(file) => serial_println!("Created: {}", file.lock().ino()),
    Err(e) => serial_println!("Error: {:?}", e),
}
```

---

## 完整测试文件

<details>
<summary>展开查看完整的test_filesystem.rs</summary>

```rust
//! 文件系统测试

#![no_std]
#![no_main]
#![feature(custom_test_frameworks)]
#![test_runner(os::test_runner)]
#![reexport_test_harness_main = "test_main"]

use core::panic::PanicInfo;
use os::fs::{RAMFS, FD_TABLE, RamFile};
use os::{serial_println, serial_print};
use alloc::sync::Arc;
use spin::Mutex;
use alloc::string::String;

extern crate alloc;

#[no_mangle]
pub extern "C" fn _start() -> ! {
    test_main();
    loop {}
}

#[panic_handler]
fn panic(info: &PanicInfo) -> ! {
    os::test_panic_handler(info)
}

#[test_case]
fn test_create_file() {
    serial_print!("test_create_file... ");

    let root = RAMFS.root();
    let file = RAMFS.create_file(root.clone(), String::from("test.txt")).unwrap();

    assert_eq!(file.lock().ino(), 2); // root是1，这个文件是2

    serial_println!("[ok]");
}

#[test_case]
fn test_write_read() {
    serial_print!("test_write_read... ");

    let root = RAMFS.root();
    let inode = RAMFS.create_file(root, String::from("data.txt")).unwrap();
    let mut file = RAMFS.open_file(inode).unwrap();

    // 写入数据
    let data = b"Hello, RamFS!";
    let n = file.write(data).unwrap();
    assert_eq!(n, data.len());

    // 重置偏移
    file.seek(os::fs::SeekFrom::Start(0)).unwrap();

    // 读取数据
    let mut buf = [0u8; 20];
    let n = file.read(&mut buf).unwrap();
    assert_eq!(n, data.len());
    assert_eq!(&buf[..n], data);

    serial_println!("[ok]");
}

#[test_case]
fn test_fd_table() {
    serial_print!("test_fd_table... ");

    let root = RAMFS.root();
    let inode = RAMFS.create_file(root, String::from("fd_test.txt")).unwrap();
    let file = RAMFS.open_file(inode).unwrap();

    let file_arc: Arc<Mutex<dyn os::fs::File>> = Arc::new(Mutex::new(file));
    let fd = FD_TABLE.lock().alloc(file_arc).unwrap();

    assert!(fd >= 3); // 0-2是标准流

    // 验证可以获取文件
    assert!(FD_TABLE.lock().get(fd).is_some());

    // 关闭文件描述符
    assert!(FD_TABLE.lock().dealloc(fd));

    // 验证已释放
    assert!(FD_TABLE.lock().get(fd).is_none());

    serial_println!("[ok]");
}

#[test_case]
fn test_create_directory() {
    serial_print!("test_create_directory... ");

    let root = RAMFS.root();
    let dir = RAMFS.create_directory(root, String::from("testdir")).unwrap();

    assert_eq!(dir.lock().file_type(), os::fs::FileType::Directory);

    serial_println!("[ok]");
}
```

</details>

---

## 知识点总结

### 测试金字塔

```
        /\
       /  \
      / E2E\      (集成测试)
     /______\
    /        \
   /  集成测试 \   (本章测试)
  /____________\
 /              \
/    单元测试     \  (未来扩展)
/________________\
```

当前测试属于集成测试，验证多个模块协同工作。

### 测试原则

1. **独立性** - 每个测试互不干扰
2. **可重复** - 多次运行结果一致
3. **简洁性** - 每个测试只验证一个功能点
4. **全面性** - 覆盖正常和异常情况

### 测试命名规范

```rust
test_功能名称_预期结果

✅ test_create_file
✅ test_fd_alloc_returns_valid_fd
✅ test_read_empty_file_returns_zero

❌ test1
❌ test_file
❌ my_test
```

---

## 常见问题

**Q1: 为什么测试需要extern crate alloc？**

- 测试使用String::from()创建文件名
- String需要堆分配
- 必须显式引入alloc crate

**Q2: 测试之间会互相影响吗？**

当前实现：
- 所有测试共享全局RAMFS
- 后续测试会看到前面创建的文件
- 可通过文件名避免冲突

改进方案：
- 每个测试创建独立的RamFS实例
- 测试后清理文件系统

**Q3: 如何测试失败情况？**

```rust
// 测试预期失败
let result = RAMFS.create_file(root, String::from(""));
assert!(result.is_err());

// 测试特定错误
match result {
    Err(FileError::AlreadyExists) => {},
    _ => panic!("Expected AlreadyExists error"),
}
```

---

## 下一步

### 第7章完成！

你已经完成：
- ✅ 7.1 虚拟文件系统接口
- ✅ 7.2 简单文件系统实现
- ✅ 7.3 文件系统系统调用
- ✅ 7.4 文件系统测试

### 继续学习

- **第8章**：实现磁盘驱动（块设备）
- **第9章**：实现真实文件系统（FAT32）
- **第10章**：实现网络协议栈

### 扩展练习

1. 实现路径解析（支持/dir/file.txt）
2. 添加文件权限检查
3. 实现软链接和硬链接
4. 支持文件重命名
5. 实现文件元数据修改（chmod/chown）

---

## 参考资料

- [Rust测试文档](https://doc.rust-lang.org/book/ch11-00-testing.html)
- [xv6文件系统测试](https://github.com/mit-pdos/xv6-riscv/tree/riscv/user)
- [Linux文件系统测试套件](https://github.com/linux-test-project/ltp)
