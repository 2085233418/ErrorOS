# 7.3 文件系统系统调用

## 本节目标

- 添加文件系统相关系统调用号
- 实现sys_read系统调用
- 实现sys_write系统调用
- 实现sys_open系统调用（处理C字符串）
- 实现sys_close和sys_mkdir系统调用
- 更新系统调用分发器

---

## 本节修改文件

```
os/src/syscall/
├── mod.rs              # 添加系统调用号和分发逻辑（修改）
└── syscall_impl.rs     # 实现具体系统调用（修改）
```

---

## 系统调用概述

### 为什么需要系统调用？

**系统调用** 是用户态程序访问内核资源的唯一合法途径。

**类比**：系统调用就像银行柜台
- 用户不能直接进入金库（内核）
- 必须通过柜员（系统调用）办理业务
- 柜员验证身份（参数检查）后执行操作

### 文件系统系统调用列表

| 系统调用号 | 名称 | 功能 | 参数 |
|-----------|------|------|------|
| 63 | sys_read | 读取文件 | fd, buf, len |
| 64 | sys_write | 写入文件 | fd, buf, len |
| 56 | sys_open | 打开/创建文件 | path, flags |
| 57 | sys_close | 关闭文件 | fd |
| 34 | sys_mkdir | 创建目录 | path |

**系统调用号来源**：兼容Linux RISC-V调用约定

---

## 添加系统调用号

### 扩展SyscallId枚举

修改 `os/src/syscall/mod.rs`：

```rust
#[repr(usize)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum SyscallId {
    Read = 63,       // sys_read（第7章新增）
    Write = 64,      // sys_write
    Exit = 93,       // sys_exit
    GetPid = 172,    // sys_getpid
    Fork = 220,      // sys_fork（第6章新增）
    Exec = 221,      // sys_exec（第6章新增）
    WaitPid = 260,   // sys_waitpid（第6章新增）
    Open = 56,       // sys_open（第7章新增）
    Close = 57,      // sys_close（第7章新增）
    Mkdir = 34,      // sys_mkdir（第7章新增）
    Unknown = 9999,
}
```

### 更新From实现

```rust
impl From<usize> for SyscallId {
    fn from(id: usize) -> Self {
        match id {
            34 => SyscallId::Mkdir,
            56 => SyscallId::Open,
            57 => SyscallId::Close,
            63 => SyscallId::Read,
            64 => SyscallId::Write,
            93 => SyscallId::Exit,
            172 => SyscallId::GetPid,
            220 => SyscallId::Fork,
            221 => SyscallId::Exec,
            260 => SyscallId::WaitPid,
            _ => SyscallId::Unknown,
        }
    }
}
```

**注意**：按数字顺序排列，便于查找

---

## sys_read实现

### 函数签名

修改 `os/src/syscall/syscall_impl.rs`：

```rust
/// sys_read - 从文件描述符读取数据
pub fn sys_read(fd: usize, buf: *mut u8, len: usize) -> isize {
    if buf.is_null() {
        return -1;
    }

    let buffer = unsafe { core::slice::from_raw_parts_mut(buf, len) };

    // 获取文件并读取
    match FD_TABLE.lock().get(fd) {
        Some(file) => match file.lock().read(buffer) {
            Ok(n) => n as isize,
            Err(_) => -1,
        },
        None => -1,
    }
}
```

### 参数说明

- **fd**: 文件描述符（0=stdin, 1=stdout, 2=stderr, >=3用户文件）
- **buf**: 用户态缓冲区指针
- **len**: 缓冲区大小

### 安全性检查

**1. 空指针检查**

```rust
if buf.is_null() {
    return -1;
}
```

**为什么重要**：防止内核访问无效地址导致崩溃

**2. 构造切片**

```rust
let buffer = unsafe { core::slice::from_raw_parts_mut(buf, len) };
```

**unsafe原因**：从原始指针构造切片，需要保证：
- 指针有效
- 长度正确
- 内存可访问

### 读取流程

```
1. 验证指针有效
   ↓
2. 构造&mut [u8]切片
   ↓
3. 从FD_TABLE查找文件
   ↓
4. 调用file.read(buffer)
   ↓
5. 返回读取字节数（成功）或-1（失败）
```

### 错误处理

| 错误情况 | 返回值 |
|---------|--------|
| buf为空 | -1 |
| fd无效 | -1 |
| 读取失败 | -1 |
| 成功 | 读取字节数 |

---

## sys_write实现

### 函数实现

```rust
/// sys_write - 写入数据到文件描述符
pub fn sys_write(fd: usize, buf: *const u8, len: usize) -> isize {
    if buf.is_null() {
        return -1;
    }

    let slice = unsafe { core::slice::from_raw_parts(buf, len) };

    // 获取文件并写入
    match FD_TABLE.lock().get(fd) {
        Some(file) => match file.lock().write(slice) {
            Ok(n) => n as isize,
            Err(_) => -1,
        },
        None => {
            serial_println!("[SYSCALL] sys_write: invalid fd={}", fd);
            -1
        }
    }
}
```

### 与sys_read的区别

| 特性 | sys_read | sys_write |
|------|----------|-----------|
| 缓冲区类型 | `*mut u8` | `*const u8` |
| 切片类型 | `&mut [u8]` | `&[u8]` |
| 操作 | 读取到缓冲区 | 从缓冲区写入 |

**类比**：
- `sys_read` - 从文件倒水到杯子
- `sys_write` - 从杯子倒水到文件

### 使用场景

```rust
// 写入到stdout（控制台输出）
sys_write(1, b"Hello\n".as_ptr(), 6);

// 写入到文件
let fd = sys_open(b"test.txt\0".as_ptr(), 0);
sys_write(fd, b"data".as_ptr(), 4);
```

---

## sys_open实现

### C字符串问题

用户态通常传递C风格字符串（以`\0`结尾）：

```c
char* path = "test.txt";  // C字符串
open(path, O_RDWR);
```

内核需要解析C字符串为Rust的String。

### 函数实现

```rust
/// sys_open - 打开文件
pub fn sys_open(path: *const u8, flags: usize) -> isize {
    if path.is_null() {
        return -1;
    }

    // 读取路径字符串
    let path_str = unsafe {
        let mut len = 0;
        while *path.add(len) != 0 {
            len += 1;
            if len > 256 {
                return -1;
            }
        }
        let slice = core::slice::from_raw_parts(path, len);
        match core::str::from_utf8(slice) {
            Ok(s) => String::from(s),
            Err(_) => return -1,
        }
    };

    // 在根目录查找或创建文件
    let root = RAMFS.root();
    let inode = {
        let root_guard = root.lock();
        match root_guard.lookup(&path_str) {
            Ok(inode) => inode,
            Err(_) => {
                drop(root_guard);
                // 文件不存在，创建新文件
                match RAMFS.create_file(root.clone(), path_str) {
                    Ok(inode) => inode,
                    Err(_) => return -1,
                }
            }
        }
    };

    // 打开文件
    match RAMFS.open_file(inode) {
        Ok(file) => {
            let file_arc: Arc<Mutex<dyn crate::fs::File>> = Arc::new(Mutex::new(file));
            match FD_TABLE.lock().alloc(file_arc) {
                Some(fd) => fd as isize,
                None => -1,
            }
        }
        Err(_) => -1,
    }
}
```

### C字符串解析算法

```rust
let mut len = 0;
while *path.add(len) != 0 {  // 查找'\0'
    len += 1;
    if len > 256 {           // 防止无限循环
        return -1;
    }
}
```

**示例**：

```
内存: ['t', 'e', 's', 't', '.', 't', 'x', 't', '\0']
       0    1    2    3    4    5    6    7    8

len=0: path[0]='t' != 0, len++
len=1: path[1]='e' != 0, len++
...
len=8: path[8]='\0', 退出循环

结果: len=8, 读取"test.txt"
```

### UTF-8验证

```rust
let slice = core::slice::from_raw_parts(path, len);
match core::str::from_utf8(slice) {
    Ok(s) => String::from(s),
    Err(_) => return -1,
}
```

**作用**：确保路径是合法的UTF-8字符串

### 查找或创建逻辑

```
尝试查找文件
  ↓
找到了 -> 返回inode
  ↓
没找到 -> 创建新文件 -> 返回inode
  ↓
创建失败 -> 返回-1
```

### 锁的使用技巧

```rust
let inode = {
    let root_guard = root.lock();
    match root_guard.lookup(&path_str) {
        Ok(inode) => inode,
        Err(_) => {
            drop(root_guard);  // 手动释放锁！
            RAMFS.create_file(root.clone(), path_str)?
        }
    }
};
```

**为什么要drop**：
- `create_file`内部会再次锁定root
- 不释放会导致死锁

---

## sys_close实现

### 函数实现

```rust
/// sys_close - 关闭文件描述符
pub fn sys_close(fd: usize) -> isize {
    if FD_TABLE.lock().dealloc(fd) {
        0
    } else {
        -1
    }
}
```

**极简设计**：
- 调用FD_TABLE的dealloc方法
- 成功返回0，失败返回-1

### 使用场景

```rust
let fd = sys_open(b"test.txt\0".as_ptr(), 0);
sys_write(fd, b"data".as_ptr(), 4);
sys_close(fd);  // 释放FD
```

**注意**：关闭FD后，该FD号可以被复用

---

## sys_mkdir实现

### 函数实现

```rust
/// sys_mkdir - 创建目录
pub fn sys_mkdir(path: *const u8) -> isize {
    if path.is_null() {
        return -1;
    }

    let path_str = unsafe {
        let mut len = 0;
        while *path.add(len) != 0 {
            len += 1;
            if len > 256 {
                return -1;
            }
        }
        let slice = core::slice::from_raw_parts(path, len);
        match core::str::from_utf8(slice) {
            Ok(s) => String::from(s),
            Err(_) => return -1,
        }
    };

    let root = RAMFS.root();
    match RAMFS.create_directory(root, path_str) {
        Ok(_) => 0,
        Err(_) => -1,
    }
}
```

### 与sys_open的区别

| 系统调用 | 创建类型 | 是否返回FD |
|---------|---------|-----------|
| sys_open | 文件 | 是 |
| sys_mkdir | 目录 | 否 |

**类比**：
- `sys_open` - 打开文件并拿到钥匙（FD）
- `sys_mkdir` - 创建文件夹，不需要钥匙

---

## 更新系统调用分发器

### 添加新的分支

修改 `os/src/syscall/mod.rs` 的 `syscall_dispatcher` 函数：

```rust
pub fn syscall_dispatcher(context: &SyscallContext) -> isize {
    let syscall_id = SyscallId::from(context.syscall_id);

    // 可视化输出（可选）
    if cfg!(feature = "verbose_syscall") {
        print_syscall_entry(context, syscall_id);
    }

    let result = match syscall_id {
        SyscallId::Read => {
            syscall_impl::sys_read(
                context.arg0,
                context.arg1 as *mut u8,
                context.arg2,
            )
        }
        SyscallId::Write => {
            syscall_impl::sys_write(
                context.arg0,
                context.arg1 as *const u8,
                context.arg2,
            )
        }
        SyscallId::Open => {
            syscall_impl::sys_open(
                context.arg0 as *const u8,
                context.arg1,
            )
        }
        SyscallId::Close => {
            syscall_impl::sys_close(context.arg0)
        }
        SyscallId::Mkdir => {
            syscall_impl::sys_mkdir(context.arg0 as *const u8)
        }
        SyscallId::Exit => {
            syscall_impl::sys_exit(context.arg0 as i32)
        }
        SyscallId::GetPid => {
            syscall_impl::sys_getpid()
        }
        SyscallId::Fork => {
            syscall_impl::sys_fork()
        }
        SyscallId::Exec => {
            syscall_impl::sys_exec(context.arg0 as *const u8)
        }
        SyscallId::WaitPid => {
            syscall_impl::sys_waitpid(
                context.arg0 as isize,
                context.arg1 as *mut i32,
            )
        }
        SyscallId::Unknown => {
            serial_println!(
                "[SYSCALL] Unknown syscall: {} (syscall_id={})",
                context.syscall_id,
                context.syscall_id
            );
            -1
        }
    };

    // 可视化输出（可选）
    if cfg!(feature = "verbose_syscall") {
        print_syscall_exit(syscall_id, result);
    }

    result
}
```

### 参数类型转换

注意不同系统调用的参数类型：

```rust
// Read: buf需要可变指针
context.arg1 as *mut u8

// Write: buf是只读指针
context.arg1 as *const u8

// Open/Mkdir: path是C字符串指针
context.arg0 as *const u8

// Close: fd是usize
context.arg0
```

---

## 测试辅助函数

### 为什么需要test_syscall？

在内核测试中，无法通过ecall触发系统调用，需要直接调用分发器。

```rust
/// 简化的系统调用接口（用于内核测试）
pub fn test_syscall(syscall_id: usize, arg0: usize, arg1: usize, arg2: usize) -> isize {
    let context = SyscallContext {
        syscall_id,
        arg0,
        arg1,
        arg2,
        arg3: 0,
        arg4: 0,
        arg5: 0,
        sepc: 0,
    };
    syscall_dispatcher(&context)
}
```

### 使用示例

```rust
// 测试sys_write
let data = b"Hello";
let ret = test_syscall(
    64,  // SyscallId::Write
    1,   // stdout
    data.as_ptr() as usize,
    data.len()
);
assert_eq!(ret, 5);
```

---

## 完整调用链

### 用户态调用流程

```
用户程序
  ↓
write(1, "Hello", 5)  // 用户态封装
  ↓
ecall指令（触发异常）
  ↓
trap_handler（异常处理）
  ↓
SyscallContext::from_registers()
  ↓
syscall_dispatcher(context)
  ↓
sys_write(fd=1, buf=..., len=5)
  ↓
FD_TABLE.get(1) -> Stdout
  ↓
Stdout::write(b"Hello")
  ↓
println!("Hello")
  ↓
返回5（写入字节数）
```

### 数据流向

```
用户态缓冲区（虚拟地址）
  ↓
系统调用参数（寄存器a0-a5）
  ↓
内核栈（SyscallContext）
  ↓
FD_TABLE查找
  ↓
File trait对象
  ↓
RamFile（文件句柄）
  ↓
RamInode（文件数据）
  ↓
Vec<u8>（实际存储）
```

---

## 知识点总结

### 文件系统系统调用全貌

| 系统调用 | 主要操作 | 关键步骤 |
|---------|---------|---------|
| sys_read | 读取文件 | 验证指针 → 查找FD → 调用file.read |
| sys_write | 写入文件 | 验证指针 → 查找FD → 调用file.write |
| sys_open | 打开文件 | 解析C字符串 → 查找/创建文件 → 分配FD |
| sys_close | 关闭文件 | 释放FD → 清空FD表项 |
| sys_mkdir | 创建目录 | 解析C字符串 → 创建目录Inode |

### C字符串处理要点

1. **查找'\0'终止符**
2. **限制最大长度**（防止无限循环）
3. **UTF-8验证**（确保字符串合法）
4. **错误处理**（返回-1）

### 安全性检查

1. **空指针检查**：`if buf.is_null()`
2. **FD有效性检查**：`FD_TABLE.get(fd)`
3. **UTF-8验证**：`str::from_utf8()`
4. **长度限制**：`if len > 256`

---

## 常见问题

**Q1: 为什么sys_open不支持路径层级（/dir/file.txt）？**

当前实现只支持根目录下的文件。扩展方法：
```rust
// 按'/'分割路径
let parts: Vec<&str> = path.split('/').collect();
// 逐级查找目录
```

**Q2: 为什么用Arc<Mutex<dyn File>>而不是Box？**

- Arc：多个FD可以指向同一个文件（共享所有权）
- Mutex：多线程安全访问
- dyn File：支持不同文件类型（RamFile/Stdout/Stdin）

**Q3: sys_open的flags参数有什么用？**

当前未使用，扩展时可支持：
- O_RDONLY (0) - 只读
- O_WRONLY (1) - 只写
- O_RDWR (2) - 读写
- O_CREAT (0x40) - 不存在则创建

---

## 下一步

- 7.1 虚拟文件系统接口
- 7.2 简单文件系统实现
- 7.3 文件系统系统调用（本节）
- 7.4 文件系统测试
