# 进程管理可视化测试

## 测试文件位置

`os/tests/test_process_management.rs`

## 测试内容

这个测试套件包含6个测试用例，全面验证进程管理模块的各项功能：

### 测试1：PID分配器
- **功能**：验证PID分配的唯一性和单调性
- **验证点**：
  - ✅ 每次分配的PID都不相同
  - ✅ PID单调递增
  - ✅ 从1开始分配

### 测试2：进程状态转换
- **功能**：模拟进程完整生命周期的状态转换
- **流程**：
  ```
  Ready → Running → Ready → Running → Blocked → Ready → Running → Zombie
  ```
- **验证点**：
  - ✅ 所有状态转换都合法
  - ✅ 状态枚举正确
  - ✅ 可视化展示每一步转换

### 测试3：PCB创建和管理
- **功能**：创建多个进程并验证PCB信息
- **验证点**：
  - ✅ 进程名称正确
  - ✅ 父子关系正确
  - ✅ 进程树结构正确
  - ✅ 可视化进程树

### 测试4：时间片管理
- **功能**：验证时间片消耗和调度触发机制
- **验证点**：
  - ✅ 时间片从5开始
  - ✅ 每次tick()减少1
  - ✅ 减到0时返回true（触发调度）
  - ✅ 可视化时间片消耗过程

### 测试5：父子进程关系
- **功能**：验证父进程管理子进程列表
- **验证点**：
  - ✅ 可以添加子进程
  - ✅ 子进程列表正确
  - ✅ 可以移除子进程
  - ✅ 可视化进程树结构

### 测试6：进程退出和僵尸状态
- **功能**：验证进程退出机制
- **验证点**：
  - ✅ 进程退出后状态变为Zombie
  - ✅ 退出码被正确保存
  - ✅ PCB仍然保留
  - ✅ 可以被父进程查询

---

## 如何运行测试

### 运行所有测试

```bash
cargo test --test test_process_management -- --nocapture
```

### 运行单个测试

```bash
# 测试1：PID分配器
cargo test test_pid_allocation -- --nocapture

# 测试2：进程状态转换
cargo test test_process_state_transitions -- --nocapture

# 测试3：PCB创建
cargo test test_pcb_creation -- --nocapture

# 测试4：时间片管理
cargo test test_time_slice -- --nocapture

# 测试5：父子进程关系
cargo test test_parent_child_relationship -- --nocapture

# 测试6：进程退出
cargo test test_process_exit -- --nocapture
```

---

## 测试输出示例

### 测试1输出示例

```
╔════════════════════════════════════════════════════╗
║          测试1：PID分配器                          ║
╠════════════════════════════════════════════════════╣
║ 说明：验证PID分配的唯一性和单调性                 ║
╠════════════════════════════════════════════════════╣
║ 步骤1: 分配新PID → PID = 1                        ║
║ 步骤2: 分配新PID → PID = 2                        ║
║ 步骤3: 分配新PID → PID = 3                        ║
║ 步骤4: 分配新PID → PID = 4                        ║
║ 步骤5: 分配新PID → PID = 5                        ║
╠════════════════════════════════════════════════════╣
║ 验证结果：                                         ║
║   ✓ PID唯一性：通过                               ║
║   ✓ PID单调递增：通过                             ║
╚════════════════════════════════════════════════════╝
```

### 测试4输出示例（时间片）

```
╔════════════════════════════════════════════════════╗
║          测试4：时间片管理                         ║
╠════════════════════════════════════════════════════╣
║ 说明：验证时间片的消耗和重置机制                   ║
╠════════════════════════════════════════════════════╣
║                                                    ║
║ 初始状态：                                         ║
║   时间片 = 5                                       ║
║   ┌───┬───┬───┬───┬───┐                           ║
║   │ ● │ ● │ ● │ ● │ ● │  (5个时钟周期)            ║
║   └───┴───┴───┴───┴───┘                           ║
║                                                    ║
║ 时钟中断 #1: tick()                               ║
║   ┌───┬───┬───┬───┬───┐                           ║
║   │ ● │ ● │ ● │ ● │ ✕ │                           ║
║   └───┴───┴───┴───┴───┘                           ║
║   → 还有时间片，继续执行                          ║
║                                                    ║
║ 时钟中断 #2: tick()                               ║
║   ┌───┬───┬───┬───┬───┐                           ║
║   │ ● │ ● │ ● │ ✕ │ ✕ │                           ║
║   └───┴───┴───┴───┴───┘                           ║
║   → 还有时间片，继续执行                          ║
...
║                                                    ║
║ 时钟中断 #5: tick()                               ║
║   ┌───┬───┬───┬───┬───┐                           ║
║   │ ✕ │ ✕ │ ✕ │ ✕ │ ✕ │                           ║
║   └───┴───┴───┴───┴───┘                           ║
║   → 时间片用完！触发调度                          ║
╚════════════════════════════════════════════════════╝
```

---

## 可视化特点

### 1. 清晰的框线结构
- 使用Unicode框线字符绘制表格
- 层次清晰，易于阅读

### 2. ASCII艺术图
- 时间片用 `●` (剩余) 和 `✕` (已用) 表示
- 进程树用 `├─` 和 `└─` 表示层级关系

### 3. 状态转换可视化
- 每一步都有图示说明
- 箭头表示状态转换方向

### 4. 实时信息
- 显示PID、状态、子进程数等实时信息
- 每一步都有详细说明

---

## 测试覆盖率

| 模块 | 功能点 | 测试覆盖 |
|------|--------|----------|
| **PID分配器** | PID唯一性 | ✅ |
| | PID单调性 | ✅ |
| | 原子性 | ✅ |
| **进程状态** | 4种状态定义 | ✅ |
| | 状态转换 | ✅ |
| | Display实现 | ✅ |
| **PCB结构** | 创建和初始化 | ✅ |
| | 父子关系 | ✅ |
| | 进程树 | ✅ |
| **时间片** | 消耗机制 | ✅ |
| | 调度触发 | ✅ |
| | 重置功能 | ✅ |
| **进程退出** | Zombie状态 | ✅ |
| | 退出码保存 | ✅ |
| | PCB保留 | ✅ |

---

## 注意事项

1. **必须启用 `--nocapture` 标志**
   - 否则看不到可视化输出
   - `cargo test` 默认会捕获stdout

2. **测试顺序**
   - 测试按照从简单到复杂的顺序排列
   - 建议先运行单个测试理解功能

3. **依赖关系**
   - 需要 `alloc` crate（动态内存分配）
   - 需要 `serial_println!` 宏（输出）

4. **性能考虑**
   - 可视化输出会稍微增加测试时间
   - 但对理解系统行为非常有帮助

---

## 扩展建议

后续可以添加更多测试：

1. **并发测试**
   - 多个CPU核心同时分配PID
   - 验证原子性

2. **压力测试**
   - 创建大量进程（如1000个）
   - 验证性能

3. **错误处理**
   - 测试异常情况（如PID溢出）
   - 验证错误恢复

4. **调度器集成**
   - 测试完整的调度流程
   - 验证上下文切换

5. **系统调用集成**
   - 测试fork/exec/exit/wait
   - 验证端到端流程
