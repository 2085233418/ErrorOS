# ============================================
# RISC-V 上下文切换汇编代码
# ============================================
# 功能：在两个进程之间切换执行上下文
#
# 函数签名：
# extern "C" fn switch_context(
#     current_context: *mut ProcessContext,
#     next_context: *const ProcessContext
# );
#
# 参数：
# - a0: 当前进程上下文指针（保存目标）
# - a1: 下一个进程上下文指针（恢复源）
#
# 说明：
# 1. 保存当前进程的所有寄存器到 *a0
# 2. 从 *a1 恢复下一个进程的所有寄存器
# 3. 切换页表（satp寄存器）
# 4. 返回到新进程继续执行
#
# 注意：
# - 上下文结构体字段顺序必须与 context.rs 一致
# - 使用 sd/ld 指令（64位）
# - 偏移量以字节为单位（每个寄存器8字节）
# ============================================

.section .text
.globl switch_context
.align 4

switch_context:
    # ============================================
    # 第一步：保存当前进程的上下文到 *a0
    # ============================================

    # 通用寄存器（按 ProcessContext 结构体顺序）
    sd ra, 0*8(a0)      # 保存返回地址
    sd sp, 1*8(a0)      # 保存栈指针
    sd gp, 2*8(a0)      # 保存全局指针
    sd tp, 3*8(a0)      # 保存线程指针

    # 临时寄存器 t0-t6
    sd t0, 4*8(a0)
    sd t1, 5*8(a0)
    sd t2, 6*8(a0)
    sd t3, 7*8(a0)
    sd t4, 8*8(a0)
    sd t5, 9*8(a0)
    sd t6, 10*8(a0)

    # 保存寄存器 s0-s11
    sd s0, 11*8(a0)
    sd s1, 12*8(a0)
    sd s2, 13*8(a0)
    sd s3, 14*8(a0)
    sd s4, 15*8(a0)
    sd s5, 16*8(a0)
    sd s6, 17*8(a0)
    sd s7, 18*8(a0)
    sd s8, 19*8(a0)
    sd s9, 20*8(a0)
    sd s10, 21*8(a0)
    sd s11, 22*8(a0)

    # 参数寄存器 a0-a7
    # 注意：a0 和 a1 是参数，保存的是调用时的值
    sd a0, 23*8(a0)
    sd a1, 24*8(a0)
    sd a2, 25*8(a0)
    sd a3, 26*8(a0)
    sd a4, 27*8(a0)
    sd a5, 28*8(a0)
    sd a6, 29*8(a0)
    sd a7, 30*8(a0)

    # ============================================
    # 保存 CSR 寄存器
    # ============================================

    # 保存 sepc（异常程序计数器）
    csrr t0, sepc
    sd t0, 31*8(a0)

    # 保存 sstatus（状态寄存器）
    csrr t0, sstatus
    sd t0, 32*8(a0)

    # 保存 satp（页表基址）
    csrr t0, satp
    sd t0, 33*8(a0)

    # ============================================
    # 第二步：从 *a1 恢复下一个进程的上下文
    # ============================================

    # 通用寄存器
    ld ra, 0*8(a1)
    ld sp, 1*8(a1)
    ld gp, 2*8(a1)
    ld tp, 3*8(a1)

    # 临时寄存器 t0-t6
    # 注意：t0-t2 暂时不恢复，用于后续操作
    ld t3, 7*8(a1)
    ld t4, 8*8(a1)
    ld t5, 9*8(a1)
    ld t6, 10*8(a1)

    # 保存寄存器 s0-s11
    ld s0, 11*8(a1)
    ld s1, 12*8(a1)
    ld s2, 13*8(a1)
    ld s3, 14*8(a1)
    ld s4, 15*8(a1)
    ld s5, 16*8(a1)
    ld s6, 17*8(a1)
    ld s7, 18*8(a1)
    ld s8, 19*8(a1)
    ld s9, 20*8(a1)
    ld s10, 21*8(a1)
    ld s11, 22*8(a1)

    # 参数寄存器 a0-a7
    # 注意：先恢复 a2-a7，最后恢复 a0-a1
    ld a2, 25*8(a1)
    ld a3, 26*8(a1)
    ld a4, 27*8(a1)
    ld a5, 28*8(a1)
    ld a6, 29*8(a1)
    ld a7, 30*8(a1)

    # ============================================
    # 第三步：恢复 CSR 寄存器
    # ============================================

    # 恢复 sepc
    ld t0, 31*8(a1)
    csrw sepc, t0

    # 恢复 sstatus
    ld t0, 32*8(a1)
    csrw sstatus, t0

    # 恢复 satp（切换页表）
    ld t0, 33*8(a1)
    csrw satp, t0

    # 刷新 TLB（Translation Lookaside Buffer）
    # sfence.vma 指令确保页表更改生效
    sfence.vma

    # ============================================
    # 第四步：恢复剩余寄存器并返回
    # ============================================

    # 恢复 t0-t2
    ld t0, 4*8(a1)
    ld t1, 5*8(a1)
    ld t2, 6*8(a1)

    # 最后恢复 a0-a1
    ld a0, 23*8(a1)
    ld a1, 24*8(a1)

    # 返回到新进程
    # ra 已经被恢复为新进程的返回地址
    ret

# ============================================
# 辅助函数：从内核态进入用户态
# ============================================
# 用于首次启动用户进程
#
# extern "C" fn enter_user_mode(context: *const ProcessContext);
# ============================================

.globl enter_user_mode
.align 4

enter_user_mode:
    # a0: ProcessContext 指针

    # 恢复所有通用寄存器
    ld ra, 0*8(a0)
    ld sp, 1*8(a0)
    ld gp, 2*8(a0)
    ld tp, 3*8(a0)

    ld t0, 4*8(a0)
    ld t1, 5*8(a0)
    ld t2, 6*8(a0)
    ld t3, 7*8(a0)
    ld t4, 8*8(a0)
    ld t5, 9*8(a0)
    ld t6, 10*8(a0)

    ld s0, 11*8(a0)
    ld s1, 12*8(a0)
    ld s2, 13*8(a0)
    ld s3, 14*8(a0)
    ld s4, 15*8(a0)
    ld s5, 16*8(a0)
    ld s6, 17*8(a0)
    ld s7, 18*8(a0)
    ld s8, 19*8(a0)
    ld s9, 20*8(a0)
    ld s10, 21*8(a0)
    ld s11, 22*8(a0)

    # 恢复 CSR 寄存器
    ld t0, 31*8(a0)
    csrw sepc, t0

    ld t0, 32*8(a0)
    csrw sstatus, t0

    ld t0, 33*8(a0)
    csrw satp, t0
    sfence.vma

    # 恢复参数寄存器
    ld a1, 24*8(a0)
    ld a2, 25*8(a0)
    ld a3, 26*8(a0)
    ld a4, 27*8(a0)
    ld a5, 28*8(a0)
    ld a6, 29*8(a0)
    ld a7, 30*8(a0)
    ld a0, 23*8(a0)

    # 使用 sret 指令返回用户态
    # sret 会：
    # 1. 恢复特权级（sstatus.SPP -> 当前特权级）
    # 2. PC = sepc
    # 3. 恢复中断状态（sstatus.SPIE -> sstatus.SIE）
    sret
